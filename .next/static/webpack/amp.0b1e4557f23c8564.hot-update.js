"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/next/dist/client/dev/amp-dev.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/dev/amp-dev.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/regenerator-runtime/runtime.js */ \"./node_modules/regenerator-runtime/runtime.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar _fouc = __webpack_require__(/*! ./fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nvar _onDemandEntriesClient = _interopRequireDefault1(__webpack_require__(/*! ./on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\nwindow.__NEXT_DATA__ = data;\nvar assetPrefix = data.assetPrefix, page = data.page;\nassetPrefix = assetPrefix || '';\nvar mostRecentHash = null;\n/* eslint-disable-next-line */ var curHash = __webpack_require__.h();\nvar hotUpdatePath = assetPrefix + (assetPrefix.endsWith('/') ? '' : '/') + '_next/static/webpack/';\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n    // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    /* eslint-disable-next-line */ return mostRecentHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === 'idle';\n}\nfunction _tryApplyUpdates() {\n    _tryApplyUpdates = // reloads the page when it has changed.\n    _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n        var res, jsonData, curPage, pageUpdated;\n        return _runtimeJs.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (!(!isUpdateAvailable() || !canApplyUpdates())) {\n                        _ctx.next = 2;\n                        break;\n                    }\n                    return _ctx.abrupt(\"return\");\n                case 2:\n                    _ctx.prev = 2;\n                    _ctx.next = 5;\n                    return fetch(typeof __webpack_require__.j !== 'undefined' ? \"\".concat(hotUpdatePath).concat(curHash, \".\").concat(__webpack_require__.j, \".hot-update.json\") : \"\".concat(hotUpdatePath).concat(curHash, \".hot-update.json\"));\n                case 5:\n                    res = _ctx.sent;\n                    _ctx.next = 8;\n                    return res.json();\n                case 8:\n                    jsonData = _ctx.sent;\n                    curPage = page === '/' ? 'index' : page;\n                    pageUpdated = (Array.isArray(jsonData.c) ? jsonData.c : Object.keys(jsonData.c)).some(function(mod) {\n                        return mod.indexOf(\"pages\".concat(curPage.substr(0, 1) === '/' ? curPage : \"/\".concat(curPage))) !== -1 || mod.indexOf(\"pages\".concat(curPage.substr(0, 1) === '/' ? curPage : \"/\".concat(curPage)).replace(/\\//g, '\\\\')) !== -1;\n                    });\n                    if (pageUpdated) {\n                        document.location.reload(true);\n                    } else {\n                        curHash = mostRecentHash;\n                    }\n                    _ctx.next = 18;\n                    break;\n                case 14:\n                    _ctx.prev = 14;\n                    _ctx.t0 = _ctx[\"catch\"](2);\n                    console.error('Error occurred checking for update', _ctx.t0);\n                    document.location.reload(true);\n                case 18:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                2,\n                14\n            ]\n        ]);\n    }));\n    return _tryApplyUpdates.apply(this, arguments);\n}\nfunction tryApplyUpdates() {\n    return _tryApplyUpdates.apply(this, arguments);\n}\n(0, _websocket).addMessageListener(function(event) {\n    if (event.data === '\\ud83d\\udc93') {\n        return;\n    }\n    try {\n        var message = JSON.parse(event.data);\n        if (message.action === 'sync' || message.action === 'built') {\n            if (!message.hash) {\n                return;\n            }\n            mostRecentHash = message.hash;\n            tryApplyUpdates();\n        } else if (message.action === 'reloadPage') {\n            document.location.reload(true);\n        }\n    } catch (ex) {\n        console.warn('Invalid HMR message: ' + event.data + '\\n' + ex);\n    }\n});\n(0, _websocket).connectHMR({\n    assetPrefix: assetPrefix,\n    path: '/_next/webpack-hmr'\n});\n(0, _fouc).displayContent();\n(0, _onDemandEntriesClient).default(data.page); //# sourceMappingURL=amp-dev.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvYW1wLWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7QUFDWixHQUFHLENBQUNBLEtBQUssR0FBR0MsbUJBQU8sQ0FBQywyREFBUTtBQUM1QixHQUFHLENBQUNDLHNCQUFzQixHQUFHQyx1QkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyxtR0FBNEI7QUFDeEYsR0FBRyxDQUFDRyxVQUFVLEdBQUdILG1CQUFPLENBQUMsaUdBQTJCO1NBQzNDSSxrQkFBa0IsQ0FBQ0MsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFLENBQUM7SUFDeEUsR0FBRyxDQUFDLENBQUM7UUFDRCxHQUFHLENBQUNDLElBQUksR0FBR1AsR0FBRyxDQUFDSyxHQUFHLEVBQUVDLEdBQUc7UUFDdkIsR0FBRyxDQUFDRSxLQUFLLEdBQUdELElBQUksQ0FBQ0MsS0FBSztJQUMxQixDQUFDLENBQUMsS0FBSyxFQUFFQyxLQUFLLEVBQUUsQ0FBQztRQUNiUCxNQUFNLENBQUNPLEtBQUs7UUFDWixNQUFNO0lBQ1YsQ0FBQztJQUNELEVBQUUsRUFBRUYsSUFBSSxDQUFDRyxJQUFJLEVBQUUsQ0FBQztRQUNaVCxPQUFPLENBQUNPLEtBQUs7SUFDakIsQ0FBQyxNQUFNLENBQUM7UUFDSkcsT0FBTyxDQUFDVixPQUFPLENBQUNPLEtBQUssRUFBRUksSUFBSSxDQUFDVCxLQUFLLEVBQUVDLE1BQU07SUFDN0MsQ0FBQztBQUNMLENBQUM7U0FDUVMsaUJBQWlCLENBQUNDLEVBQUUsRUFBRSxDQUFDO0lBQzVCLE1BQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQztRQUNmLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLElBQUksRUFBRUMsSUFBSSxHQUFHQyxTQUFTO1FBQ2pDLE1BQU0sQ0FBQyxHQUFHLENBQUNOLE9BQU8sQ0FBQyxRQUFRLENBQUNWLE9BQU8sRUFBRUMs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UUFDRCxHQUFLLENBQUM0QyxPQUFPLEdBQUczQyxJQUFJLENBQUNDLEtBQUssQ0FBQ3lDLEtBQUssQ0FBQzNDLElBQUk7UUFDckMsRUFBRSxFQUFFNEMsT0FBTyxDQUFDQyxNQUFNLEtBQUssQ0FBTSxTQUFJRCxPQUFPLENBQUNDLE1BQU0sS0FBSyxDQUFPLFFBQUUsQ0FBQztZQUMxRCxFQUFFLEdBQUdELE9BQU8sQ0FBQ0UsSUFBSSxFQUFFLENBQUM7Z0JBQ2hCLE1BQU07WUFDVixDQUFDO1lBQ0RwQyxjQUFjLEdBQUdrQyxPQUFPLENBQUNFLElBQUk7WUFDN0JMLGVBQWU7UUFDbkIsQ0FBQyxNQUFNLEVBQUUsRUFBRUcsT0FBTyxDQUFDQyxNQUFNLEtBQUssQ0FBWSxhQUFFLENBQUM7WUFDekMxQyxRQUFRLENBQUNtQyxRQUFRLENBQUNDLE1BQU0sQ0FBQyxJQUFJO1FBQ2pDLENBQUM7SUFDTCxDQUFDLENBQUMsS0FBSyxFQUFFUSxFQUFFLEVBQUUsQ0FBQztRQUNWUCxPQUFPLENBQUNRLElBQUksQ0FBQyxDQUF1Qix5QkFBR0wsS0FBSyxDQUFDM0MsSUFBSSxHQUFHLENBQUksTUFBRytDLEVBQUU7SUFDakUsQ0FBQztBQUNMLENBQUM7Q0FDQSxDQUFDLEVBQUV6RSxVQUFVLEVBQUUyRSxVQUFVLENBQUMsQ0FBQztJQUN4QnpDLFdBQVcsRUFBWEEsV0FBVztJQUNYMEMsSUFBSSxFQUFFLENBQW9CO0FBQzlCLENBQUM7Q0FDQSxDQUFDLEVBQUVoRixLQUFLLEVBQUVpRixjQUFjO0NBQ3hCLENBQUMsRUFBRS9FLHNCQUFzQixFQUFFMkIsT0FBTyxDQUFDQyxJQUFJLENBQUNTLElBQUksRUFFN0MsQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2FtcC1kZXYuanM/NWNjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZm91YyA9IHJlcXVpcmUoXCIuL2ZvdWNcIik7XG52YXIgX29uRGVtYW5kRW50cmllc0NsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vb24tZGVtYW5kLWVudHJpZXMtY2xpZW50XCIpKTtcbnZhciBfd2Vic29ja2V0ID0gcmVxdWlyZShcIi4vZXJyb3Itb3ZlcmxheS93ZWJzb2NrZXRcIik7XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fTkVYVF9EQVRBX18nKS50ZXh0Q29udGVudCk7XG53aW5kb3cuX19ORVhUX0RBVEFfXyA9IGRhdGE7XG5sZXQgeyBhc3NldFByZWZpeCAsIHBhZ2UgIH0gPSBkYXRhO1xuYXNzZXRQcmVmaXggPSBhc3NldFByZWZpeCB8fCAnJztcbmxldCBtb3N0UmVjZW50SGFzaCA9IG51bGw7XG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi8gbGV0IGN1ckhhc2ggPSBfX3dlYnBhY2tfaGFzaF9fO1xuY29uc3QgaG90VXBkYXRlUGF0aCA9IGFzc2V0UHJlZml4ICsgKGFzc2V0UHJlZml4LmVuZHNXaXRoKCcvJykgPyAnJyA6ICcvJykgKyAnX25leHQvc3RhdGljL3dlYnBhY2svJztcbi8vIElzIHRoZXJlIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGlzIGNvZGUgYXZhaWxhYmxlP1xuZnVuY3Rpb24gaXNVcGRhdGVBdmFpbGFibGUoKSB7XG4gICAgLy8gX193ZWJwYWNrX2hhc2hfXyBpcyB0aGUgaGFzaCBvZiB0aGUgY3VycmVudCBjb21waWxhdGlvbi5cbiAgICAvLyBJdCdzIGEgZ2xvYmFsIHZhcmlhYmxlIGluamVjdGVkIGJ5IFdlYnBhY2suXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovIHJldHVybiBtb3N0UmVjZW50SGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfXztcbn1cbi8vIFdlYnBhY2sgZGlzYWxsb3dzIHVwZGF0ZXMgaW4gb3RoZXIgc3RhdGVzLlxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCkge1xuICAgIHJldHVybiBtb2R1bGUuaG90LnN0YXR1cygpID09PSAnaWRsZSc7XG59XG5mdW5jdGlvbiBfdHJ5QXBwbHlVcGRhdGVzKCkge1xuICAgIF90cnlBcHBseVVwZGF0ZXMgPSAvLyBUaGlzIGZ1bmN0aW9uIHJlYWRzIGNvZGUgdXBkYXRlcyBvbiB0aGUgZmx5IGFuZCBoYXJkXG4gICAgLy8gcmVsb2FkcyB0aGUgcGFnZSB3aGVuIGl0IGhhcyBjaGFuZ2VkLlxuICAgIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgaWYgKCFpc1VwZGF0ZUF2YWlsYWJsZSgpIHx8ICFjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCBmZXRjaCh0eXBlb2YgX193ZWJwYWNrX3J1bnRpbWVfaWRfXyAhPT0gJ3VuZGVmaW5lZCcgPyBgJHtob3RVcGRhdGVQYXRofSR7Y3VySGFzaH0uJHtfX3dlYnBhY2tfcnVudGltZV9pZF9ffS5ob3QtdXBkYXRlLmpzb25gIDogYCR7aG90VXBkYXRlUGF0aH0ke2N1ckhhc2h9LmhvdC11cGRhdGUuanNvbmApO1xuICAgICAgICAgICAgY29uc3QganNvbkRhdGEgPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgY3VyUGFnZSA9IHBhZ2UgPT09ICcvJyA/ICdpbmRleCcgOiBwYWdlO1xuICAgICAgICAgICAgLy8gd2VicGFjayA1IHVzZXMgYW4gYXJyYXkgaW5zdGVhZFxuICAgICAgICAgICAgY29uc3QgcGFnZVVwZGF0ZWQgPSAoQXJyYXkuaXNBcnJheShqc29uRGF0YS5jKSA/IGpzb25EYXRhLmMgOiBPYmplY3Qua2V5cyhqc29uRGF0YS5jKSkuc29tZSgobW9kKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2QuaW5kZXhPZihgcGFnZXMke2N1clBhZ2Uuc3Vic3RyKDAsIDEpID09PSAnLycgPyBjdXJQYWdlIDogYC8ke2N1clBhZ2V9YH1gKSAhPT0gLTEgfHwgbW9kLmluZGV4T2YoYHBhZ2VzJHtjdXJQYWdlLnN1YnN0cigwLCAxKSA9PT0gJy8nID8gY3VyUGFnZSA6IGAvJHtjdXJQYWdlfWB9YC5yZXBsYWNlKC9cXC8vZywgJ1xcXFwnKSkgIT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGFnZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ckhhc2ggPSBtb3N0UmVjZW50SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvY2N1cnJlZCBjaGVja2luZyBmb3IgdXBkYXRlJywgZXJyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfdHJ5QXBwbHlVcGRhdGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXMoKSB7XG4gICAgcmV0dXJuIF90cnlBcHBseVVwZGF0ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbigwLCBfd2Vic29ja2V0KS5hZGRNZXNzYWdlTGlzdGVuZXIoKGV2ZW50KT0+e1xuICAgIGlmIChldmVudC5kYXRhID09PSAnXFx1RDgzRFxcdURDOTMnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ3N5bmMnIHx8IG1lc3NhZ2UuYWN0aW9uID09PSAnYnVpbHQnKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vc3RSZWNlbnRIYXNoID0gbWVzc2FnZS5oYXNoO1xuICAgICAgICAgICAgdHJ5QXBwbHlVcGRhdGVzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5hY3Rpb24gPT09ICdyZWxvYWRQYWdlJykge1xuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEhNUiBtZXNzYWdlOiAnICsgZXZlbnQuZGF0YSArICdcXG4nICsgZXgpO1xuICAgIH1cbn0pO1xuKDAsIF93ZWJzb2NrZXQpLmNvbm5lY3RITVIoe1xuICAgIGFzc2V0UHJlZml4LFxuICAgIHBhdGg6ICcvX25leHQvd2VicGFjay1obXInXG59KTtcbigwLCBfZm91YykuZGlzcGxheUNvbnRlbnQoKTtcbigwLCBfb25EZW1hbmRFbnRyaWVzQ2xpZW50KS5kZWZhdWx0KGRhdGEucGFnZSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIl9mb3VjIiwicmVxdWlyZSIsIl9vbkRlbWFuZEVudHJpZXNDbGllbnQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3dlYnNvY2tldCIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJ2YWx1ZSIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwidGV4dENvbnRlbnQiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwiYXNzZXRQcmVmaXgiLCJwYWdlIiwibW9zdFJlY2VudEhhc2giLCJjdXJIYXNoIiwiX193ZWJwYWNrX2hhc2hfXyIsImhvdFVwZGF0ZVBhdGgiLCJlbmRzV2l0aCIsImlzVXBkYXRlQXZhaWxhYmxlIiwiY2FuQXBwbHlVcGRhdGVzIiwibW9kdWxlIiwiaG90Iiwic3RhdHVzIiwiX3RyeUFwcGx5VXBkYXRlcyIsInJlcyIsImpzb25EYXRhIiwiY3VyUGFnZSIsInBhZ2VVcGRhdGVkIiwiZmV0Y2giLCJfX3dlYnBhY2tfcnVudGltZV9pZF9fIiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsImMiLCJPYmplY3QiLCJrZXlzIiwic29tZSIsIm1vZCIsImluZGV4T2YiLCJzdWJzdHIiLCJyZXBsYWNlIiwibG9jYXRpb24iLCJyZWxvYWQiLCJjb25zb2xlIiwidHJ5QXBwbHlVcGRhdGVzIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiZXZlbnQiLCJtZXNzYWdlIiwiYWN0aW9uIiwiaGFzaCIsImV4Iiwid2FybiIsImNvbm5lY3RITVIiLCJwYXRoIiwiZGlzcGxheUNvbnRlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/amp-dev.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/regenerator-runtime/runtime.js */ \"./node_modules/regenerator-runtime/runtime.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _router = _interopRequireDefault1(__webpack_require__(/*! next/router */ \"./node_modules/next/router.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar _default = _asyncToGenerator(_runtimeJs.default.mark(function _callee(page) {\n    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n        while(1)switch(_ctx.prev = _ctx.next){\n            case 0:\n                if (page) {\n                    // in AMP the router isn't initialized on the client and\n                    // client-transitions don't occur so ping initial page\n                    setInterval(function() {\n                        (0, _websocket).sendMessage(JSON.stringify({\n                            event: 'ping',\n                            page: page\n                        }));\n                    }, 2500);\n                } else {\n                    _router.default.ready(function() {\n                        setInterval(function() {\n                            (0, _websocket).sendMessage(JSON.stringify({\n                                event: 'ping',\n                                page: _router.default.pathname\n                            }));\n                        }, 2500);\n                    });\n                }\n                (0, _websocket).addMessageListener(function(event) {\n                    if (event.data.indexOf('{') === -1) return;\n                    try {\n                        var payload = JSON.parse(event.data);\n                        // don't attempt fetching the page if we're already showing\n                        // the dev overlay as this can cause the error to be triggered\n                        // repeatedly\n                        if (payload.event === 'pong' && payload.invalid && !self.__NEXT_DATA__.err) {\n                            // Payload can be invalid even if the page does exist.\n                            // So, we check if it can be created.\n                            fetch(location.href, {\n                                credentials: 'same-origin'\n                            }).then(function(pageRes) {\n                                if (pageRes.status === 200) {\n                                    // Page exists now, reload\n                                    location.reload();\n                                } else {\n                                    // Page doesn't exist\n                                    if (self.__NEXT_DATA__.page === _router.default.pathname && _router.default.pathname !== '/_error') {\n                                        // We are still on the page,\n                                        // reload to show 404 error page\n                                        location.reload();\n                                    }\n                                }\n                            });\n                        }\n                    } catch (err) {\n                        console.error('on-demand-entries failed to parse response', err);\n                    }\n                });\n            case 2:\n            case \"end\":\n                return _ctx.stop();\n        }\n    }, _callee);\n}));\nexports[\"default\"] = _default; //# sourceMappingURL=on-demand-entries-client.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7Ozs7OztBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN4QixHQUFHLENBQUNHLE9BQU8sR0FBR0MsdUJBQXNCLENBQUNDLG1CQUFPLENBQUMsa0RBQWE7QUFDMUQsR0FBRyxDQUFDQyxVQUFVLEdBQUdELG1CQUFPLENBQUMsaUdBQTJCO1NBQzNDRSxrQkFBa0IsQ0FBQ0MsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFLENBQUM7SUFDeEUsR0FBRyxDQUFDLENBQUM7UUFDRCxHQUFHLENBQUNDLElBQUksR0FBR1AsR0FBRyxDQUFDSyxHQUFHLEVBQUVDLEdBQUc7UUFDdkIsR0FBRyxDQUFDYixLQUFLLEdBQUdjLElBQUksQ0FBQ2QsS0FBSztJQUMxQixDQUFDLENBQUMsS0FBSyxFQUFFZSxLQUFLLEVBQUUsQ0FBQztRQUNiTixNQUFNLENBQUNNLEtBQUs7UUFDWixNQUFNO0lBQ1YsQ0FBQztJQUNELEVBQUUsRUFBRUQsSUFBSSxDQUFDRSxJQUFJLEVBQUUsQ0FBQztRQUNaUixPQUFPLENBQUNSLEtBQUs7SUFDakIsQ0FBQyxNQUFNLENBQUM7UUFDSmlCLE9BQU8sQ0FBQ1QsT0FBTyxDQUFDUixLQUFLLEVBQUVrQixJQUFJLENBQUNSLEtBQUssRUFBRUMsTUFBTTtJQUM3QyxDQUFDO0FBQ0wsQ0FBQztTQUNRUSxpQkFBaUIsQ0FBQ0MsRUFBRSxFQUFFLENBQUM7SUFDNUIsTUFBTSxDQUFDLFFBQVEsR0FBRyxDQUFDO1FBQ2YsR0FBRyxDQUFDQyxJQUFJLEdBQUcsSUFBSSxFQUFFQyxJQUFJLEdBQUdDLFNBQVM7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LEVBQUUsQ0FBQztvQ0FDekIsRUFBMEI7b0NBQzFCSixRQUFRLENBQUNLLE1BQU07Z0NBQ25CLENBQUMsTUFBTSxDQUFDO29DQUNKLEVBQXFCO29DQUNyQixFQUFFLEVBQUU5QixJQUFJLENBQUN1QixhQUFhLENBQUNkLElBQUksS0FBSzVCLE9BQU8sQ0FBQ0QsT0FBTyxDQUFDb0MsUUFBUSxJQUFJbkMsT0FBTyxDQUFDRCxPQUFPLENBQUNvQyxRQUFRLEtBQUssQ0FBUyxVQUFFLENBQUM7d0NBQ2pHLEVBQTRCO3dDQUM1QixFQUFnQzt3Q0FDaENTLFFBQVEsQ0FBQ0ssTUFBTTtvQ0FDbkIsQ0FBQztnQ0FDTCxDQUFDOzRCQUNMLENBQUM7d0JBQ0wsQ0FBQztvQkFDTCxDQUFDLENBQUMsS0FBSyxFQUFFMUIsR0FBRyxFQUFFLENBQUM7d0JBQ1gyQixPQUFPLENBQUNyQyxLQUFLLENBQUMsQ0FBNEMsNkNBQUVVLEdBQUc7b0JBQ25FLENBQUM7Z0JBQ0wsQ0FBQzs7Ozs7O0FBQ0wsQ0FBQztBQUNEMUIsa0JBQWUsR0FBRzhCLFFBQVEsQ0FFMUIsQ0FBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcz84NDVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yb3V0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKSk7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbnZhciBfZGVmYXVsdCA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKihwYWdlKSB7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgLy8gaW4gQU1QIHRoZSByb3V0ZXIgaXNuJ3QgaW5pdGlhbGl6ZWQgb24gdGhlIGNsaWVudCBhbmRcbiAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb25zIGRvbid0IG9jY3VyIHNvIHBpbmcgaW5pdGlhbCBwYWdlXG4gICAgICAgIHNldEludGVydmFsKCgpPT57XG4gICAgICAgICAgICAoMCwgX3dlYnNvY2tldCkuc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiAncGluZycsXG4gICAgICAgICAgICAgICAgcGFnZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LCAyNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfcm91dGVyLmRlZmF1bHQucmVhZHkoKCk9PntcbiAgICAgICAgICAgIHNldEludGVydmFsKCgpPT57XG4gICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdwaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSwgMjUwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCk9PntcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZigneycpID09PSAtMSkgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAvLyBkb24ndCBhdHRlbXB0IGZldGNoaW5nIHRoZSBwYWdlIGlmIHdlJ3JlIGFscmVhZHkgc2hvd2luZ1xuICAgICAgICAgICAgLy8gdGhlIGRldiBvdmVybGF5IGFzIHRoaXMgY2FuIGNhdXNlIHRoZSBlcnJvciB0byBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICAgIC8vIHJlcGVhdGVkbHlcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmV2ZW50ID09PSAncG9uZycgJiYgcGF5bG9hZC5pbnZhbGlkICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gUGF5bG9hZCBjYW4gYmUgaW52YWxpZCBldmVuIGlmIHRoZSBwYWdlIGRvZXMgZXhpc3QuXG4gICAgICAgICAgICAgICAgLy8gU28sIHdlIGNoZWNrIGlmIGl0IGNhbiBiZSBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIGZldGNoKGxvY2F0aW9uLmhyZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgICAgICAgICAgICAgICB9KS50aGVuKChwYWdlUmVzKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFnZVJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFnZSBleGlzdHMgbm93LCByZWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFnZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfREFUQV9fLnBhZ2UgPT09IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSAmJiBfcm91dGVyLmRlZmF1bHQucGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzdGlsbCBvbiB0aGUgcGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxvYWQgdG8gc2hvdyA0MDQgZXJyb3IgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignb24tZGVtYW5kLWVudHJpZXMgZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcm91dGVyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfd2Vic29ja2V0IiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93Iiwia2V5IiwiYXJnIiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2RlZmF1bHQiLCJwYWdlIiwic2V0SW50ZXJ2YWwiLCJzZW5kTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudCIsInJlYWR5IiwicGF0aG5hbWUiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJkYXRhIiwiaW5kZXhPZiIsInBheWxvYWQiLCJwYXJzZSIsImludmFsaWQiLCJfX05FWFRfREFUQV9fIiwiZmV0Y2giLCJsb2NhdGlvbiIsImhyZWYiLCJjcmVkZW50aWFscyIsInBhZ2VSZXMiLCJzdGF0dXMiLCJyZWxvYWQiLCJjb25zb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/on-demand-entries-client.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nvar MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    var entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    var resolver;\n    var prom = new Promise(function(resolve) {\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator() // eslint-disable-next-line no-sequences\n    .then(function(value) {\n        return resolver(value), value;\n    }).catch(function(err) {\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// with relList.support\n        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nvar canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise(function(res, rej) {\n        var selector = \"\\n      link[rel=\\\"prefetch\\\"][href^=\\\"\".concat(href, \"\\\"],\\n      link[rel=\\\"preload\\\"][href^=\\\"\").concat(href, \"\\\"],\\n      script[src^=\\\"\").concat(href, \"\\\"]\");\n        if (document.querySelector(selector)) {\n            return res();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = \"prefetch\";\n        link.crossOrigin = undefined;\n        link.onload = res;\n        link.onerror = rej;\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nvar ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {\n    });\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction appendScript(src, script) {\n    return new Promise(function(resolve, reject) {\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = function() {\n            return reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n        };\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = undefined;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nvar devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise(function(resolve, reject) {\n        var cancelled = false;\n        p.then(function(r) {\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (true) {\n            (devBuildPromise || Promise.resolve()).then(function() {\n                (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return setTimeout(function() {\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms);\n                });\n            });\n        }\n        if (false) {}\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    var onBuildManifest = new Promise(function(resolve) {\n        // Mandatory because this is not concurrent safe:\n        var cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = function() {\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getMiddlewareManifest() {\n    if (self.__MIDDLEWARE_MANIFEST) {\n        return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n    }\n    var onMiddlewareManifest = new Promise(function(resolve) {\n        var cb = self.__MIDDLEWARE_MANIFEST_CB;\n        self.__MIDDLEWARE_MANIFEST_CB = function() {\n            resolve(self.__MIDDLEWARE_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (true) {\n        return Promise.resolve({\n            scripts: [\n                assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js')), \n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then(function(manifest) {\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n        }\n        var allFiles = manifest[route].map(function(entry) {\n            return assetPrefix + '/_next/' + encodeURI(entry);\n        });\n        return {\n            scripts: allFiles.filter(function(v) {\n                return v.endsWith('.js');\n            }),\n            css: allFiles.filter(function(v) {\n                return v.endsWith('.css');\n            })\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    var maybeExecuteScript = function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (false) { var prom; } else {\n            return appendScript(src);\n        }\n    };\n    var fetchStyleSheet = function fetchStyleSheet(href) {\n        var prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then(function(res) {\n            if (!res.ok) {\n                throw new Error(\"Failed to load stylesheet: \".concat(href));\n            }\n            return res.text().then(function(text) {\n                return {\n                    href: href,\n                    content: text\n                };\n            });\n        }).catch(function(err) {\n            throw markAssetError(err);\n        }));\n        return prom;\n    };\n    var entrypoints = new Map();\n    var loadedScripts = new Map();\n    var styleSheets = new Map();\n    var routes = new Map();\n    return {\n        whenEntrypoint: function(route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint: function(route, execute) {\n            (execute ? Promise.resolve().then(function() {\n                return execute();\n            }).then(function(exports) {\n                return {\n                    component: exports && exports.default || exports,\n                    exports: exports\n                };\n            }, function(err) {\n                return {\n                    error: err\n                };\n            }) : Promise.resolve(undefined)).then(function(input) {\n                var old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute: function(route, prefetch) {\n            var _this = this;\n            return withFuture(route, routes, function() {\n                var _this1 = _this;\n                var devBuildPromiseResolve;\n                if (true) {\n                    devBuildPromise = new Promise(function(resolve) {\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(function(param) {\n                    var scripts = param.scripts, css = param.css;\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet)), \n                    ]);\n                }).then(function(res) {\n                    return _this1.whenEntrypoint(route).then(function(entrypoint) {\n                        return {\n                            entrypoint: entrypoint,\n                            styles: res[1]\n                        };\n                    });\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then(function(param) {\n                    var entrypoint = param.entrypoint, styles = param.styles;\n                    var res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch(function(err) {\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(function() {\n                    return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch: function(route) {\n            var _this = this;\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            var cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then(function(output) {\n                return Promise.all(canPrefetch ? output.scripts.map(function(script) {\n                    return prefetchViaDom(script, 'script');\n                }) : []);\n            }).then(function() {\n                var _this2 = _this;\n                (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return _this2.loadRoute(route, true).catch(function() {\n                    });\n                });\n            }).catch(function() {\n            });\n        }\n    };\n} //# sourceMappingURL=route-loader.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFZO0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0UsY0FBYztBQUN2Q0Ysb0JBQW9CLEdBQUdHLFlBQVk7QUFDbkNILDhCQUE4QixHQUFHSSxzQkFBc0I7QUFDdkRKLDZCQUE2QixHQUFHSyxxQkFBcUI7QUFDckRMLHlCQUF5QixHQUFHTSxpQkFBaUI7QUFDN0MsR0FBRyxDQUFDQyxzQkFBc0IsR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsMklBQXNEO0FBQ2xILEdBQUcsQ0FBQ0Msb0JBQW9CLEdBQUdELG1CQUFPLENBQUMseUZBQXlCO1NBQ25ERCxzQkFBc0IsQ0FBQ0csR0FBRyxFQUFFLENBQUM7SUFDbEMsTUFBTSxDQUFDQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHRCxHQUFHLEdBQUcsQ0FBQztRQUNsQ0UsT0FBTyxFQUFFRixHQUFHO0lBQ2hCLENBQUM7QUFDTCxDQUFDO0FBQ0QsRUFBdUU7QUFDdkUsRUFBeUU7QUFDekUsRUFBMkU7QUFDM0UsRUFBb0M7QUFDcEMsR0FBSyxDQUFDRyxpQkFBaUIsR0FBRyxJQUFJO1NBQ3JCQyxVQUFVLENBQUNDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxTQUFTLEVBQUUsQ0FBQztJQUN0QyxHQUFHLENBQUNDLEtBQUssR0FBR0YsR0FBRyxDQUFDRyxHQUFHLENBQUNKLEdBQUc7SUFDdkIsRUFBRSxFQUFFRyxLQUFLLEVBQUUsQ0FBQztRQUNSLEVBQUUsRUFBRSxDQUFRLFdBQUlBLEtBQUssRUFBRSxDQUFDO1lBQ3BCLE1BQU0sQ0FBQ0EsS0FBSyxDQUFDRSxNQUFNO1FBQ3ZCLENBQUM7UUFDRCxNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDSixLQUFLO0lBQ2hDLENBQUM7SUFDRCxHQUFH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LE9BQU87WUFDMUUsQ0FBQztZQUNELE1BQU0sQ0FBQzJELGdCQUFnQixDQUFDQyxXQUFXLEVBQUVDLEtBQUssRUFBRXpELElBQUksQ0FBQyxRQUFRLENBQVBvRyxNQUFNO2dCQUFHekcsTUFBTSxDQUFOQSxPQUFPLENBQUM2RixHQUFHLENBQUMxRSxXQUFXLEdBQUdzRixNQUFNLENBQUMxQyxPQUFPLENBQUNwRSxHQUFHLENBQUMsUUFBUSxDQUFQNkMsTUFBTTtvQkFBR3BCLE1BQU0sQ0FBTkEsY0FBYyxDQUFDb0IsTUFBTSxFQUFFLENBQVE7cUJBQ3pJLENBQUMsQ0FBQztlQUNSbkMsSUFBSSxDQUFDLFFBQ2pCLEdBRHFCLENBQUM7O2lCQUNQLENBQUMsRUFBRWpCLG9CQUFvQixFQUFFOEQsbUJBQW1CLENBQUMsUUFBUTtvQkFBSixNQUFNLFFBQUR3QyxTQUFTLENBQUM1QixLQUFLLEVBQUUsSUFBSSxFQUFFeEQsS0FBSyxDQUFDLFFBQ2xHLEdBRHNHLENBQUM7b0JBQ3JGLENBQUM7O1lBRVQsQ0FBQyxFQUFFQSxLQUFLLENBQ1IsUUFDVixHQURjLENBQUM7WUFDTCxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDLENBRXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLWxvYWRlci5qcz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXJrQXNzZXRFcnJvciA9IG1hcmtBc3NldEVycm9yO1xuZXhwb3J0cy5pc0Fzc2V0RXJyb3IgPSBpc0Fzc2V0RXJyb3I7XG5leHBvcnRzLmdldENsaWVudEJ1aWxkTWFuaWZlc3QgPSBnZXRDbGllbnRCdWlsZE1hbmlmZXN0O1xuZXhwb3J0cy5nZXRNaWRkbGV3YXJlTWFuaWZlc3QgPSBnZXRNaWRkbGV3YXJlTWFuaWZlc3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRlTG9hZGVyID0gY3JlYXRlUm91dGVMb2FkZXI7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMDtcbmZ1bmN0aW9uIHdpdGhGdXR1cmUoa2V5LCBtYXAsIGdlbmVyYXRvcikge1xuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZXI7XG4gICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbWFwLnNldChrZXksIGVudHJ5ID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcbiAgICAgICAgZnV0dXJlOiBwcm9tXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgIC50aGVuKCh2YWx1ZSk9PihyZXNvbHZlcih2YWx1ZSksIHZhbHVlKVxuICAgICkuY2F0Y2goKGVycik9PntcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkgOiBwcm9tO1xufVxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaykge1xuICAgIHRyeSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIHJldHVybigvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB8fCBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGNhblByZWZldGNoID0gaGFzUHJlZmV0Y2goKTtcbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKGhyZWYsIGFzLCBsaW5rKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaik9PntcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBgXG4gICAgICBsaW5rW3JlbD1cInByZWZldGNoXCJdW2hyZWZePVwiJHtocmVmfVwiXSxcbiAgICAgIGxpbmtbcmVsPVwicHJlbG9hZFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXG4gICAgICBzY3JpcHRbc3JjXj1cIiR7aHJlZn1cIl1gO1xuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsOlxuICAgICAgICBpZiAoYXMpIGxpbmsuYXMgPSBhcztcbiAgICAgICAgbGluay5yZWwgPSBgcHJlZmV0Y2hgO1xuICAgICAgICBsaW5rLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgbGluay5vbmxvYWQgPSByZXM7XG4gICAgICAgIGxpbmsub25lcnJvciA9IHJlajtcbiAgICAgICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9KTtcbn1cbmNvbnN0IEFTU0VUX0xPQURfRVJST1IgPSBTeW1ib2woJ0FTU0VUX0xPQURfRVJST1InKTtcbmZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0Fzc2V0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVycjtcbn1cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChzcmMsIHNjcmlwdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAgICAgLy8gMS4gU2V0dXAgc3VjY2Vzcy9mYWlsdXJlIGhvb2tzIGluIGNhc2UgdGhlIGJyb3dzZXIgc3luY2hyb25vdXNseVxuICAgICAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gKCk9PnJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuICAgICAgICA7XG4gICAgICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgICAgICAvLyAgICBicm93c2VyIGJlZ2lucyB0byBmZXRjaC5cbiAgICAgICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgLy8gMy4gRmluYWxseSwgc2V0IHRoZSBzb3VyY2UgYW5kIGluamVjdCBpbnRvIHRoZSBET00gaW4gY2FzZSB0aGUgY2hpbGRcbiAgICAgICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcbn1cbi8vIFdlIHdhaXQgZm9yIHBhZ2VzIHRvIGJlIGJ1aWx0IGluIGRldiBiZWZvcmUgd2Ugc3RhcnQgdGhlIHJvdXRlIHRyYW5zaXRpb25cbi8vIHRpbWVvdXQgdG8gcHJldmVudCBhbiB1bi1uZWNlc3NhcnkgaGFyZCBuYXZpZ2F0aW9uIGluIGRldmVsb3BtZW50LlxubGV0IGRldkJ1aWxkUHJvbWlzZTtcbi8vIFJlc29sdmUgYSBwcm9taXNlIHRoYXQgdGltZXMgb3V0IGFmdGVyIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KHAsIG1zLCBlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBwLnRoZW4oKHIpPT57XG4gICAgICAgICAgICAvLyBSZXNvbHZlZCwgY2FuY2VsIHRoZSB0aW1lb3V0XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgLy8gV2Ugd3JhcCB0aGVzZSBjaGVja3Mgc2VwYXJhdGVseSBmb3IgYmV0dGVyIGRlYWQtY29kZSBlbGltaW5hdGlvbiBpblxuICAgICAgICAvLyBwcm9kdWN0aW9uIGJ1bmRsZXMuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKGRldkJ1aWxkUHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgbXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG1zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcbiAgICB9XG4gICAgY29uc3Qgb25CdWlsZE1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIC8vIE1hbmRhdG9yeSBiZWNhdXNlIHRoaXMgaXMgbm90IGNvbmN1cnJlbnQgc2FmZTpcbiAgICAgICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpPT57XG4gICAgICAgICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVCk7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KG9uQnVpbGRNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IGJ1aWxkIG1hbmlmZXN0JykpKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fTUlERExFV0FSRV9NQU5JRkVTVCk7XG4gICAgfVxuICAgIGNvbnN0IG9uTWlkZGxld2FyZU1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIGNvbnN0IGNiID0gc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19NSURETEVXQVJFX01BTklGRVNUX0NCID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChvbk1pZGRsZXdhcmVNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IG1pZGRsZXdhcmUgbWFuaWZlc3QnKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzY3JpcHRzOiBbXG4gICAgICAgICAgICAgICAgYXNzZXRQcmVmaXggKyAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICsgZW5jb2RlVVJJKCgwLCBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKS5kZWZhdWx0KHJvdXRlLCAnLmpzJykpLCBcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICBjc3M6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KT0+di5lbmRzV2l0aCgnLmpzJylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXgpIHtcbiAgICBjb25zdCBlbnRyeXBvaW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBsb2FkZWRTY3JpcHRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjKSB7XG4gICAgICAgIC8vIFdpdGggSE1SIHdlIG1pZ2h0IG5lZWQgdG8gXCJyZWxvYWRcIiBzY3JpcHRzIHdoZW4gdGhleSBhcmVcbiAgICAgICAgLy8gZGlzcG9zZWQgYW5kIHJlYWRkZWQuIEV4ZWN1dGluZyBzY3JpcHRzIHR3aWNlIGhhcyBubyBmdW5jdGlvbmFsXG4gICAgICAgIC8vIGRpZmZlcmVuY2VzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgbGV0IHByb20gPSBsb2FkZWRTY3JpcHRzLmdldChzcmMpO1xuICAgICAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLCBwcm9tID0gYXBwZW5kU2NyaXB0KHNyYykpO1xuICAgICAgICAgICAgcmV0dXJuIHByb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kU2NyaXB0KHNyYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTdHlsZVNoZWV0KGhyZWYpIHtcbiAgICAgICAgbGV0IHByb20gPSBzdHlsZVNoZWV0cy5nZXQoaHJlZik7XG4gICAgICAgIGlmIChwcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVNoZWV0cy5zZXQoaHJlZiwgcHJvbSA9IGZldGNoKGhyZWYpLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdHlsZXNoZWV0OiAke2hyZWZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKCh0ZXh0KT0+KHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2hlbkVudHJ5cG9pbnQgKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudHJ5cG9pbnQgKHJvdXRlLCBleGVjdXRlKSB7XG4gICAgICAgICAgICAoZXhlY3V0ZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmV4ZWN1dGUoKVxuICAgICAgICAgICAgKS50aGVuKChleHBvcnRzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBleHBvcnRzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICwgKGVycik9Pih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKS50aGVuKChpbnB1dCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnJlc29sdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZSBpcyBvdXRkYXRlZCBhbmQgd2Ugd2FudCB0byBpbnZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRSb3V0ZSAocm91dGUsIHByZWZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgcm91dGVzLCAoKT0+e1xuICAgICAgICAgICAgICAgIGxldCBkZXZCdWlsZFByb21pc2VSZXNvbHZlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBkZXZCdWlsZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKHsgc2NyaXB0cyAsIGNzcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSkgPyBbXSA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSwgXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSksIE1TX01BWF9JRExFX0RFTEFZLCBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYFJvdXRlIGRpZCBub3QgY29tcGxldGUgbG9hZGluZzogJHtyb3V0ZX1gKSkpLnRoZW4oKHsgZW50cnlwb2ludCAsIHN0eWxlcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICB9LCBlbnRyeXBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXM7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIGVycm9ycyBkdXJpbmcgcHJlZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPT09IG51bGwgfHwgZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZldGNoIChyb3V0ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgICAgICAgbGV0IGNuO1xuICAgICAgICAgICAgaWYgKGNuID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKG91dHB1dCk9PlByb21pc2UuYWxsKGNhblByZWZldGNoID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpPT5wcmVmZXRjaFZpYURvbShzY3JpcHQsICdzY3JpcHQnKVxuICAgICAgICAgICAgICAgICkgOiBbXSlcbiAgICAgICAgICAgICkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+dGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgICAoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFya0Fzc2V0RXJyb3IiLCJpc0Fzc2V0RXJyb3IiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiZ2V0TWlkZGxld2FyZU1hbmlmZXN0IiwiY3JlYXRlUm91dGVMb2FkZXIiLCJfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcmVxdWVzdElkbGVDYWxsYmFjayIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiTVNfTUFYX0lETEVfREVMQVkiLCJ3aXRoRnV0dXJlIiwia2V5IiwibWFwIiwiZ2VuZXJhdG9yIiwiZW50cnkiLCJnZXQiLCJmdXR1cmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVyIiwicHJvbSIsInNldCIsInRoZW4iLCJjYXRjaCIsImVyciIsImRlbGV0ZSIsImhhc1ByZWZldGNoIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpbmRvdyIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiZSIsImNhblByZWZldGNoIiwicHJlZmV0Y2hWaWFEb20iLCJocmVmIiwiYXMiLCJyZXMiLCJyZWoiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ1JPU1NfT1JJR0lOIiwib25sb2FkIiwib25lcnJvciIsImhlYWQiLCJhcHBlbmRDaGlsZCIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJhcHBlbmRTY3JpcHQiLCJzcmMiLCJzY3JpcHQiLCJyZWplY3QiLCJFcnJvciIsImJvZHkiLCJkZXZCdWlsZFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0IiwicCIsIm1zIiwiY2FuY2VsbGVkIiwiciIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZXRUaW1lb3V0Iiwic2VsZiIsIl9fQlVJTERfTUFOSUZFU1QiLCJvbkJ1aWxkTWFuaWZlc3QiLCJjYiIsIl9fQlVJTERfTUFOSUZFU1RfQ0IiLCJfX01JRERMRVdBUkVfTUFOSUZFU1QiLCJvbk1pZGRsZXdhcmVNYW5pZmVzdCIsIl9fTUlERExFV0FSRV9NQU5JRkVTVF9DQiIsImdldEZpbGVzRm9yUm91dGUiLCJhc3NldFByZWZpeCIsInJvdXRlIiwic2NyaXB0cyIsImVuY29kZVVSSSIsImNzcyIsIm1hbmlmZXN0IiwiYWxsRmlsZXMiLCJmaWx0ZXIiLCJ2IiwiZW5kc1dpdGgiLCJtYXliZUV4ZWN1dGVTY3JpcHQiLCJsb2FkZWRTY3JpcHRzIiwiZmV0Y2hTdHlsZVNoZWV0Iiwic3R5bGVTaGVldHMiLCJmZXRjaCIsIm9rIiwidGV4dCIsImNvbnRlbnQiLCJlbnRyeXBvaW50cyIsIk1hcCIsInJvdXRlcyIsIndoZW5FbnRyeXBvaW50Iiwib25FbnRyeXBvaW50IiwiZXhlY3V0ZSIsImNvbXBvbmVudCIsImVycm9yIiwidW5kZWZpbmVkIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJwcmVmZXRjaCIsImRldkJ1aWxkUHJvbWlzZVJlc29sdmUiLCJhbGwiLCJoYXMiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiYXNzaWduIiwiZmluYWxseSIsImNuIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwidGVzdCIsImVmZmVjdGl2ZVR5cGUiLCJvdXRwdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/regenerator-runtime/runtime.js */ \"./node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports[\"default\"] = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _isError = _interopRequireDefault1(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../../../server/denormalize-page-path */ \"./node_modules/next/dist/server/denormalize-page-path.js\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _resolveRewrites = _interopRequireDefault1(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _getMiddlewareRegex = __webpack_require__(/*! ./utils/get-middleware-regex */ \"./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js\");\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar detectDomainLocale;\nif (false) {}\nvar basePath =  false || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    var pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(\"\".concat(prefix).concat(pathname)) + path.substr(pathname.length);\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var detectedDomain; } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    var queryIndex = path.indexOf('?');\n    var hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    path = pathNoQueryHash(path);\n    return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = \"/\".concat(path);\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        var locationOrigin = (0, _utils).getLocationOrigin();\n        var resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    var interpolatedRoute = '';\n    var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    var dynamicGroups = dynamicRegex.groups;\n    var dynamicMatches = (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    var params = Object.keys(dynamicGroups);\n    if (!params.every(function(param) {\n        var value = dynamicMatches[param] || '';\n        var _param = dynamicGroups[param], repeat = _param.repeat, optional = _param.optional;\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n        if (optional) {\n            replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        function(segment) {\n            return encodeURIComponent(segment);\n        }).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params: params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    var filteredQuery = {\n    };\n    Object.keys(query).forEach(function(key) {\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    var base;\n    var urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    var urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n    var urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n        var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        var finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        var interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            var ref = interpolateAs(finalUrl.pathname, finalUrl.pathname, query), result = ref.result, params = ref.params;\n            if (result) {\n                interpolatedAs = (0, _utils).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var ref = _slicedToArray(resolveHref(router, url, true), 2), resolvedHref = ref[0], resolvedAs = ref[1];\n    var origin = (0, _utils).getLocationOrigin();\n    var hrefHadOrigin = resolvedHref.startsWith(origin);\n    var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, opts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then(function(res) {\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1, opts);\n            }\n            if (res.status === 404) {\n                return res.json().then(function(data) {\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(\"Failed to load static props\");\n                });\n            }\n            throw new Error(\"Failed to load static props\");\n        }\n        return opts.text ? res.text() : res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n    var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n        text: text\n    }).catch(function(err) {\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then(function(data) {\n        if (!persistCache || \"development\" !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch(function(err) {\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname2, query1, as1, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _classCallCheck(this, Router);\n        // Static Data Cache\n        this.sdc = {\n        };\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {\n        };\n        // In-flight middleware preflight requests\n        this.sde = {\n        };\n        this._idx = 0;\n        this.onPopState = function(e) {\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var pathname = _this.pathname, query = _this.query;\n                _this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query: query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, as = state.as, options = state.options, idx = state.idx;\n            if (false) { var v; }\n            _this._idx = idx;\n            var pathname1 = (0, _parseRelativeUrl).parseRelativeUrl(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && as === _this.asPath && pathname1 === _this.pathname) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change('replaceState', url, as, Object.assign({\n            }, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname2);\n        // set up the component cache (by route keys)\n        this.components = {\n        };\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname2 !== '/_error') {\n            var ref;\n            this.components[this.route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        this.pathname = pathname2;\n        this.query = query1;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname2) && self.__NEXT_DATA__.autoExport;\n        this.asPath = autoExportDynamic ? pathname2 : as1;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isFallback = isFallback;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        this.isPreview = !!isPreview;\n        this.isLocaleDomain = false;\n        if (false) {}\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (as1.substr(0, 2) !== '//') {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options1 = {\n                    locale: locale\n                };\n                options1._shouldResolveHref = as1 !== pathname2;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname2),\n                    query: query1\n                }), (0, _utils).getURL(), options1);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _createClass(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('pushState', url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('replaceState', url, as, options);\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var shouldResolveHref, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _shallow, shallow, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, ref1, ref2, resolvedAs, rewritesResult, effect, route, parsedAs1, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, ref, ref12, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, ref3, newUrl, newAs, notFoundRoute, isValidShallowRoute, _scroll, shouldScroll, resetScroll;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (isLocalURL(url)) {\n                                    _ctx.next = 3;\n                                    break;\n                                }\n                                window.location.href = url;\n                                return _ctx.abrupt(\"return\", false);\n                            case 3:\n                                shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                if (options._h) {\n                                    this.isReady = true;\n                                }\n                                prevLocale = this.locale;\n                                if (true) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;\n                                if (typeof options.locale === 'undefined') {\n                                    options.locale = this.locale;\n                                }\n                                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n                                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n                                if (localePathResult.detectedLocale) {\n                                    this.locale = localePathResult.detectedLocale;\n                                    parsedAs.pathname = addBasePath(parsedAs.pathname);\n                                    as = (0, _utils).formatWithValidation(parsedAs);\n                                    url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n                                }\n                                didNavigate = false;\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale);\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                if (!didNavigate) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 18:\n                                if (!options._h) {\n                                    this.isSsr = false;\n                                }\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark('routeChange');\n                                }\n                                _shallow = options.shallow, shallow = _shallow === void 0 ? false : _shallow;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (this._inFlightRoute) {\n                                    this.abortComponentLoad(this._inFlightRoute, routeProps);\n                                }\n                                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n                                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n                                this._inFlightRoute = as;\n                                localeChange = prevLocale !== this.locale;\n                                if (!(!options._h && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                                    _ctx.next = 35;\n                                    break;\n                                }\n                                this.asPath = cleanedAs;\n                                Router.events.emit('hashChangeStart', as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                this.changeState(method, url, as, options);\n                                this.scrollToHash(cleanedAs);\n                                this.notify(this.components[this.route], null);\n                                Router.events.emit('hashChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 35:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                ;\n                                _ctx.prev = 38;\n                                ;\n                                _ctx.t0 = _slicedToArray;\n                                _ctx.next = 43;\n                                return Promise.all([\n                                    this.pageLoader.getPageList(),\n                                    (0, _routeLoader).getClientBuildManifest(),\n                                    this.pageLoader.getMiddlewareList(), \n                                ]);\n                            case 43:\n                                _ctx.t1 = _ctx.sent;\n                                ref1 = (0, _ctx.t0)(_ctx.t1, 2);\n                                pages = ref1[0];\n                                ref2 = ref1[1], rewrites = ref2.__rewrites, ref2;\n                                ref1;\n                                _ctx.next = 54;\n                                break;\n                            case 50:\n                                _ctx.prev = 50;\n                                _ctx.t2 = _ctx[\"catch\"](38);\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 54:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = 'replaceState';\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n                                if (shouldResolveHref && pathname !== '/_error') {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = addBasePath(pathname);\n                                            url = (0, _utils).formatWithValidation(parsed);\n                                        }\n                                    }\n                                }\n                                if (isLocalURL(as)) {\n                                    _ctx.next = 63;\n                                    break;\n                                }\n                                if (false) {}\n                                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                            case 61:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 63:\n                                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n                                if (!(options._h !== 1)) {\n                                    _ctx.next = 84;\n                                    break;\n                                }\n                                _ctx.next = 67;\n                                return this._preflightRequest({\n                                    as: as,\n                                    cache: \"development\" === 'production',\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 67:\n                                effect = _ctx.sent;\n                                if (!(effect.type === 'rewrite')) {\n                                    _ctx.next = 72;\n                                    break;\n                                }\n                                {\n                                    query = _objectSpread({\n                                    }, query, effect.parsedAs.query);\n                                    resolvedAs = effect.asPath;\n                                    pathname = effect.resolvedHref;\n                                    parsed.pathname = effect.resolvedHref;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 84;\n                                break;\n                            case 72:\n                                if (!(effect.type === 'redirect' && effect.newAs)) {\n                                    _ctx.next = 76;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", this.change(method, effect.newUrl, effect.newAs, options));\n                            case 76:\n                                if (!(effect.type === 'redirect' && effect.destination)) {\n                                    _ctx.next = 81;\n                                    break;\n                                }\n                                window.location.href = effect.destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 81:\n                                if (!(effect.type === 'refresh')) {\n                                    _ctx.next = 84;\n                                    break;\n                                }\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 84:\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                                    _ctx.next = 100;\n                                    break;\n                                }\n                                parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                                asPathname = parsedAs1.pathname;\n                                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                                shouldInterpolate = route === asPathname;\n                                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {\n                                };\n                                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                                    _ctx.next = 99;\n                                    break;\n                                }\n                                missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                    return !query[param];\n                                });\n                                if (!(missingParams.length > 0)) {\n                                    _ctx.next = 97;\n                                    break;\n                                }\n                                if (true) {\n                                    console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                                }\n                                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n                            case 97:\n                                _ctx.next = 100;\n                                break;\n                            case 99:\n                                if (shouldInterpolate) {\n                                    as = (0, _utils).formatWithValidation(Object.assign({\n                                    }, parsedAs1, {\n                                        pathname: interpolatedAs.result,\n                                        query: omitParmsFromQuery(query, interpolatedAs.params)\n                                    }));\n                                } else {\n                                    // Merge params into `query`, overwriting any specified in search\n                                    Object.assign(query, routeMatch);\n                                }\n                            case 100:\n                                Router.events.emit('routeChangeStart', as, routeProps);\n                                _ctx.prev = 101;\n                                ;\n                                _ctx.next = 105;\n                                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n                            case 105:\n                                routeInfo = _ctx.sent;\n                                error = routeInfo.error, props = routeInfo.props, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;\n                                if (!((__N_SSG || __N_SSP) && props)) {\n                                    _ctx.next = 132;\n                                    break;\n                                }\n                                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                                    _ctx.next = 117;\n                                    break;\n                                }\n                                destination = props.pageProps.__N_REDIRECT;\n                                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                                    _ctx.next = 115;\n                                    break;\n                                }\n                                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                ref3 = prepareUrlAs(this, destination, destination), newUrl = ref3.url, newAs = ref3.as;\n                                return _ctx.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n                            case 115:\n                                window.location.href = destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 117:\n                                this.isPreview = !!props.__N_PREVIEW;\n                                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                                    _ctx.next = 132;\n                                    break;\n                                }\n                                ;\n                                _ctx.prev = 120;\n                                _ctx.next = 123;\n                                return this.fetchComponent('/404');\n                            case 123:\n                                notFoundRoute = '/404';\n                                _ctx.next = 129;\n                                break;\n                            case 126:\n                                _ctx.prev = 126;\n                                _ctx.t3 = _ctx[\"catch\"](120);\n                                notFoundRoute = '/_error';\n                            case 129:\n                                _ctx.next = 131;\n                                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                                    shallow: false\n                                });\n                            case 131:\n                                routeInfo = _ctx.sent;\n                            case 132:\n                                Router.events.emit('beforeHistoryChange', as, routeProps);\n                                this.changeState(method, url, as, options);\n                                if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref12 = ref.pageProps) === null || ref12 === void 0 ? void 0 : ref12.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && this.route === route;\n                                ;\n                                shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                _ctx.next = 141;\n                                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(function(e) {\n                                    if (e.cancelled) error = error || e;\n                                    else throw e;\n                                });\n                            case 141:\n                                if (!error) {\n                                    _ctx.next = 144;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                                throw error;\n                            case 144:\n                                if (false) {}\n                                Router.events.emit('routeChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 149:\n                                _ctx.prev = 149;\n                                _ctx.t4 = _ctx[\"catch\"](101);\n                                if (!((0, _isError).default(_ctx.t4) && _ctx.t4.cancelled)) {\n                                    _ctx.next = 153;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", false);\n                            case 153:\n                                throw _ctx.t4;\n                            case 154:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            38,\n                            50\n                        ],\n                        [\n                            101,\n                            149\n                        ],\n                        [\n                            120,\n                            126\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (true) {\n                    if (typeof window.history === 'undefined') {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === 'undefined') {\n                        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                        return;\n                    }\n                }\n                if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    '', as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var Component, styleSheets, props, ref, routeInfo;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (!err.cancelled) {\n                                    _ctx.next = 2;\n                                    break;\n                                }\n                                // bubble up cancellation errors\n                                throw err;\n                            case 2:\n                                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                                    _ctx.next = 6;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', err, as, routeProps);\n                                // If we can't load the page it could be one of following reasons\n                                //  1. Page doesn't exists\n                                //  2. Page does exist in a different zone\n                                //  3. Internal error while loading the page\n                                // So, doing a hard reload is the proper way to deal with this.\n                                window.location.href = as;\n                                // Changing the URL doesn't block executing the current code path.\n                                // So let's throw a cancellation error stop the routing logic.\n                                throw buildCancellationError();\n                            case 6:\n                                _ctx.prev = 6;\n                                ;\n                                ;\n                                ;\n                                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                ;\n                                _ctx.next = 14;\n                                return this.fetchComponent('/_error');\n                            case 14:\n                                ref = _ctx.sent;\n                                Component = ref.page;\n                                styleSheets = ref.styleSheets;\n                                ref;\n                            case 18:\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (routeInfo.props) {\n                                    _ctx.next = 30;\n                                    break;\n                                }\n                                _ctx.prev = 20;\n                                _ctx.next = 23;\n                                return this.getInitialProps(Component, {\n                                    err: err,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 23:\n                                routeInfo.props = _ctx.sent;\n                                _ctx.next = 30;\n                                break;\n                            case 26:\n                                _ctx.prev = 26;\n                                _ctx.t0 = _ctx[\"catch\"](20);\n                                console.error('Error in error page `getInitialProps`: ', _ctx.t0);\n                                routeInfo.props = {\n                                };\n                            case 30:\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 33:\n                                _ctx.prev = 33;\n                                _ctx.t1 = _ctx[\"catch\"](6);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps, true));\n                            case 36:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            6,\n                            33\n                        ],\n                        [\n                            20,\n                            26\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, __N_RSC, isValidElementType, dataHref, props, ref, fresh, data;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _ctx.prev = 0;\n                                existingRouteInfo = this.components[route];\n                                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {\n                                    _ctx.next = 4;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", existingRouteInfo);\n                            case 4:\n                                cachedRouteInfo = undefined;\n                                // can only use non-initial route info\n                                // cannot reuse route info in development since it can change after HMR\n                                if (false) {}\n                                _ctx.t0 = cachedRouteInfo;\n                                if (_ctx.t0) {\n                                    _ctx.next = 11;\n                                    break;\n                                }\n                                _ctx.next = 10;\n                                return this.fetchComponent(route).then(function(res) {\n                                    return {\n                                        Component: res.page,\n                                        styleSheets: res.styleSheets,\n                                        __N_SSG: res.mod.__N_SSG,\n                                        __N_SSP: res.mod.__N_SSP,\n                                        __N_RSC: !!res.page.__next_rsc__\n                                    };\n                                });\n                            case 10:\n                                _ctx.t0 = _ctx.sent;\n                            case 11:\n                                routeInfo = _ctx.t0;\n                                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP, __N_RSC = routeInfo.__N_RSC;\n                                if (false) {}\n                                isValidElementType = (__webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\").isValidElementType);\n                                if (isValidElementType(Component)) {\n                                    _ctx.next = 17;\n                                    break;\n                                }\n                                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n                            case 17:\n                                ;\n                                if (__N_SSG || __N_SSP || __N_RSC) {\n                                    dataHref = this.pageLoader.getDataHref({\n                                        href: (0, _utils).formatWithValidation({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        asPath: resolvedAs,\n                                        ssg: __N_SSG,\n                                        rsc: __N_RSC,\n                                        locale: this.locale\n                                    });\n                                }\n                                _ctx.next = 21;\n                                return this._getData(function() {\n                                    return __N_SSG || __N_SSP ? fetchNextData(dataHref, _this.isSsr, false, __N_SSG ? _this.sdc : _this.sdr, !!__N_SSG && !_this.isPreview) : _this.getInitialProps(Component, {\n                                        pathname: pathname,\n                                        query: query,\n                                        asPath: as,\n                                        locale: _this.locale,\n                                        locales: _this.locales,\n                                        defaultLocale: _this.defaultLocale\n                                    });\n                                });\n                            case 21:\n                                props = _ctx.sent;\n                                if (!__N_RSC) {\n                                    _ctx.next = 29;\n                                    break;\n                                }\n                                _ctx.next = 25;\n                                return this._getData(function() {\n                                    return _this._getFlightData(dataHref);\n                                });\n                            case 25:\n                                ref = _ctx.sent;\n                                fresh = ref.fresh;\n                                data = ref.data;\n                                props.pageProps = Object.assign(props.pageProps, {\n                                    __flight_serialized__: data,\n                                    __flight_fresh__: fresh\n                                });\n                            case 29:\n                                routeInfo.props = props;\n                                this.components[route] = routeInfo;\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 34:\n                                _ctx.prev = 34;\n                                _ctx.t1 = _ctx[\"catch\"](0);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps));\n                            case 37:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            34\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(route, pathname, query, as, data, resetScroll) {\n                this.isFallback = false;\n                this.route = route;\n                this.pathname = pathname;\n                this.query = query;\n                this.asPath = as;\n                return this.notify(data, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var ref = _slicedToArray(this.asPath.split('#'), 2), oldUrlNoHash = ref[0], oldHash = ref[1];\n                var ref4 = _slicedToArray(as.split('#'), 2), newUrlNoHash = ref4[0], newHash = ref4[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var ref = _slicedToArray(as.split('#'), 2), hash = ref[1];\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === '' || hash === 'top') {\n                    window.scrollTo(0, 0);\n                    return;\n                }\n                // First we check if the element by id is found\n                var idEl = document.getElementById(hash);\n                if (idEl) {\n                    idEl.scrollIntoView();\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(hash)[0];\n                if (nameEl) {\n                    nameEl.scrollIntoView();\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url, param, param1) {\n                var asPath = param === void 0 ? url : param, options = param1 === void 0 ? {\n                } : param1;\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var parsed, pathname, query, parsedAs, localePathResult, pages, resolvedAs, rewrites, ref, rewritesResult, effects, route;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                if (false) {}\n                                _ctx.next = 5;\n                                return this.pageLoader.getPageList();\n                            case 5:\n                                pages = _ctx.sent;\n                                resolvedAs = asPath;\n                                if (true) {\n                                    _ctx.next = 20;\n                                    break;\n                                }\n                                ;\n                                ;\n                                _ctx.next = 12;\n                                return (0, _routeLoader).getClientBuildManifest();\n                            case 12:\n                                ref = _ctx.sent;\n                                rewrites = ref.__rewrites;\n                                ref;\n                                rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, this.locales);\n                                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 21;\n                                break;\n                            case 20:\n                                {\n                                    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                    if (parsed.pathname !== pathname) {\n                                        pathname = parsed.pathname;\n                                        parsed.pathname = pathname;\n                                        url = (0, _utils).formatWithValidation(parsed);\n                                    }\n                                }\n                            case 21:\n                                if (false) {}\n                                return _ctx.abrupt(\"return\");\n                            case 23:\n                                _ctx.next = 25;\n                                return this._preflightRequest({\n                                    as: addBasePath(asPath),\n                                    cache: true,\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 25:\n                                effects = _ctx.sent;\n                                if (effects.type === 'rewrite') {\n                                    parsed.pathname = effects.resolvedHref;\n                                    pathname = effects.resolvedHref;\n                                    query = _objectSpread({\n                                    }, query, effects.parsedAs.query);\n                                    resolvedAs = effects.asPath;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                _ctx.next = 30;\n                                return Promise.all([\n                                    this.pageLoader._isSsg(route).then(function(isSsg) {\n                                        return isSsg ? fetchNextData(_this.pageLoader.getDataHref({\n                                            href: url,\n                                            asPath: resolvedAs,\n                                            ssg: true,\n                                            locale: typeof options.locale !== 'undefined' ? options.locale : _this.locale\n                                        }), false, false, _this.sdc, true) : false;\n                                    }),\n                                    this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n                                ]);\n                            case 30:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var cancelled, cancel, handleCancelled, componentResult;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                cancelled = false;\n                                cancel = this.clc = function() {\n                                    cancelled = true;\n                                };\n                                handleCancelled = function() {\n                                    if (cancelled) {\n                                        var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n                                        error.cancelled = true;\n                                        throw error;\n                                    }\n                                    if (cancel === _this.clc) {\n                                        _this.clc = null;\n                                    }\n                                };\n                                _ctx.prev = 3;\n                                _ctx.next = 6;\n                                return this.pageLoader.loadPage(route);\n                            case 6:\n                                componentResult = _ctx.sent;\n                                handleCancelled();\n                                return _ctx.abrupt(\"return\", componentResult);\n                            case 11:\n                                _ctx.prev = 11;\n                                _ctx.t0 = _ctx[\"catch\"](3);\n                                handleCancelled();\n                                throw _ctx.t0;\n                            case 15:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            3,\n                            11\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error('Loading initial props cancelled');\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                var _this = this;\n                var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n                if (!this.isPreview && this.sdc[cacheKey]) {\n                    return Promise.resolve({\n                        fresh: false,\n                        data: this.sdc[cacheKey]\n                    });\n                }\n                return fetchNextData(dataHref, true, true, this.sdc, false).then(function(serialized) {\n                    _this.sdc[cacheKey] = serialized;\n                    return {\n                        fresh: true,\n                        data: serialized\n                    };\n                });\n            }\n        },\n        {\n            key: \"_preflightRequest\",\n            value: function _preflightRequest(options) {\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var ref, cleanedAs, fns, requiresPreflight, preflight, parsed, fsPathname, matchedPage, resolvedHref, cleanRedirect, ref5, newUrl, newAs;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                ;\n                                cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, this.locale);\n                                _ctx.next = 4;\n                                return this.pageLoader.getMiddlewareList();\n                            case 4:\n                                fns = _ctx.sent;\n                                requiresPreflight = fns.some(function(param) {\n                                    var _param = _slicedToArray(param, 2), middleware = _param[0], isSSR = _param[1];\n                                    return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n                                });\n                                if (requiresPreflight) {\n                                    _ctx.next = 8;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 8:\n                                _ctx.next = 10;\n                                return this._getPreflightData({\n                                    preflightHref: options.as,\n                                    shouldCache: options.cache\n                                });\n                            case 10:\n                                preflight = _ctx.sent;\n                                if (!((ref = preflight.rewrite) === null || ref === void 0 ? void 0 : ref.startsWith('/'))) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n                                fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n                                ;\n                                ;\n                                if (options.pages.includes(fsPathname)) {\n                                    matchedPage = true;\n                                    resolvedHref = fsPathname;\n                                } else {\n                                    resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                                    if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                                        matchedPage = true;\n                                    }\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'rewrite',\n                                    asPath: parsed.pathname,\n                                    parsedAs: parsed,\n                                    matchedPage: matchedPage,\n                                    resolvedHref: resolvedHref\n                                });\n                            case 18:\n                                if (!preflight.redirect) {\n                                    _ctx.next = 24;\n                                    break;\n                                }\n                                if (!preflight.redirect.startsWith('/')) {\n                                    _ctx.next = 23;\n                                    break;\n                                }\n                                cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                                ref5 = prepareUrlAs(this, cleanRedirect, cleanRedirect), newUrl = ref5.url, newAs = ref5.as;\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    newUrl: newUrl,\n                                    newAs: newAs\n                                });\n                            case 23:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    destination: preflight.redirect\n                                });\n                            case 24:\n                                if (!(preflight.refresh && !preflight.ssr)) {\n                                    _ctx.next = 26;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'refresh'\n                                });\n                            case 26:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 27:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getPreflightData\",\n            value: function _getPreflightData(params) {\n                var _this = this;\n                var preflightHref = params.preflightHref, _shouldCache = params.shouldCache, shouldCache = _shouldCache === void 0 ? false : _shouldCache;\n                var ref = new URL(preflightHref, window.location.href), cacheKey = ref.href;\n                if (false) {}\n                return fetch(preflightHref, {\n                    method: 'HEAD',\n                    credentials: 'same-origin',\n                    headers: {\n                        'x-middleware-preflight': '1'\n                    }\n                }).then(function(res) {\n                    if (!res.ok) {\n                        throw new Error(\"Failed to preflight request\");\n                    }\n                    return {\n                        redirect: res.headers.get('Location'),\n                        refresh: res.headers.has('x-middleware-refresh'),\n                        rewrite: res.headers.get('x-middleware-rewrite'),\n                        ssr: !!res.headers.get('x-middleware-ssr')\n                    };\n                }).then(function(data) {\n                    if (shouldCache) {\n                        _this.sde[cacheKey] = data;\n                    }\n                    return data;\n                }).catch(function(err) {\n                    delete _this.sde[cacheKey];\n                    throw err;\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var ref = this.components['/_app'], App = ref.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils).loadGetInitialProps(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"abortComponentLoad\",\n            value: function abortComponentLoad(as, routeProps) {\n                if (this.clc) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n                    this.clc();\n                    this.clc = null;\n                }\n            }\n        },\n        {\n            key: \"notify\",\n            value: function notify(data, resetScroll) {\n                return this.sub(data, this.components['/_app'].Component, resetScroll);\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt).default();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRSxlQUFlO0FBQ3pDRixpQkFBaUIsR0FBR0csU0FBUztBQUM3QkgsaUJBQWlCLEdBQUdJLFNBQVM7QUFDN0JKLG1CQUFtQixHQUFHSyxXQUFXO0FBQ2pDTCxtQkFBbUIsR0FBR00sV0FBVztBQUNqQ04sbUJBQW1CLEdBQUdPLFdBQVc7QUFDakNQLGtCQUFrQixHQUFHUSxVQUFVO0FBQy9CUixxQkFBcUIsR0FBR1MsYUFBYTtBQUNyQ1QsbUJBQW1CLEdBQUdVLFdBQVc7QUFDakNWLGtCQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDeEIsR0FBRyxDQUFDWSx1QkFBdUIsR0FBR0MsbUJBQU8sQ0FBQyw2R0FBMEM7QUFDaEYsR0FBRyxDQUFDQyxZQUFZLEdBQUdELG1CQUFPLENBQUMscUZBQThCO0FBQ3pELEdBQUcsQ0FBQ0UsUUFBUSxHQUFHQyx1QkFBc0IsQ0FBQ0gsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDckUsR0FBRyxDQUFDSSxvQkFBb0IsR0FBR0osbUJBQU8sQ0FBQyx1R0FBdUM7QUFDMUUsR0FBRyxDQUFDSyxvQkFBb0IsR0FBR0wsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDbEUsR0FBRyxDQUFDTSxLQUFLLEdBQUdILHVCQUFzQixDQUFDSCxtQkFBTyxDQUFDLDREQUFTO0FBQ3BELEdBQUcsQ0FBQ08sTUFBTSxHQUFHUCxtQkFBTyxDQUFDLDhEQUFVO0FBQy9CLEdBQUcsQ0FBQ1EsVUFBVSxHQUFH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QUFNLEVBQU5BLENBQU07bUJBQU5BLFFBQVEsQ0FBUkEsTUFBTSxDQUFDeEgsSUFBSSxFQUFFNkcsV0FBVyxFQUFFLENBQUM7Z0JBQ3ZCLE1BQU0sQ0FBQyxJQUFJLENBQUM5QyxHQUFHLENBQUMvRCxJQUFJLEVBQUUsSUFBSSxDQUFDa0QsVUFBVSxDQUFDLENBQU8sUUFBRWhDLFNBQVMsRUFBRTJGLFdBQVc7WUFDekUsQ0FBQzs7O1dBdDZCQ2hHLE1BQU07O0FBdzZCWkEsTUFBTSxDQUFDOEMsTUFBTSxJQUFJLENBQUMsRUFBRTlNLEtBQUssRUFBRVIsT0FBTztBQUNsQ1gsa0JBQWUsR0FBR21MLE1BQU0sQ0FFeEIsQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanM/ODY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0RG9tYWluTG9jYWxlID0gZ2V0RG9tYWluTG9jYWxlO1xuZXhwb3J0cy5hZGRMb2NhbGUgPSBhZGRMb2NhbGU7XG5leHBvcnRzLmRlbExvY2FsZSA9IGRlbExvY2FsZTtcbmV4cG9ydHMuaGFzQmFzZVBhdGggPSBoYXNCYXNlUGF0aDtcbmV4cG9ydHMuYWRkQmFzZVBhdGggPSBhZGRCYXNlUGF0aDtcbmV4cG9ydHMuZGVsQmFzZVBhdGggPSBkZWxCYXNlUGF0aDtcbmV4cG9ydHMuaXNMb2NhbFVSTCA9IGlzTG9jYWxVUkw7XG5leHBvcnRzLmludGVycG9sYXRlQXMgPSBpbnRlcnBvbGF0ZUFzO1xuZXhwb3J0cy5yZXNvbHZlSHJlZiA9IHJlc29sdmVIcmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX3JvdXRlTG9hZGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXJcIik7XG52YXIgX2lzRXJyb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtZXJyb3JcIikpO1xudmFyIF9kZW5vcm1hbGl6ZVBhZ2VQYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XG52YXIgX25vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG52YXIgX21pdHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9taXR0XCIpKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG52YXIgX3BhcnNlUmVsYXRpdmVVcmwgPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4vdXRpbHMvcXVlcnlzdHJpbmdcIik7XG52YXIgX3Jlc29sdmVSZXdyaXRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG52YXIgX3JvdXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG52YXIgX3JvdXRlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbnZhciBfZ2V0TWlkZGxld2FyZVJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0LW1pZGRsZXdhcmUtcmVnZXhcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5sZXQgZGV0ZWN0RG9tYWluTG9jYWxlO1xuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBkZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykuZGV0ZWN0RG9tYWluTG9jYWxlO1xufVxuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGAke3ByZWZpeH0ke3BhdGhuYW1lfWApICsgcGF0aC5zdWJzdHIocGF0aG5hbWUubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShwYXRoLCBsb2NhbGUsIGxvY2FsZXMsIGRvbWFpbkxvY2FsZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBsb2NhbGUgPSBsb2NhbGUgfHwgKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIGxvY2FsZSk7XG4gICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuIGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHtiYXNlUGF0aCB8fCAnJ30ke2xvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke2xvY2FsZX1gfSR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkTG9jYWxlKHBhdGgsIGxvY2FsZSwgZGVmYXVsdExvY2FsZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgICAgICBjb25zdCBwYXRoTG93ZXIgPSBwYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBsb2NhbGVMb3dlciA9IGxvY2FsZSAmJiBsb2NhbGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZSAmJiBsb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUgJiYgIXBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSAmJiBwYXRoTG93ZXIgIT09ICcvJyArIGxvY2FsZUxvd2VyID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpIDogcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBkZWxMb2NhbGUocGF0aCwgbG9jYWxlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZUxvd2VyID0gbG9jYWxlICYmIGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIChwYXRoTG93ZXIuc3RhcnRzV2l0aCgnLycgKyBsb2NhbGVMb3dlciArICcvJykgfHwgcGF0aExvd2VyID09PSAnLycgKyBsb2NhbGVMb3dlcikgPyAocGF0aG5hbWUubGVuZ3RoID09PSBsb2NhbGUubGVuZ3RoICsgMSA/ICcvJyA6ICcnKSArIHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSA6IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gcGF0aE5vUXVlcnlIYXNoKHBhdGgpIHtcbiAgICBjb25zdCBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gICAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKHF1ZXJ5SW5kZXggPiAtMSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aCkge1xuICAgIHBhdGggPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJyk7XG59XG5mdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoKSB7XG4gICAgLy8gd2Ugb25seSBhZGQgdGhlIGJhc2VwYXRoIG9uIHJlbGF0aXZlIHVybHNcbiAgICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aCk7XG59XG5mdW5jdGlvbiBkZWxCYXNlUGF0aChwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKTtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YDtcbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpIHx8IHVybC5zdGFydHNXaXRoKCcjJykgfHwgdXJsLnN0YXJ0c1dpdGgoJz8nKSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSAnJztcbiAgICBjb25zdCBkeW5hbWljUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xuICAgIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzO1xuICAgIGNvbnN0IGR5bmFtaWNNYXRjaGVzID0gLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fCAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG4gICAgcXVlcnk7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKTtcbiAgICBpZiAoIXBhcmFtcy5ldmVyeSgocGFyYW0pPT57XG4gICAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJztcbiAgICAgICAgY29uc3QgeyByZXBlYXQgLCBvcHRpb25hbCAgfSA9IGR5bmFtaWNHcm91cHNbcGFyYW1dO1xuICAgICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuICAgICAgICBsZXQgcmVwbGFjZWQgPSBgWyR7cmVwZWF0ID8gJy4uLicgOiAnJ30ke3BhcmFtfV1gO1xuICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiYgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9IGludGVycG9sYXRlZFJvdXRlLnJlcGxhY2UocmVwbGFjZWQsIHJlcGVhdCA/IHZhbHVlLm1hcCgvLyB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGZ1bGx5IGVuY29kZWQgaW5zdGVhZCBvZiBqdXN0XG4gICAgICAgIC8vIHBhdGggZGVsaW1pdGVyIGVzY2FwZWQgc2luY2UgdGhleSBhcmUgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgLy8gaW50byB0aGUgVVJMIGFuZCB3ZSBleHBlY3QgVVJMIGVuY29kZWQgc2VnbWVudHNcbiAgICAgICAgLy8gd2hlbiBwYXJzaW5nIGR5bmFtaWMgcm91dGUgcGFyYW1zXG4gICAgICAgIChzZWdtZW50KT0+ZW5jb2RlVVJJQ29tcG9uZW50KHNlZ21lbnQpXG4gICAgICAgICkuam9pbignLycpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkgfHwgJy8nKTtcbiAgICB9KSkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5mdW5jdGlvbiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcykge1xuICAgIGNvbnN0IGZpbHRlcmVkUXVlcnkgPSB7XG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBpZiAoIXBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFF1ZXJ5W2tleV0gPSBxdWVyeVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkUXVlcnk7XG59XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKGhyZWYpO1xuICAgIC8vIHJlcGVhdGVkIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSBVUkwgYXJlIGNvbnNpZGVyZWRcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcbiAgICBjb25zdCB1cmxQcm90b01hdGNoID0gdXJsQXNTdHJpbmcubWF0Y2goL15bYS16QS1aXXsxLH06XFwvXFwvLyk7XG4gICAgY29uc3QgdXJsQXNTdHJpbmdOb1Byb3RvID0gdXJsUHJvdG9NYXRjaCA/IHVybEFzU3RyaW5nLnN1YnN0cih1cmxQcm90b01hdGNoWzBdLmxlbmd0aCkgOiB1cmxBc1N0cmluZztcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybEFzU3RyaW5nTm9Qcm90by5zcGxpdCgnPycpO1xuICAgIGlmICgodXJsUGFydHNbMF0gfHwgJycpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBocmVmIHBhc3NlZCB0byBuZXh0L3JvdXRlcjogJHt1cmxBc1N0cmluZ30sIHJlcGVhdGVkIGZvcndhcmQtc2xhc2hlcyAoLy8pIG9yIGJhY2tzbGFzaGVzIFxcXFwgYXJlIG5vdCB2YWxpZCBpbiB0aGUgaHJlZmApO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscykubm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogJycpICsgbm9ybWFsaXplZFVybDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsQXNTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICB1cmxBc1N0cmluZ1xuICAgICAgICBdIDogdXJsQXNTdHJpbmc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKHVybEFzU3RyaW5nLnN0YXJ0c1dpdGgoJyMnKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsICdodHRwOi8vbicpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gLyBmb3IgaW52YWxpZCBhc1BhdGggdmFsdWVzIGUuZy4gLy9cbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoJy8nLCAnaHR0cDovL24nKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gJyc7XG4gICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJiByZXNvbHZlQXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gKDAsIF9xdWVyeXN0cmluZykuc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShmaW5hbFVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgLCBwYXJhbXMgIH0gPSBpbnRlcnBvbGF0ZUFzKGZpbmFsVXJsLnBhdGhuYW1lLCBmaW5hbFVybC5wYXRobmFtZSwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZEFzID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIF0gOiByZXNvbHZlZEhyZWY7XG4gICAgfSBjYXRjaCAoXzEpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIGNvbnN0IGhyZWZIYWRPcmlnaW4gPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIGNvbnN0IGFzSGFkT3JpZ2luID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZkhhZE9yaWdpbiA/IHJlc29sdmVkSHJlZiA6IGFkZEJhc2VQYXRoKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZUhyZWYocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzSGFkT3JpZ2luID8gcHJlcGFyZWRBcyA6IGFkZEJhc2VQYXRoKHByZXBhcmVkQXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKSB7XG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goKDAsIF9kZW5vcm1hbGl6ZVBhZ2VQYXRoKS5kZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhdGhuYW1lKSk7XG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpPT57XG4gICAgICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHBhZ2UpICYmICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xufVxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiYgISFmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgdiA9ICdfX25leHQnO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICB9XG59KCk7XG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRzKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ1xuICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cy50ZXh0ID8gcmVzLnRleHQoKSA6IHJlcy5qc29uKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciwgdGV4dCwgaW5mbGlnaHRDYWNoZSwgcGVyc2lzdENhY2hlKSB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSAgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBpZiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgICAgdGV4dFxuICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgICAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgICAgICAvLyBsb29wLlxuICAgICAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5tYXJrQXNzZXRFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICBpZiAoIXBlcnNpc3RDYWNoZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG59XG5jbGFzcyBSb3V0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzICwgcGFnZUxvYWRlciAsIEFwcCAsIHdyYXBBcHAgLCBDb21wb25lbnQgLCBlcnIgLCBzdWJzY3JpcHRpb24gLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRlZmF1bHRMb2NhbGUgLCBkb21haW5Mb2NhbGVzICwgaXNQcmV2aWV3ICB9KXtcbiAgICAgICAgLy8gU3RhdGljIERhdGEgQ2FjaGVcbiAgICAgICAgdGhpcy5zZGMgPSB7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluLWZsaWdodCBTZXJ2ZXIgRGF0YSBSZXF1ZXN0cywgZm9yIGRlZHVwaW5nXG4gICAgICAgIHRoaXMuc2RyID0ge1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbi1mbGlnaHQgbWlkZGxld2FyZSBwcmVmbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgdGhpcy5zZGUgPSB7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2lkeCA9IDA7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgICAgICAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscykuZ2V0VVJMKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwgaWR4ICB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9pZHgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faWR4ID0gaWR4O1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgICAgICAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgfSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIHRoaXMucm91dGUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICAgICAgICAgICAgX19OX1JTQzogISEoKHJlZiA9IENvbXBvbmVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuX19uZXh0X3JzY19fKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgICAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHM7XG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYXNQYXRoID0gYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzO1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGg7XG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgICAgIHRoaXMuaXNTc3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIHRoaXMuaXNQcmV2aWV3ID0gISFpc1ByZXZpZXc7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMgIT09IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscykuZ2V0VVJMKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zID0ge1xuICAgIH0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9pZHgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNoYW5nZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMsIGZvcmNlZFNjcm9sbCkge1xuICAgICAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvdWxkUmVzb2x2ZUhyZWYgPSBvcHRpb25zLl9oIHx8IG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmIHx8IHBhdGhOb1F1ZXJ5SGFzaCh1cmwpID09PSBwYXRoTm9RdWVyeUhhc2goYXMpO1xuICAgICAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgICAgIGlmIChvcHRpb25zLl9oKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZMb2NhbGUgPSB0aGlzLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID8gdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXJzZWRBcy5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGhhc0Jhc2VQYXRoKHVybCkgPyBkZWxCYXNlUGF0aCh1cmwpIDogdXJsLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKHJlZiA9IHRoaXMubG9jYWxlcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuaW5jbHVkZXModGhpcy5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKHRoaXMuZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiB0aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSBkZWxCYXNlUGF0aChhcyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke2FkZEJhc2VQYXRoKGAke3RoaXMubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7dGhpcy5sb2NhbGV9YH0ke2FzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGh9YCB8fCAnLycpfWA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9PntcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuX2gpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ID1mYWxzZSAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7XG4gICAgICAgICAgICBzaGFsbG93XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29tcG9uZW50TG9hZCh0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBhcyA9IGFkZEJhc2VQYXRoKGFkZExvY2FsZShoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsIHRoaXMubG9jYWxlKTtcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICBsZXQgbG9jYWxlQ2hhbmdlID0gcHJldkxvY2FsZSAhPT0gdGhpcy5sb2NhbGU7XG4gICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBpZiAoIW9wdGlvbnMuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAgICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLmdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZUxpc3QoKSwgXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgICAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XG4gICAgICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAgICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lID8gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChkZWxCYXNlUGF0aChwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZVJld3JpdGVzKS5kZWZhdWx0KGFkZEJhc2VQYXRoKGFkZExvY2FsZShjbGVhbmVkQXMsIHRoaXMubG9jYWxlKSksIHBhZ2VzLCByZXdyaXRlcywgcXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcylcbiAgICAgICAgICAgICAgICAsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTG9jYWxVUkwoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgKyBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGUgcm91dGUgdXBkYXRlIHdhcyB0cmlnZ2VyZWQgZm9yIGNsaWVudC1zaWRlIGh5ZHJhdGlvbiB0aGVuXG4gICAgICogZG8gbm90IGNoZWNrIHRoZSBwcmVmbGlnaHQgcmVxdWVzdC4gT3RoZXJ3aXNlIHdoZW4gcmVuZGVyaW5nXG4gICAgICogYSBwYWdlIHdpdGggcmVmcmVzaCBpdCBtaWdodCBnZXQgaW50byBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAqLyBpZiAob3B0aW9ucy5faCAhPT0gMSkge1xuICAgICAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgY2FjaGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgIC4uLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGVmZmVjdC5hc1BhdGg7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBlZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0Lm5ld0FzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgZWZmZWN0Lm5ld1VybCwgZWZmZWN0Lm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBlZmZlY3QuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVmZmVjdC50eXBlID09PSAncmVmcmVzaCcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSA6IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtzaG91bGRJbnRlcnBvbGF0ZSA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbignLCAnKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8ocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgbGV0IHsgZXJyb3IgLCBwcm9wcyAsIF9fTl9TU0cgLCBfX05fU1NQICB9ID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKF9fTl9TU0cgfHwgX19OX1NTUCkgJiYgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucGFnZVByb3BzICYmIHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ByZXZpZXcgPSAhIXByb3BzLl9fTl9QUkVWSUVXO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCc7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8obm90Rm91bmRSb3V0ZSwgbm90Rm91bmRSb3V0ZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5faCAmJiBwYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChyZWYxID0gcmVmLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS5zdGF0dXNDb2RlKSA9PT0gNTAwICYmIChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGU7XG4gICAgICAgICAgICB2YXIgX3Njcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9PSBudWxsICYmIF9zY3JvbGwgIT09IHZvaWQgMCA/IF9zY3JvbGwgOiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBjbGVhbmVkQXMsIHJvdXRlSW5mbywgZm9yY2VkU2Nyb2xsICE9PSBudWxsICYmIGZvcmNlZFNjcm9sbCAhPT0gdm9pZCAwID8gZm9yY2VkU2Nyb2xsIDogcmVzZXRTY3JvbGwpLmNhdGNoKChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycjEpICYmIGVycjEuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCAoMCwgX3V0aWxzKS5nZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAgaWR4OiB0aGlzLl9pZHggPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5faWR4IDogdGhpcy5faWR4ICsgMVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICcnLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3JvdXRlTG9hZGVyKS5pc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgQ29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlU2hlZXRzO1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBzdHlsZVNoZWV0cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAoeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArICcnKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUm91dGVJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIGNhbiBvbmx5IHVzZSBub24taW5pdGlhbCByb3V0ZSBpbmZvXG4gICAgICAgICAgICAvLyBjYW5ub3QgcmV1c2Ugcm91dGUgaW5mbyBpbiBkZXZlbG9wbWVudCBzaW5jZSBpdCBjYW4gY2hhbmdlIGFmdGVyIEhNUlxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmIGV4aXN0aW5nUm91dGVJbmZvICYmICEoJ2luaXRpYWwnIGluIGV4aXN0aW5nUm91dGVJbmZvKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nUm91dGVJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgICAgICAgICAgICBfX05fUlNDOiAhIXJlcy5wYWdlLl9fbmV4dF9yc2NfX1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgeyBDb21wb25lbnQgLCBfX05fU1NHICwgX19OX1NTUCAsIF9fTl9SU0MgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YUhyZWY7XG4gICAgICAgICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQIHx8IF9fTl9SU0MpIHtcbiAgICAgICAgICAgICAgICBkYXRhSHJlZiA9IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgc3NnOiBfX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICByc2M6IF9fTl9SU0MsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YSgoKT0+X19OX1NTRyB8fCBfX05fU1NQID8gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzciwgZmFsc2UsIF9fTl9TU0cgPyB0aGlzLnNkYyA6IHRoaXMuc2RyLCAhIV9fTl9TU0cgJiYgIXRoaXMuaXNQcmV2aWV3KSA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlczogdGhpcy5sb2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChfX05fUlNDKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcmVzaCAsIGRhdGEgIH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKCgpPT50aGlzLl9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbihwcm9wcy5wYWdlUHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgX19mbGlnaHRfc2VyaWFsaXplZF9fOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBfX2ZsaWdodF9mcmVzaF9fOiBmcmVzaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzRXJyb3IpLmRlZmF1bHQoZXJyKSA/IGVyciA6IG5ldyBFcnJvcihlcnIgKyAnJyksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgZGF0YSwgcmVzZXRTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5pc0ZhbGxiYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuYXNQYXRoID0gYXM7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhLCByZXNldFNjcm9sbCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi8gYmVmb3JlUG9wU3RhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5fYnBzID0gY2I7XG4gICAgfVxuICAgIG9ubHlBSGFzaENoYW5nZShhcykge1xuICAgICAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSAnJyB8fCBoYXNoID09PSAndG9wJykge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdO1xuICAgICAgICBpZiAobmFtZUVsKSB7XG4gICAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoID0gdXJsLCBvcHRpb25zID0ge1xuICAgIH0pIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9ID0gYXdhaXQgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzUGF0aCwgdGhpcy5sb2NhbGUpKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcylcbiAgICAgICAgICAgICwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZmZlY3RzID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICBhczogYWRkQmFzZVBhdGgoYXNQYXRoKSxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWZmZWN0cy50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGVmZmVjdHMucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBlZmZlY3RzLnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmVmZmVjdHMucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZWZmZWN0cy5hc1BhdGg7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEodGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIHNzZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiB0aGlzLmxvY2FsZVxuICAgICAgICAgICAgICAgIH0pLCBmYWxzZSwgZmFsc2UsIHRoaXMuc2RjLCB0cnVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksIFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSB0aGlzLmNsYyA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHRoaXMuc2RjW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZnJlc2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuc2RjW2NhY2hlS2V5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRydWUsIHRydWUsIHRoaXMuc2RjLCBmYWxzZSkudGhlbigoc2VyaWFsaXplZCk9PntcbiAgICAgICAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IHNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyZXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHNlcmlhbGl6ZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfcHJlZmxpZ2h0UmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShoYXNCYXNlUGF0aChvcHRpb25zLmFzKSA/IGRlbEJhc2VQYXRoKG9wdGlvbnMuYXMpIDogb3B0aW9ucy5hcywgdGhpcy5sb2NhbGUpO1xuICAgICAgICBjb25zdCBmbnMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZUxpc3QoKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZXNQcmVmbGlnaHQgPSBmbnMuc29tZSgoW21pZGRsZXdhcmUsIGlzU1NSXSk9PntcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfZ2V0TWlkZGxld2FyZVJlZ2V4KS5nZXRNaWRkbGV3YXJlUmVnZXgobWlkZGxld2FyZSwgIWlzU1NSKSkoY2xlYW5lZEFzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVxdWlyZXNQcmVmbGlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZsaWdodCA9IGF3YWl0IHRoaXMuX2dldFByZWZsaWdodERhdGEoe1xuICAgICAgICAgICAgcHJlZmxpZ2h0SHJlZjogb3B0aW9ucy5hcyxcbiAgICAgICAgICAgIHNob3VsZENhY2hlOiBvcHRpb25zLmNhY2hlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKHJlZiA9IHByZWZsaWdodC5yZXdyaXRlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoaGFzQmFzZVBhdGgocHJlZmxpZ2h0LnJld3JpdGUpID8gZGVsQmFzZVBhdGgocHJlZmxpZ2h0LnJld3JpdGUpIDogcHJlZmxpZ2h0LnJld3JpdGUsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZnNQYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGFyc2VkLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIGxldCBtYXRjaGVkUGFnZTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRQYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWYgPSBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWYgPSByZXNvbHZlRHluYW1pY1JvdXRlKGZzUGF0aG5hbWUsIG9wdGlvbnMucGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZEhyZWYgIT09IHBhcnNlZC5wYXRobmFtZSAmJiBvcHRpb25zLnBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jld3JpdGUnLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogcGFyc2VkLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWQsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmbGlnaHQucmVkaXJlY3QpIHtcbiAgICAgICAgICAgIGlmIChwcmVmbGlnaHQucmVkaXJlY3Quc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5SZWRpcmVjdCA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGhhc0Jhc2VQYXRoKHByZWZsaWdodC5yZWRpcmVjdCkgPyBkZWxCYXNlUGF0aChwcmVmbGlnaHQucmVkaXJlY3QpIDogcHJlZmxpZ2h0LnJlZGlyZWN0LCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsICwgYXM6IG5ld0FzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIGNsZWFuUmVkaXJlY3QsIGNsZWFuUmVkaXJlY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIG5ld1VybCxcbiAgICAgICAgICAgICAgICAgICAgbmV3QXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVkaXJlY3QnLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBwcmVmbGlnaHQucmVkaXJlY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIFNTUiByZXF1ZXN0cywgdGhleSB3aWxsIGJlIGhhbmRsZWQgbGlrZSBub3JtYWwgcGFnZXMuXG4gICAgICAgIGlmIChwcmVmbGlnaHQucmVmcmVzaCAmJiAhcHJlZmxpZ2h0LnNzcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVmcmVzaCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICduZXh0J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0UHJlZmxpZ2h0RGF0YShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmbGlnaHRIcmVmICwgc2hvdWxkQ2FjaGUgPWZhbHNlICB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChwcmVmbGlnaHRIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICF0aGlzLmlzUHJldmlldyAmJiBzaG91bGRDYWNoZSAmJiB0aGlzLnNkZVtjYWNoZUtleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGVbY2FjaGVLZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2gocHJlZmxpZ2h0SHJlZiwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAneC1taWRkbGV3YXJlLXByZWZsaWdodCc6ICcxJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKChyZXMpPT57XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHByZWZsaWdodCByZXF1ZXN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZXMuaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyksXG4gICAgICAgICAgICAgICAgcmVmcmVzaDogcmVzLmhlYWRlcnMuaGFzKCd4LW1pZGRsZXdhcmUtcmVmcmVzaCcpLFxuICAgICAgICAgICAgICAgIHJld3JpdGU6IHJlcy5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLXJld3JpdGUnKSxcbiAgICAgICAgICAgICAgICBzc3I6ICEhcmVzLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtc3NyJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNkZVtjYWNoZUtleV0gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zZGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ107XG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCk7XG4gICAgICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZTtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCB7XG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhYm9ydENvbXBvbmVudExvYWQoYXMsIHJvdXRlUHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuY2xjKCk7XG4gICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50LCByZXNldFNjcm9sbCk7XG4gICAgfVxufVxuUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dCkuZGVmYXVsdCgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RG9tYWluTG9jYWxlIiwiYWRkTG9jYWxlIiwiZGVsTG9jYWxlIiwiaGFzQmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsImRlbEJhc2VQYXRoIiwiaXNMb2NhbFVSTCIsImludGVycG9sYXRlQXMiLCJyZXNvbHZlSHJlZiIsImRlZmF1bHQiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsInJlcXVpcmUiLCJfcm91dGVMb2FkZXIiLCJfaXNFcnJvciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZGVub3JtYWxpemVQYWdlUGF0aCIsIl9ub3JtYWxpemVMb2NhbGVQYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNEeW5hbWljIiwiX3BhcnNlUmVsYXRpdmVVcmwiLCJfcXVlcnlzdHJpbmciLCJfcmVzb2x2ZVJld3JpdGVzIiwiX3JvdXRlTWF0Y2hlciIsIl9yb3V0ZVJlZ2V4IiwiX2dldE1pZGRsZXdhcmVSZWdleCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImJhc2VQYXRoIiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsImFkZFBhdGhQcmVmaXgiLCJwYXRoIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicGF0aE5vUXVlcnlIYXNoIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJzdWJzdHIiLCJsZW5ndGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3RlZExvY2FsZSIsImRldGVjdGVkRG9tYWluIiwidW5kZWZpbmVkIiwiaHR0cCIsImRvbWFpbiIsImRlZmF1bHRMb2NhbGUiLCJwYXRoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUxvd2VyIiwicXVlcnlJbmRleCIsImluZGV4T2YiLCJoYXNoSW5kZXgiLCJzdWJzdHJpbmciLCJzbGljZSIsInVybCIsImxvY2F0aW9uT3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsIlVSTCIsIm9yaWdpbiIsIl8iLCJyb3V0ZSIsImFzUGF0aG5hbWUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInBhcmFtcyIsImtleXMiLCJldmVyeSIsInBhcmFtIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsImZpbHRlcmVkUXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiLCJyb3V0ZXIiLCJocmVmIiwicmVzb2x2ZUFzIiwiYmFzZSIsInVybEFzU3RyaW5nIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJ1cmxQcm90b01hdGNoIiwibWF0Y2giLCJ1cmxBc1N0cmluZ05vUHJvdG8iLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImFzUGF0aCIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpc0R5bmFtaWNSb3V0ZSIsInNlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJoYXNoIiwicmVzb2x2ZWRIcmVmIiwiXzEiLCJzdHJpcE9yaWdpbiIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZWRBcyIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJzb21lIiwicGFnZSIsInJlIiwidGVzdCIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJvcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInRoZW4iLCJyZXMiLCJvayIsInN0YXR1cyIsImpzb24iLCJkYXRhIiwibm90Rm91bmQiLCJ0ZXh0IiwiZmV0Y2hOZXh0RGF0YSIsImRhdGFIcmVmIiwiaXNTZXJ2ZXJSZW5kZXIiLCJpbmZsaWdodENhY2hlIiwicGVyc2lzdENhY2hlIiwibG9jYXRpb24iLCJjYWNoZUtleSIsImNhdGNoIiwiZXJyIiwibWFya0Fzc2V0RXJyb3IiLCJSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJwYWdlTG9hZGVyIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsInN1YnNjcmlwdGlvbiIsImlzRmFsbGJhY2siLCJpc1ByZXZpZXciLCJzZGMiLCJzZHIiLCJzZGUiLCJfaWR4Iiwib25Qb3BTdGF0ZSIsImUiLCJzdGF0ZSIsImNoYW5nZVN0YXRlIiwiZ2V0VVJMIiwiX19OIiwiZm9yY2VkU2Nyb2xsIiwib3B0aW9ucyIsImlkeCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0SXRlbSIsInBhcnNlIiwicGFyc2VSZWxhdGl2ZVVybCIsImlzU3NyIiwiX2JwcyIsImNoYW5nZSIsInNoYWxsb3ciLCJfc2hhbGxvdyIsImNvbXBvbmVudHMiLCJyZWYiLCJpbml0aWFsIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsIl9fTl9SU0MiLCJfX25leHRfcnNjX18iLCJzdHlsZVNoZWV0cyIsImV2ZW50cyIsImF1dG9FeHBvcnREeW5hbWljIiwiX19ORVhUX0RBVEFfXyIsImF1dG9FeHBvcnQiLCJzdWIiLCJjbGMiLCJfd3JhcEFwcCIsImlzUmVhZHkiLCJnc3NwIiwiZ2lwIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsImlzTG9jYWxlRG9tYWluIiwiaG9zdG5hbWUiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJyZWxvYWQiLCJiYWNrIiwicHVzaCIsIm1ldGhvZCIsInNob3VsZFJlc29sdmVIcmVmIiwicHJldkxvY2FsZSIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRpZE5hdmlnYXRlIiwiYXNOb0Jhc2VQYXRoIiwicm91dGVQcm9wcyIsImNsZWFuZWRBcyIsImxvY2FsZUNoYW5nZSIsInBhcnNlZCIsInJld3JpdGVzIiwicmV3cml0ZXNSZXN1bHQiLCJlZmZlY3QiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJlZjEiLCJyb3V0ZUluZm8iLCJkZXN0aW5hdGlvbiIsInBhcnNlZEhyZWYiLCJuZXdVcmwiLCJuZXdBcyIsIm5vdEZvdW5kUm91dGUiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiX3Njcm9sbCIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwiX2giLCJQcm9taXNlIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJfaW5GbGlnaHRSb3V0ZSIsImFib3J0Q29tcG9uZW50TG9hZCIsIm9ubHlBSGFzaENoYW5nZSIsImVtaXQiLCJzY3JvbGxUb0hhc2giLCJub3RpZnkiLCJhbGwiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJnZXRNaWRkbGV3YXJlTGlzdCIsIl9fcmV3cml0ZXMiLCJ1cmxJc05ldyIsInAiLCJtYXRjaGVkUGFnZSIsIl9wcmVmbGlnaHRSZXF1ZXN0IiwiY2FjaGUiLCJ0eXBlIiwiZmlsdGVyIiwid2FybiIsImdldFJvdXRlSW5mbyIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJfX05fUFJFVklFVyIsImZldGNoQ29tcG9uZW50Iiwic3RhdHVzQ29kZSIsInNjcm9sbCIsInNldCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsImV4aXN0aW5nUm91dGVJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZnJlc2giLCJtb2QiLCJnZXREYXRhSHJlZiIsInNzZyIsInJzYyIsIl9nZXREYXRhIiwiX2dldEZsaWdodERhdGEiLCJfX2ZsaWdodF9zZXJpYWxpemVkX18iLCJfX2ZsaWdodF9mcmVzaF9fIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwic2Nyb2xsVG8iLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwicHJlZmV0Y2giLCJlZmZlY3RzIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsImNhbmNlbCIsImhhbmRsZUNhbmNlbGxlZCIsImNvbXBvbmVudFJlc3VsdCIsImxvYWRQYWdlIiwiZm4iLCJyZXNvbHZlIiwic2VyaWFsaXplZCIsImZucyIsInJlcXVpcmVzUHJlZmxpZ2h0IiwicHJlZmxpZ2h0IiwiZnNQYXRobmFtZSIsImNsZWFuUmVkaXJlY3QiLCJtaWRkbGV3YXJlIiwiaXNTU1IiLCJnZXRNaWRkbGV3YXJlUmVnZXgiLCJfZ2V0UHJlZmxpZ2h0RGF0YSIsInByZWZsaWdodEhyZWYiLCJzaG91bGRDYWNoZSIsInJld3JpdGUiLCJyZWRpcmVjdCIsInJlZnJlc2giLCJzc3IiLCJoZWFkZXJzIiwiZ2V0IiwiaGFzIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n");

/***/ })

});