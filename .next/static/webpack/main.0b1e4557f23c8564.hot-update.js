"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/@next/react-dev-overlay/lib/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/client.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nexports.__esModule = true;\nexports.onRefresh = exports.unregister = exports.register = exports.onBuildError = exports.onBuildOk = exports.ReactDevOverlay = exports.getNodeError = void 0;\nvar Bus = __importStar(__webpack_require__(/*! ./internal/bus */ \"./node_modules/@next/react-dev-overlay/lib/internal/bus.js\"));\nvar parseStack_1 = __webpack_require__(/*! ./internal/helpers/parseStack */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js\");\nvar isRegistered = false;\nvar stackTraceLimit = undefined;\nfunction onUnhandledError(ev) {\n    var error = ev === null || ev === void 0 ? void 0 : ev.error;\n    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {\n        // A non-error was thrown, we don't have anything to show. :-(\n        return;\n    }\n    var e = error;\n    Bus.emit({\n        type: Bus.TYPE_UNHANDLED_ERROR,\n        reason: error,\n        frames: (0, parseStack_1.parseStack)(e.stack)\n    });\n}\nfunction onUnhandledRejection(ev) {\n    var reason = ev === null || ev === void 0 ? void 0 : ev.reason;\n    if (!reason ||\n        !(reason instanceof Error) ||\n        typeof reason.stack !== 'string') {\n        // A non-error was thrown, we don't have anything to show. :-(\n        return;\n    }\n    var e = reason;\n    Bus.emit({\n        type: Bus.TYPE_UNHANDLED_REJECTION,\n        reason: reason,\n        frames: (0, parseStack_1.parseStack)(e.stack)\n    });\n}\nfunction register() {\n    if (isRegistered) {\n        return;\n    }\n    isRegistered = true;\n    try {\n        var limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 50;\n        stackTraceLimit = limit;\n    }\n    catch (_a) { }\n    window.addEventListener('error', onUnhandledError);\n    window.addEventListener('unhandledrejection', onUnhandledRejection);\n}\nexports.register = register;\nfunction unregister() {\n    if (!isRegistered) {\n        return;\n    }\n    isRegistered = false;\n    if (stackTraceLimit !== undefined) {\n        try {\n            Error.stackTraceLimit = stackTraceLimit;\n        }\n        catch (_a) { }\n        stackTraceLimit = undefined;\n    }\n    window.removeEventListener('error', onUnhandledError);\n    window.removeEventListener('unhandledrejection', onUnhandledRejection);\n}\nexports.unregister = unregister;\nfunction onBuildOk() {\n    Bus.emit({ type: Bus.TYPE_BUILD_OK });\n}\nexports.onBuildOk = onBuildOk;\nfunction onBuildError(message) {\n    Bus.emit({ type: Bus.TYPE_BUILD_ERROR, message: message });\n}\nexports.onBuildError = onBuildError;\nfunction onRefresh() {\n    Bus.emit({ type: Bus.TYPE_REFRESH });\n}\nexports.onRefresh = onRefresh;\nvar nodeStackFrames_1 = __webpack_require__(/*! ./internal/helpers/nodeStackFrames */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js\");\n__createBinding(exports, nodeStackFrames_1, \"getNodeError\");\nvar ReactDevOverlay_1 = __webpack_require__(/*! ./internal/ReactDevOverlay */ \"./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js\");\n__createBinding(exports, ReactDevOverlay_1, \"default\", \"ReactDevOverlay\");\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQjtBQUNySix1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBLGlCQUFpQjtBQUNqQix3QkFBd0IsbUJBQU8sQ0FBQywwSEFBb0M7QUFDcEU7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywwR0FBNEI7QUFDNUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudC5qcz80M2RkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5vblJlZnJlc2ggPSBleHBvcnRzLnVucmVnaXN0ZXIgPSBleHBvcnRzLnJlZ2lzdGVyID0gZXhwb3J0cy5vbkJ1aWxkRXJyb3IgPSBleHBvcnRzLm9uQnVpbGRPayA9IGV4cG9ydHMuUmVhY3REZXZPdmVybGF5ID0gZXhwb3J0cy5nZXROb2RlRXJyb3IgPSB2b2lkIDA7XG52YXIgQnVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVybmFsL2J1c1wiKSk7XG52YXIgcGFyc2VTdGFja18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrXCIpO1xudmFyIGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xudmFyIHN0YWNrVHJhY2VMaW1pdCA9IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXYpIHtcbiAgICB2YXIgZXJyb3IgPSBldiA9PT0gbnVsbCB8fCBldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXYuZXJyb3I7XG4gICAgaWYgKCFlcnJvciB8fCAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHx8IHR5cGVvZiBlcnJvci5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZSA9IGVycm9yO1xuICAgIEJ1cy5lbWl0KHtcbiAgICAgICAgdHlwZTogQnVzLlRZUEVfVU5IQU5ETEVEX0VSUk9SLFxuICAgICAgICByZWFzb246IGVycm9yLFxuICAgICAgICBmcmFtZXM6ICgwLCBwYXJzZVN0YWNrXzEucGFyc2VTdGFjaykoZS5zdGFjaylcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2KSB7XG4gICAgdmFyIHJlYXNvbiA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5yZWFzb247XG4gICAgaWYgKCFyZWFzb24gfHxcbiAgICAgICAgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikgfHxcbiAgICAgICAgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZSA9IHJlYXNvbjtcbiAgICBCdXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IEJ1cy5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT04sXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICBmcmFtZXM6ICgwLCBwYXJzZVN0YWNrXzEucGFyc2VTdGFjaykoZS5zdGFjaylcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgIGlmIChpc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNTA7XG4gICAgICAgIHN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBvblVuaGFuZGxlZFJlamVjdGlvbik7XG59XG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5mdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgaWYgKHN0YWNrVHJhY2VMaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xufVxuZXhwb3J0cy51bnJlZ2lzdGVyID0gdW5yZWdpc3RlcjtcbmZ1bmN0aW9uIG9uQnVpbGRPaygpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX0JVSUxEX09LIH0pO1xufVxuZXhwb3J0cy5vbkJ1aWxkT2sgPSBvbkJ1aWxkT2s7XG5mdW5jdGlvbiBvbkJ1aWxkRXJyb3IobWVzc2FnZSkge1xuICAgIEJ1cy5lbWl0KHsgdHlwZTogQnVzLlRZUEVfQlVJTERfRVJST1IsIG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG59XG5leHBvcnRzLm9uQnVpbGRFcnJvciA9IG9uQnVpbGRFcnJvcjtcbmZ1bmN0aW9uIG9uUmVmcmVzaCgpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX1JFRlJFU0ggfSk7XG59XG5leHBvcnRzLm9uUmVmcmVzaCA9IG9uUmVmcmVzaDtcbnZhciBub2RlU3RhY2tGcmFtZXNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2hlbHBlcnMvbm9kZVN0YWNrRnJhbWVzXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG5vZGVTdGFja0ZyYW1lc18xLCBcImdldE5vZGVFcnJvclwiKTtcbnZhciBSZWFjdERldk92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheVwiKTtcbl9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBSZWFjdERldk92ZXJsYXlfMSwgXCJkZWZhdWx0XCIsIFwiUmVhY3REZXZPdmVybGF5XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/client.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nexports.__esModule = true;\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Bus = __importStar(__webpack_require__(/*! ./bus */ \"./node_modules/@next/react-dev-overlay/lib/internal/bus.js\"));\nvar ShadowPortal_1 = __webpack_require__(/*! ./components/ShadowPortal */ \"./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js\");\nvar Errors_1 = __webpack_require__(/*! ./container/Errors */ \"./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js\");\nvar BuildError_1 = __webpack_require__(/*! ./container/BuildError */ \"./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js\");\nvar ErrorBoundary_1 = __webpack_require__(/*! ./ErrorBoundary */ \"./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js\");\nvar Base_1 = __webpack_require__(/*! ./styles/Base */ \"./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js\");\nvar ComponentStyles_1 = __webpack_require__(/*! ./styles/ComponentStyles */ \"./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js\");\nvar CssReset_1 = __webpack_require__(/*! ./styles/CssReset */ \"./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js\");\nfunction reducer(state, ev) {\n    switch (ev.type) {\n        case Bus.TYPE_BUILD_OK: {\n            return __assign(__assign({}, state), { buildError: null });\n        }\n        case Bus.TYPE_BUILD_ERROR: {\n            return __assign(__assign({}, state), { buildError: ev.message });\n        }\n        case Bus.TYPE_REFRESH: {\n            return __assign(__assign({}, state), { buildError: null, errors: [] });\n        }\n        case Bus.TYPE_UNHANDLED_ERROR:\n        case Bus.TYPE_UNHANDLED_REJECTION: {\n            return __assign(__assign({}, state), { nextId: state.nextId + 1, errors: __spreadArray(__spreadArray([], __read(state.errors), false), [{ id: state.nextId, event: ev }], false) });\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            var _1 = ev;\n            return state;\n        }\n    }\n}\nvar ReactDevOverlay = function ReactDevOverlay(_a) {\n    var children = _a.children;\n    var _b = __read(React.useReducer(reducer, { nextId: 1, buildError: null, errors: [] }), 2), state = _b[0], dispatch = _b[1];\n    React.useEffect(function () {\n        Bus.on(dispatch);\n        return function () {\n            Bus.off(dispatch);\n        };\n    }, [dispatch]);\n    var onComponentError = React.useCallback(function (_error, _componentStack) {\n        // TODO: special handling\n    }, []);\n    var hasBuildError = state.buildError != null;\n    var hasRuntimeErrors = Boolean(state.errors.length);\n    var isMounted = hasBuildError || hasRuntimeErrors;\n    return (React.createElement(React.Fragment, null,\n        React.createElement(ErrorBoundary_1.ErrorBoundary, { onError: onComponentError }, children !== null && children !== void 0 ? children : null),\n        isMounted ? (React.createElement(ShadowPortal_1.ShadowPortal, null,\n            React.createElement(CssReset_1.CssReset, null),\n            React.createElement(Base_1.Base, null),\n            React.createElement(ComponentStyles_1.ComponentStyles, null),\n            hasBuildError ? (React.createElement(BuildError_1.BuildError, { message: state.buildError })) : hasRuntimeErrors ? (React.createElement(Errors_1.Errors, { errors: state.errors })) : undefined)) : undefined));\n};\nexports[\"default\"] = ReactDevOverlay;\n//# sourceMappingURL=ReactDevOverlay.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIseUJBQXlCLG1CQUFPLENBQUMsNENBQU87QUFDeEMsdUJBQXVCLG1CQUFPLENBQUMseUVBQU87QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsaUhBQTJCO0FBQ3hELGVBQWUsbUJBQU8sQ0FBQyxtR0FBb0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsMkdBQXdCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLDZGQUFpQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMseUZBQWU7QUFDcEMsd0JBQXdCLG1CQUFPLENBQUMsK0dBQTBCO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLGlHQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWSxrQkFBa0I7QUFDckU7QUFDQTtBQUNBLHVDQUF1QyxZQUFZLHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVksOEJBQThCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZLG1HQUFtRyw2QkFBNkIsV0FBVztBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwyQkFBMkIsZ0VBQWdFLHNCQUFzQjtBQUM3TDtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheS5qcz8zNTU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEJ1cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9idXNcIikpO1xudmFyIFNoYWRvd1BvcnRhbF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9TaGFkb3dQb3J0YWxcIik7XG52YXIgRXJyb3JzXzEgPSByZXF1aXJlKFwiLi9jb250YWluZXIvRXJyb3JzXCIpO1xudmFyIEJ1aWxkRXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9CdWlsZEVycm9yXCIpO1xudmFyIEVycm9yQm91bmRhcnlfMSA9IHJlcXVpcmUoXCIuL0Vycm9yQm91bmRhcnlcIik7XG52YXIgQmFzZV8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Jhc2VcIik7XG52YXIgQ29tcG9uZW50U3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ29tcG9uZW50U3R5bGVzXCIpO1xudmFyIENzc1Jlc2V0XzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ3NzUmVzZXRcIik7XG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBldikge1xuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgICBjYXNlIEJ1cy5UWVBFX0JVSUxEX09LOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQnVzLlRZUEVfQlVJTERfRVJST1I6IHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IGJ1aWxkRXJyb3I6IGV2Lm1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBCdXMuVFlQRV9SRUZSRVNIOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsLCBlcnJvcnM6IFtdIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQnVzLlRZUEVfVU5IQU5ETEVEX0VSUk9SOlxuICAgICAgICBjYXNlIEJ1cy5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT046IHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IG5leHRJZDogc3RhdGUubmV4dElkICsgMSwgZXJyb3JzOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChzdGF0ZS5lcnJvcnMpLCBmYWxzZSksIFt7IGlkOiBzdGF0ZS5uZXh0SWQsIGV2ZW50OiBldiB9XSwgZmFsc2UpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIHZhciBfMSA9IGV2O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIFJlYWN0RGV2T3ZlcmxheSA9IGZ1bmN0aW9uIFJlYWN0RGV2T3ZlcmxheShfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VSZWR1Y2VyKHJlZHVjZXIsIHsgbmV4dElkOiAxLCBidWlsZEVycm9yOiBudWxsLCBlcnJvcnM6IFtdIH0pLCAyKSwgc3RhdGUgPSBfYlswXSwgZGlzcGF0Y2ggPSBfYlsxXTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBCdXMub24oZGlzcGF0Y2gpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQnVzLm9mZihkaXNwYXRjaCk7XG4gICAgICAgIH07XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIG9uQ29tcG9uZW50RXJyb3IgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoX2Vycm9yLCBfY29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgLy8gVE9ETzogc3BlY2lhbCBoYW5kbGluZ1xuICAgIH0sIFtdKTtcbiAgICB2YXIgaGFzQnVpbGRFcnJvciA9IHN0YXRlLmJ1aWxkRXJyb3IgIT0gbnVsbDtcbiAgICB2YXIgaGFzUnVudGltZUVycm9ycyA9IEJvb2xlYW4oc3RhdGUuZXJyb3JzLmxlbmd0aCk7XG4gICAgdmFyIGlzTW91bnRlZCA9IGhhc0J1aWxkRXJyb3IgfHwgaGFzUnVudGltZUVycm9ycztcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeV8xLkVycm9yQm91bmRhcnksIHsgb25FcnJvcjogb25Db21wb25lbnRFcnJvciB9LCBjaGlsZHJlbiAhPT0gbnVsbCAmJiBjaGlsZHJlbiAhPT0gdm9pZCAwID8gY2hpbGRyZW4gOiBudWxsKSxcbiAgICAgICAgaXNNb3VudGVkID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhZG93UG9ydGFsXzEuU2hhZG93UG9ydGFsLCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDc3NSZXNldF8xLkNzc1Jlc2V0LCBudWxsKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZV8xLkJhc2UsIG51bGwpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnRTdHlsZXNfMS5Db21wb25lbnRTdHlsZXMsIG51bGwpLFxuICAgICAgICAgICAgaGFzQnVpbGRFcnJvciA/IChSZWFjdC5jcmVhdGVFbGVtZW50KEJ1aWxkRXJyb3JfMS5CdWlsZEVycm9yLCB7IG1lc3NhZ2U6IHN0YXRlLmJ1aWxkRXJyb3IgfSkpIDogaGFzUnVudGltZUVycm9ycyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yc18xLkVycm9ycywgeyBlcnJvcnM6IHN0YXRlLmVycm9ycyB9KSkgOiB1bmRlZmluZWQpKSA6IHVuZGVmaW5lZCkpO1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUmVhY3REZXZPdmVybGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhY3REZXZPdmVybGF5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js":
/*!******************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/bus.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexports.__esModule = true;\nexports.off = exports.on = exports.emit = exports.TYPE_UNHANDLED_REJECTION = exports.TYPE_UNHANDLED_ERROR = exports.TYPE_REFRESH = exports.TYPE_BUILD_ERROR = exports.TYPE_BUILD_OK = void 0;\nexports.TYPE_BUILD_OK = 'build-ok';\nexports.TYPE_BUILD_ERROR = 'build-error';\nexports.TYPE_REFRESH = 'fast-refresh';\nexports.TYPE_UNHANDLED_ERROR = 'unhandled-error';\nexports.TYPE_UNHANDLED_REJECTION = 'unhandled-rejection';\nvar handlers = new Set();\nvar queue = [];\nfunction drain() {\n    // Draining should never happen synchronously in case multiple handlers are\n    // registered.\n    setTimeout(function () {\n        var _loop_1 = function () {\n            var ev = queue.shift();\n            handlers.forEach(function (handler) { return handler(ev); });\n        };\n        while (\n        // Until we are out of events:\n        Boolean(queue.length) &&\n            // Or, if all handlers removed themselves as a result of handling the\n            // event(s)\n            Boolean(handlers.size)) {\n            _loop_1();\n        }\n    }, 1);\n}\nfunction emit(ev) {\n    queue.push(Object.freeze(__assign({}, ev)));\n    drain();\n}\nexports.emit = emit;\nfunction on(fn) {\n    if (handlers.has(fn)) {\n        return false;\n    }\n    handlers.add(fn);\n    drain();\n    return true;\n}\nexports.on = on;\nfunction off(fn) {\n    if (handlers.has(fn)) {\n        handlers[\"delete\"](fn);\n        return true;\n    }\n    return false;\n}\nexports.off = off;\n//# sourceMappingURL=bus.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2J1cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFdBQVcsR0FBRyxVQUFVLEdBQUcsWUFBWSxHQUFHLGdDQUFnQyxHQUFHLDRCQUE0QixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLHFCQUFxQjtBQUNuTCxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2J1cy5qcz84NGM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLm9mZiA9IGV4cG9ydHMub24gPSBleHBvcnRzLmVtaXQgPSBleHBvcnRzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTiA9IGV4cG9ydHMuVFlQRV9VTkhBTkRMRURfRVJST1IgPSBleHBvcnRzLlRZUEVfUkVGUkVTSCA9IGV4cG9ydHMuVFlQRV9CVUlMRF9FUlJPUiA9IGV4cG9ydHMuVFlQRV9CVUlMRF9PSyA9IHZvaWQgMDtcbmV4cG9ydHMuVFlQRV9CVUlMRF9PSyA9ICdidWlsZC1vayc7XG5leHBvcnRzLlRZUEVfQlVJTERfRVJST1IgPSAnYnVpbGQtZXJyb3InO1xuZXhwb3J0cy5UWVBFX1JFRlJFU0ggPSAnZmFzdC1yZWZyZXNoJztcbmV4cG9ydHMuVFlQRV9VTkhBTkRMRURfRVJST1IgPSAndW5oYW5kbGVkLWVycm9yJztcbmV4cG9ydHMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZC1yZWplY3Rpb24nO1xudmFyIGhhbmRsZXJzID0gbmV3IFNldCgpO1xudmFyIHF1ZXVlID0gW107XG5mdW5jdGlvbiBkcmFpbigpIHtcbiAgICAvLyBEcmFpbmluZyBzaG91bGQgbmV2ZXIgaGFwcGVuIHN5bmNocm9ub3VzbHkgaW4gY2FzZSBtdWx0aXBsZSBoYW5kbGVycyBhcmVcbiAgICAvLyByZWdpc3RlcmVkLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBldiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKGV2KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgLy8gVW50aWwgd2UgYXJlIG91dCBvZiBldmVudHM6XG4gICAgICAgIEJvb2xlYW4ocXVldWUubGVuZ3RoKSAmJlxuICAgICAgICAgICAgLy8gT3IsIGlmIGFsbCBoYW5kbGVycyByZW1vdmVkIHRoZW1zZWx2ZXMgYXMgYSByZXN1bHQgb2YgaGFuZGxpbmcgdGhlXG4gICAgICAgICAgICAvLyBldmVudChzKVxuICAgICAgICAgICAgQm9vbGVhbihoYW5kbGVycy5zaXplKSkge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9XG4gICAgfSwgMSk7XG59XG5mdW5jdGlvbiBlbWl0KGV2KSB7XG4gICAgcXVldWUucHVzaChPYmplY3QuZnJlZXplKF9fYXNzaWduKHt9LCBldikpKTtcbiAgICBkcmFpbigpO1xufVxuZXhwb3J0cy5lbWl0ID0gZW1pdDtcbmZ1bmN0aW9uIG9uKGZuKSB7XG4gICAgaWYgKGhhbmRsZXJzLmhhcyhmbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVycy5hZGQoZm4pO1xuICAgIGRyYWluKCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLm9uID0gb247XG5mdW5jdGlvbiBvZmYoZm4pIHtcbiAgICBpZiAoaGFuZGxlcnMuaGFzKGZuKSkge1xuICAgICAgICBoYW5kbGVyc1tcImRlbGV0ZVwiXShmbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLm9mZiA9IG9mZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/bus.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nexports.CodeFrame = void 0;\nvar anser_1 = __importDefault(__webpack_require__(/*! anser */ \"./node_modules/anser/lib/index.js\"));\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ \"./node_modules/strip-ansi/index.js\"));\nvar stack_frame_1 = __webpack_require__(/*! ../../helpers/stack-frame */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js\");\nvar CodeFrame = function CodeFrame(_a) {\n    var stackFrame = _a.stackFrame, codeFrame = _a.codeFrame;\n    // Strip leading spaces out of the code frame:\n    var formattedFrame = React.useMemo(function () {\n        var lines = codeFrame.split(/\\r?\\n/g);\n        var prefixLength = lines\n            .map(function (line) { return /^>? +\\d+ +\\| ( *)/.exec((0, strip_ansi_1[\"default\"])(line)); })\n            .filter(Boolean)\n            .map(function (v) { return v.pop(); })\n            .reduce(function (c, n) { return (isNaN(c) ? n.length : Math.min(c, n.length)); }, NaN);\n        if (prefixLength > 1) {\n            var p_1 = ' '.repeat(prefixLength);\n            return lines\n                .map(function (line, a) {\n                return ~(a = line.indexOf('|'))\n                    ? line.substring(0, a) + line.substring(a).replace(p_1, '')\n                    : line;\n            })\n                .join('\\n');\n        }\n        return lines.join('\\n');\n    }, [codeFrame]);\n    var decoded = React.useMemo(function () {\n        return anser_1[\"default\"].ansiToJson(formattedFrame, {\n            json: true,\n            use_classes: true,\n            remove_empty: true\n        });\n    }, [formattedFrame]);\n    var open = React.useCallback(function () {\n        var _a;\n        var params = new URLSearchParams();\n        for (var key in stackFrame) {\n            params.append(key, ((_a = stackFrame[key]) !== null && _a !== void 0 ? _a : '').toString());\n        }\n        self\n            .fetch(( false || '') + \"/__nextjs_launch-editor?\" + params.toString())\n            .then(function () { }, function () {\n            console.error('There was an issue opening this code in your editor.');\n        });\n    }, [stackFrame]);\n    // TODO: make the caret absolute\n    return (React.createElement(\"div\", { \"data-nextjs-codeframe\": true },\n        React.createElement(\"div\", null,\n            React.createElement(\"p\", { role: \"link\", onClick: open, tabIndex: 1, title: \"Click to open in your editor\" },\n                React.createElement(\"span\", null,\n                    (0, stack_frame_1.getFrameSource)(stackFrame),\n                    \" @ \",\n                    stackFrame.methodName),\n                React.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 24 24\", fill: \"none\", stroke: \"currentColor\", strokeWidth: \"2\", strokeLinecap: \"round\", strokeLinejoin: \"round\" },\n                    React.createElement(\"path\", { d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\" }),\n                    React.createElement(\"polyline\", { points: \"15 3 21 3 21 9\" }),\n                    React.createElement(\"line\", { x1: \"10\", y1: \"14\", x2: \"21\", y2: \"3\" })))),\n        React.createElement(\"pre\", null, decoded.map(function (entry, index) { return (React.createElement(\"span\", { key: \"frame-\" + index, style: __assign({ color: entry.fg ? \"var(--color-\" + entry.fg + \")\" : undefined }, (entry.decoration === 'bold'\n                ? { fontWeight: 800 }\n                : entry.decoration === 'italic'\n                    ? { fontStyle: 'italic' }\n                    : undefined)) }, entry.content)); }))));\n};\nexports.CodeFrame = CodeFrame;\n//# sourceMappingURL=CodeFrame.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL0NvZGVGcmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsOEJBQThCLG1CQUFPLENBQUMsZ0RBQU87QUFDN0MseUJBQXlCLG1CQUFPLENBQUMsNENBQU87QUFDeEMsbUNBQW1DLG1CQUFPLENBQUMsc0RBQVk7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNkdBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzRUFBc0U7QUFDekc7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pELHNDQUFzQyx1REFBdUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQWtDO0FBQ3RELGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsK0JBQStCO0FBQ3hFO0FBQ0EsdUNBQXVDLGlGQUFpRjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvS0FBb0s7QUFDak4sa0RBQWtELCtEQUErRDtBQUNqSCxzREFBc0QsMEJBQTBCO0FBQ2hGLGtEQUFrRCx1Q0FBdUM7QUFDekYsK0VBQStFLHNDQUFzQyx5Q0FBeUMsK0RBQStEO0FBQzdOLG9CQUFvQjtBQUNwQjtBQUNBLHdCQUF3QjtBQUN4QixtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvQ29kZUZyYW1lLmpzPzlmY2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5Db2RlRnJhbWUgPSB2b2lkIDA7XG52YXIgYW5zZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW5zZXJcIikpO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgc3RyaXBfYW5zaV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzdHJpcC1hbnNpXCIpKTtcbnZhciBzdGFja19mcmFtZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XG52YXIgQ29kZUZyYW1lID0gZnVuY3Rpb24gQ29kZUZyYW1lKF9hKSB7XG4gICAgdmFyIHN0YWNrRnJhbWUgPSBfYS5zdGFja0ZyYW1lLCBjb2RlRnJhbWUgPSBfYS5jb2RlRnJhbWU7XG4gICAgLy8gU3RyaXAgbGVhZGluZyBzcGFjZXMgb3V0IG9mIHRoZSBjb2RlIGZyYW1lOlxuICAgIHZhciBmb3JtYXR0ZWRGcmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZXMgPSBjb2RlRnJhbWUuc3BsaXQoL1xccj9cXG4vZyk7XG4gICAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBsaW5lc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gL14+PyArXFxkKyArXFx8ICggKikvLmV4ZWMoKDAsIHN0cmlwX2Fuc2lfMVtcImRlZmF1bHRcIl0pKGxpbmUpKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucG9wKCk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChjLCBuKSB7IHJldHVybiAoaXNOYU4oYykgPyBuLmxlbmd0aCA6IE1hdGgubWluKGMsIG4ubGVuZ3RoKSk7IH0sIE5hTik7XG4gICAgICAgIGlmIChwcmVmaXhMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgcF8xID0gJyAnLnJlcGVhdChwcmVmaXhMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB+KGEgPSBsaW5lLmluZGV4T2YoJ3wnKSlcbiAgICAgICAgICAgICAgICAgICAgPyBsaW5lLnN1YnN0cmluZygwLCBhKSArIGxpbmUuc3Vic3RyaW5nKGEpLnJlcGxhY2UocF8xLCAnJylcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH0sIFtjb2RlRnJhbWVdKTtcbiAgICB2YXIgZGVjb2RlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW5zZXJfMVtcImRlZmF1bHRcIl0uYW5zaVRvSnNvbihmb3JtYXR0ZWRGcmFtZSwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtmb3JtYXR0ZWRGcmFtZV0pO1xuICAgIHZhciBvcGVuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgKChfYSA9IHN0YWNrRnJhbWVba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGZcbiAgICAgICAgICAgIC5mZXRjaCgocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJykgKyBcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZXJlIHdhcyBhbiBpc3N1ZSBvcGVuaW5nIHRoaXMgY29kZSBpbiB5b3VyIGVkaXRvci4nKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3N0YWNrRnJhbWVdKTtcbiAgICAvLyBUT0RPOiBtYWtlIHRoZSBjYXJldCBhYnNvbHV0ZVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtY29kZWZyYW1lXCI6IHRydWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgeyByb2xlOiBcImxpbmtcIiwgb25DbGljazogb3BlbiwgdGFiSW5kZXg6IDEsIHRpdGxlOiBcIkNsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3JcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICgwLCBzdGFja19mcmFtZV8xLmdldEZyYW1lU291cmNlKShzdGFja0ZyYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgXCIgQCBcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tGcmFtZS5tZXRob2ROYW1lKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOCAxM3Y2YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg2XCIgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IHBvaW50czogXCIxNSAzIDIxIDMgMjEgOVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEwXCIsIHkxOiBcIjE0XCIsIHgyOiBcIjIxXCIsIHkyOiBcIjNcIiB9KSkpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBudWxsLCBkZWNvZGVkLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBrZXk6IFwiZnJhbWUtXCIgKyBpbmRleCwgc3R5bGU6IF9fYXNzaWduKHsgY29sb3I6IGVudHJ5LmZnID8gXCJ2YXIoLS1jb2xvci1cIiArIGVudHJ5LmZnICsgXCIpXCIgOiB1bmRlZmluZWQgfSwgKGVudHJ5LmRlY29yYXRpb24gPT09ICdib2xkJ1xuICAgICAgICAgICAgICAgID8geyBmb250V2VpZ2h0OiA4MDAgfVxuICAgICAgICAgICAgICAgIDogZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2l0YWxpYydcbiAgICAgICAgICAgICAgICAgICAgPyB7IGZvbnRTdHlsZTogJ2l0YWxpYycgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkpIH0sIGVudHJ5LmNvbnRlbnQpKTsgfSkpKSk7XG59O1xuZXhwb3J0cy5Db2RlRnJhbWUgPSBDb2RlRnJhbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2RlRnJhbWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js\n");

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n    return cooked;\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nexports.__esModule = true;\nexports.RuntimeError = exports.styles = void 0;\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar CodeFrame_1 = __webpack_require__(/*! ../components/CodeFrame */ \"./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js\");\nvar noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js\");\nvar stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ \"./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js\");\nvar CallStackFrame = function CallStackFrame(_a) {\n    // TODO: ability to expand resolved frames\n    // TODO: render error or external indicator\n    var _b;\n    var frame = _a.frame;\n    var f = (_b = frame.originalStackFrame) !== null && _b !== void 0 ? _b : frame.sourceStackFrame;\n    var hasSource = Boolean(frame.originalCodeFrame);\n    var open = React.useCallback(function () {\n        var _a;\n        if (!hasSource)\n            return;\n        var params = new URLSearchParams();\n        for (var key in f) {\n            params.append(key, ((_a = f[key]) !== null && _a !== void 0 ? _a : '').toString());\n        }\n        self\n            .fetch(( false || '') + \"/__nextjs_launch-editor?\" + params.toString())\n            .then(function () { }, function () {\n            console.error('There was an issue opening this code in your editor.');\n        });\n    }, [hasSource, f]);\n    return (React.createElement(\"div\", { \"data-nextjs-call-stack-frame\": true },\n        React.createElement(\"h6\", { \"data-nextjs-frame-expanded\": Boolean(frame.expanded) }, f.methodName),\n        React.createElement(\"div\", { \"data-has-source\": hasSource ? 'true' : undefined, tabIndex: hasSource ? 10 : undefined, role: hasSource ? 'link' : undefined, onClick: open, title: hasSource ? 'Click to open in your editor' : undefined },\n            React.createElement(\"span\", null, (0, stack_frame_1.getFrameSource)(f)),\n            React.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 24 24\", fill: \"none\", stroke: \"currentColor\", strokeWidth: \"2\", strokeLinecap: \"round\", strokeLinejoin: \"round\" },\n                React.createElement(\"path\", { d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\" }),\n                React.createElement(\"polyline\", { points: \"15 3 21 3 21 9\" }),\n                React.createElement(\"line\", { x1: \"10\", y1: \"14\", x2: \"21\", y2: \"3\" })))));\n};\nvar RuntimeError = function RuntimeError(_a) {\n    var error = _a.error;\n    var firstFirstPartyFrameIndex = React.useMemo(function () {\n        return error.frames.findIndex(function (entry) {\n            return entry.expanded &&\n                Boolean(entry.originalCodeFrame) &&\n                Boolean(entry.originalStackFrame);\n        });\n    }, [error.frames]);\n    var firstFrame = React.useMemo(function () {\n        var _a;\n        return (_a = error.frames[firstFirstPartyFrameIndex]) !== null && _a !== void 0 ? _a : null;\n    }, [error.frames, firstFirstPartyFrameIndex]);\n    var allLeadingFrames = React.useMemo(function () {\n        return firstFirstPartyFrameIndex < 0\n            ? []\n            : error.frames.slice(0, firstFirstPartyFrameIndex);\n    }, [error.frames, firstFirstPartyFrameIndex]);\n    var _b = __read(React.useState(firstFrame == null), 2), all = _b[0], setAll = _b[1];\n    var toggleAll = React.useCallback(function () {\n        setAll(function (v) { return !v; });\n    }, []);\n    var leadingFrames = React.useMemo(function () { return allLeadingFrames.filter(function (f) { return f.expanded || all; }); }, [all, allLeadingFrames]);\n    var allCallStackFrames = React.useMemo(function () { return error.frames.slice(firstFirstPartyFrameIndex + 1); }, [error.frames, firstFirstPartyFrameIndex]);\n    var visibleCallStackFrames = React.useMemo(function () { return allCallStackFrames.filter(function (f) { return f.expanded || all; }); }, [all, allCallStackFrames]);\n    var canShowMore = React.useMemo(function () {\n        return (allCallStackFrames.length !== visibleCallStackFrames.length ||\n            (all && firstFrame != null));\n    }, [\n        all,\n        allCallStackFrames.length,\n        firstFrame,\n        visibleCallStackFrames.length,\n    ]);\n    return (React.createElement(React.Fragment, null,\n        firstFrame ? (React.createElement(React.Fragment, null,\n            React.createElement(\"h5\", null, \"Source\"),\n            leadingFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: \"leading-frame-\" + index + \"-\" + all, frame: frame })); }),\n            React.createElement(CodeFrame_1.CodeFrame, { stackFrame: firstFrame.originalStackFrame, codeFrame: firstFrame.originalCodeFrame }))) : undefined,\n        visibleCallStackFrames.length ? (React.createElement(React.Fragment, null,\n            React.createElement(\"h5\", null, \"Call Stack\"),\n            visibleCallStackFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: \"call-stack-\" + index + \"-\" + all, frame: frame })); }))) : undefined,\n        canShowMore ? (React.createElement(React.Fragment, null,\n            React.createElement(\"button\", { tabIndex: 10, \"data-nextjs-data-runtime-error-collapsed-action\": true, type: \"button\", onClick: toggleAll },\n                all ? 'Hide' : 'Show',\n                \" collapsed frames\"))) : undefined));\n};\nexports.RuntimeError = RuntimeError;\nexports.styles = (0, noop_template_1.noop)(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n  button[data-nextjs-data-runtime-error-collapsed-action] {\\n    background: none;\\n    border: none;\\n    padding: 0;\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-bigger);\\n    color: var(--color-accents-3);\\n  }\\n\\n  [data-nextjs-call-stack-frame]:not(:last-child) {\\n    margin-bottom: var(--size-gap-double);\\n  }\\n\\n  [data-nextjs-call-stack-frame] > h6 {\\n    margin-top: 0;\\n    margin-bottom: var(--size-gap);\\n    font-family: var(--font-stack-monospace);\\n    color: #222;\\n  }\\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\\n    color: #666;\\n  }\\n  [data-nextjs-call-stack-frame] > div {\\n    display: flex;\\n    align-items: center;\\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\\n    font-size: var(--size-font-small);\\n    color: #999;\\n  }\\n  [data-nextjs-call-stack-frame] > div > svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n\\n    display: none;\\n  }\\n\\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\\n    cursor: pointer;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\\n    display: unset;\\n  }\\n\"], [\"\\n  button[data-nextjs-data-runtime-error-collapsed-action] {\\n    background: none;\\n    border: none;\\n    padding: 0;\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-bigger);\\n    color: var(--color-accents-3);\\n  }\\n\\n  [data-nextjs-call-stack-frame]:not(:last-child) {\\n    margin-bottom: var(--size-gap-double);\\n  }\\n\\n  [data-nextjs-call-stack-frame] > h6 {\\n    margin-top: 0;\\n    margin-bottom: var(--size-gap);\\n    font-family: var(--font-stack-monospace);\\n    color: #222;\\n  }\\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\\n    color: #666;\\n  }\\n  [data-nextjs-call-stack-frame] > div {\\n    display: flex;\\n    align-items: center;\\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\\n    font-size: var(--size-font-small);\\n    color: #999;\\n  }\\n  [data-nextjs-call-stack-frame] > div > svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n\\n    display: none;\\n  }\\n\\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\\n    cursor: pointer;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\\n    display: unset;\\n  }\\n\"])));\nvar templateObject_1;\n//# sourceMappingURL=RuntimeError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CLEdBQUcsY0FBYztBQUNyQyx5QkFBeUIsbUJBQU8sQ0FBQyw0Q0FBTztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxrSEFBeUI7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsOEdBQTBCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLDBHQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFrQztBQUN0RCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLHlDQUF5QyxzQ0FBc0M7QUFDL0Usb0NBQW9DLHVEQUF1RDtBQUMzRixxQ0FBcUMsNk1BQTZNO0FBQ2xQO0FBQ0EseUNBQXlDLG9LQUFvSztBQUM3TSw4Q0FBOEMsK0RBQStEO0FBQzdHLGtEQUFrRCwwQkFBMEI7QUFDNUUsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDLEtBQUs7QUFDTCxvREFBb0QsOENBQThDLDJCQUEyQixJQUFJO0FBQ2pJLHlEQUF5RCwyREFBMkQ7QUFDcEgsNkRBQTZELGdEQUFnRCwyQkFBMkIsSUFBSTtBQUM1STtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw4Q0FBOEMseURBQXlELEtBQUs7QUFDcEsseURBQXlELG9GQUFvRjtBQUM3STtBQUNBO0FBQ0EsaUVBQWlFLDhDQUE4QyxzREFBc0QsS0FBSztBQUMxSztBQUNBLDRDQUE0QywyR0FBMkc7QUFDdko7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGNBQWMseUpBQXlKLHVCQUF1QixtQkFBbUIsaUJBQWlCLHdDQUF3QywyQ0FBMkMsb0NBQW9DLEtBQUssdURBQXVELDRDQUE0QyxLQUFLLDJDQUEyQyxvQkFBb0IscUNBQXFDLCtDQUErQyxrQkFBa0IsS0FBSyw2RUFBNkUsa0JBQWtCLEtBQUssMENBQTBDLG9CQUFvQiwwQkFBMEIsaUVBQWlFLHdDQUF3QyxrQkFBa0IsS0FBSyxnREFBZ0Qsa0JBQWtCLHFDQUFxQyxtQ0FBbUMsc0JBQXNCLEtBQUssNkRBQTZELHNCQUFzQixLQUFLLGlFQUFpRSx3Q0FBd0MsS0FBSyxpRUFBaUUscUJBQXFCLEtBQUsscUVBQXFFLHVCQUF1QixtQkFBbUIsaUJBQWlCLHdDQUF3QywyQ0FBMkMsb0NBQW9DLEtBQUssdURBQXVELDRDQUE0QyxLQUFLLDJDQUEyQyxvQkFBb0IscUNBQXFDLCtDQUErQyxrQkFBa0IsS0FBSyw2RUFBNkUsa0JBQWtCLEtBQUssMENBQTBDLG9CQUFvQiwwQkFBMEIsaUVBQWlFLHdDQUF3QyxrQkFBa0IsS0FBSyxnREFBZ0Qsa0JBQWtCLHFDQUFxQyxtQ0FBbUMsc0JBQXNCLEtBQUssNkRBQTZELHNCQUFzQixLQUFLLGlFQUFpRSx3Q0FBd0MsS0FBSyxpRUFBaUUscUJBQXFCLEtBQUs7QUFDbG9GO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb250YWluZXIvUnVudGltZUVycm9yLmpzP2MyMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5SdW50aW1lRXJyb3IgPSBleHBvcnRzLnN0eWxlcyA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xudmFyIENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoX2EpIHtcbiAgICAvLyBUT0RPOiBhYmlsaXR5IHRvIGV4cGFuZCByZXNvbHZlZCBmcmFtZXNcbiAgICAvLyBUT0RPOiByZW5kZXIgZXJyb3Igb3IgZXh0ZXJuYWwgaW5kaWNhdG9yXG4gICAgdmFyIF9iO1xuICAgIHZhciBmcmFtZSA9IF9hLmZyYW1lO1xuICAgIHZhciBmID0gKF9iID0gZnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmcmFtZS5zb3VyY2VTdGFja0ZyYW1lO1xuICAgIHZhciBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcbiAgICB2YXIgb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWhhc1NvdXJjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGYpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCAoKF9hID0gZltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZlxuICAgICAgICAgICAgLmZldGNoKChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnKSArIFwiL19fbmV4dGpzX2xhdW5jaC1lZGl0b3I/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGhlcmUgd2FzIGFuIGlzc3VlIG9wZW5pbmcgdGhpcyBjb2RlIGluIHlvdXIgZWRpdG9yLicpO1xuICAgICAgICB9KTtcbiAgICB9LCBbaGFzU291cmNlLCBmXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXCI6IHRydWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg2XCIsIHsgXCJkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZFwiOiBCb29sZWFuKGZyYW1lLmV4cGFuZGVkKSB9LCBmLm1ldGhvZE5hbWUpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLWhhcy1zb3VyY2VcIjogaGFzU291cmNlID8gJ3RydWUnIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaGFzU291cmNlID8gMTAgOiB1bmRlZmluZWQsIHJvbGU6IGhhc1NvdXJjZSA/ICdsaW5rJyA6IHVuZGVmaW5lZCwgb25DbGljazogb3BlbiwgdGl0bGU6IGhhc1NvdXJjZSA/ICdDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yJyA6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgKDAsIHN0YWNrX2ZyYW1lXzEuZ2V0RnJhbWVTb3VyY2UpKGYpKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IHBvaW50czogXCIxNSAzIDIxIDMgMjEgOVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTBcIiwgeTE6IFwiMTRcIiwgeDI6IFwiMjFcIiwgeTI6IFwiM1wiIH0pKSkpKTtcbn07XG52YXIgUnVudGltZUVycm9yID0gZnVuY3Rpb24gUnVudGltZUVycm9yKF9hKSB7XG4gICAgdmFyIGVycm9yID0gX2EuZXJyb3I7XG4gICAgdmFyIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLmZyYW1lcy5maW5kSW5kZXgoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZXhwYW5kZWQgJiZcbiAgICAgICAgICAgICAgICBCb29sZWFuKGVudHJ5Lm9yaWdpbmFsQ29kZUZyYW1lKSAmJlxuICAgICAgICAgICAgICAgIEJvb2xlYW4oZW50cnkub3JpZ2luYWxTdGFja0ZyYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2Vycm9yLmZyYW1lc10pO1xuICAgIHZhciBmaXJzdEZyYW1lID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IGVycm9yLmZyYW1lc1tmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XG4gICAgdmFyIGFsbExlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggPCAwXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IGVycm9yLmZyYW1lcy5zbGljZSgwLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4KTtcbiAgICB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKGZpcnN0RnJhbWUgPT0gbnVsbCksIDIpLCBhbGwgPSBfYlswXSwgc2V0QWxsID0gX2JbMV07XG4gICAgdmFyIHRvZ2dsZUFsbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0QWxsKGZ1bmN0aW9uICh2KSB7IHJldHVybiAhdjsgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBsZWFkaW5nRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxMZWFkaW5nRnJhbWVzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5leHBhbmRlZCB8fCBhbGw7IH0pOyB9LCBbYWxsLCBhbGxMZWFkaW5nRnJhbWVzXSk7XG4gICAgdmFyIGFsbENhbGxTdGFja0ZyYW1lcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IuZnJhbWVzLnNsaWNlKGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggKyAxKTsgfSwgW2Vycm9yLmZyYW1lcywgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleF0pO1xuICAgIHZhciB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxDYWxsU3RhY2tGcmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmV4cGFuZGVkIHx8IGFsbDsgfSk7IH0sIFthbGwsIGFsbENhbGxTdGFja0ZyYW1lc10pO1xuICAgIHZhciBjYW5TaG93TW9yZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGFsbENhbGxTdGFja0ZyYW1lcy5sZW5ndGggIT09IHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAoYWxsICYmIGZpcnN0RnJhbWUgIT0gbnVsbCkpO1xuICAgIH0sIFtcbiAgICAgICAgYWxsLFxuICAgICAgICBhbGxDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxuICAgICAgICBmaXJzdEZyYW1lLFxuICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGZpcnN0RnJhbWUgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNVwiLCBudWxsLCBcIlNvdXJjZVwiKSxcbiAgICAgICAgICAgIGxlYWRpbmdGcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTdGFja0ZyYW1lLCB7IGtleTogXCJsZWFkaW5nLWZyYW1lLVwiICsgaW5kZXggKyBcIi1cIiArIGFsbCwgZnJhbWU6IGZyYW1lIH0pKTsgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvZGVGcmFtZV8xLkNvZGVGcmFtZSwgeyBzdGFja0ZyYW1lOiBmaXJzdEZyYW1lLm9yaWdpbmFsU3RhY2tGcmFtZSwgY29kZUZyYW1lOiBmaXJzdEZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lIH0pKSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJDYWxsIFN0YWNrXCIpLFxuICAgICAgICAgICAgdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFN0YWNrRnJhbWUsIHsga2V5OiBcImNhbGwtc3RhY2stXCIgKyBpbmRleCArIFwiLVwiICsgYWxsLCBmcmFtZTogZnJhbWUgfSkpOyB9KSkpIDogdW5kZWZpbmVkLFxuICAgICAgICBjYW5TaG93TW9yZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHRhYkluZGV4OiAxMCwgXCJkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvblwiOiB0cnVlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiB0b2dnbGVBbGwgfSxcbiAgICAgICAgICAgICAgICBhbGwgPyAnSGlkZScgOiAnU2hvdycsXG4gICAgICAgICAgICAgICAgXCIgY29sbGFwc2VkIGZyYW1lc1wiKSkpIDogdW5kZWZpbmVkKSk7XG59O1xuZXhwb3J0cy5SdW50aW1lRXJyb3IgPSBSdW50aW1lRXJyb3I7XG5leHBvcnRzLnN0eWxlcyA9ICgwLCBub29wX3RlbXBsYXRlXzEubm9vcCkodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdLCBbXCJcXG4gIGJ1dHRvbltkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvbl0ge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWdnZXIpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYWNjZW50cy0zKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXTpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2IHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBjb2xvcjogIzIyMjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2W2RhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkPSdmYWxzZSddIHtcXG4gICAgY29sb3I6ICM2NjY7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLWxlZnQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2ID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwKTtcXG5cXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV06aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSA+IHN2ZyB7XFxuICAgIGRpc3BsYXk6IHVuc2V0O1xcbiAgfVxcblwiXSkpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UnVudGltZUVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = connect;\nvar _client = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\");\nvar _stripAnsi = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\"));\nvar _websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _formatWebpackMessages = _interopRequireDefault(__webpack_require__(/*! ./format-webpack-messages */ \"./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// This alternative WebpackDevServer combines the functionality of:\n// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js\n// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js\n// It only supports their simplest configuration (hot updates on same server).\n// It makes some opinionated choices on top, like adding a syntax error overlay\n// that looks similar to our console output. The error overlay is inspired by:\n// https://github.com/glenjamin/webpack-hot-middleware\nvar hadRuntimeError = false;\nvar customHmrEventHandler;\nfunction connect() {\n    (0, _client).register();\n    (0, _websocket).addMessageListener(function(event) {\n        if (event.data.indexOf('action') === -1) return;\n        try {\n            processMessage(event);\n        } catch (ex) {\n            console.warn('Invalid HMR message: ' + event.data + '\\n', ex);\n        }\n    });\n    return {\n        subscribeToHmrEvent: function(handler) {\n            customHmrEventHandler = handler;\n        },\n        onUnrecoverableError: function() {\n            hadRuntimeError = true;\n        }\n    };\n}\n// Remember some state related to hot module replacement.\nvar isFirstCompilation = true;\nvar mostRecentCompilationHash = null;\nvar hasCompileErrors = false;\nfunction clearOutdatedErrors() {\n    // Clean up outdated compile errors, if any.\n    if (typeof console !== 'undefined' && typeof console.clear === 'function') {\n        if (hasCompileErrors) {\n            console.clear();\n        }\n    }\n}\n// Successful compilation.\nfunction handleSuccess() {\n    clearOutdatedErrors();\n    var isHotUpdate = !isFirstCompilation || window.__NEXT_DATA__.page !== '/_error' && isUpdateAvailable();\n    isFirstCompilation = false;\n    hasCompileErrors = false;\n    // Attempt to apply hot updates or reload.\n    if (isHotUpdate) {\n        tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {\n            // Only dismiss it when we're sure it's a hot update.\n            // Otherwise it would flicker right before the reload.\n            onFastRefresh(hasUpdates);\n        });\n    }\n}\n// Compilation with warnings (e.g. ESLint).\nfunction handleWarnings(warnings) {\n    var printWarnings = function printWarnings() {\n        // Print warnings to the console.\n        var formatted = (0, _formatWebpackMessages).default({\n            warnings: warnings,\n            errors: []\n        });\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            for(var i = 0; i < formatted.warnings.length; i++){\n                if (i === 5) {\n                    console.warn('There were more warnings in other files.\\n' + 'You can find a complete log in the terminal.');\n                    break;\n                }\n                console.warn((0, _stripAnsi).default(formatted.warnings[i]));\n            }\n        }\n    };\n    clearOutdatedErrors();\n    var isHotUpdate = !isFirstCompilation;\n    isFirstCompilation = false;\n    hasCompileErrors = false;\n    printWarnings();\n    // Attempt to apply hot updates or reload.\n    if (isHotUpdate) {\n        tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {\n            // Only dismiss it when we're sure it's a hot update.\n            // Otherwise it would flicker right before the reload.\n            onFastRefresh(hasUpdates);\n        });\n    }\n}\n// Compilation with errors (e.g. syntax error or missing modules).\nfunction handleErrors(errors) {\n    clearOutdatedErrors();\n    isFirstCompilation = false;\n    hasCompileErrors = true;\n    // \"Massage\" webpack messages.\n    var formatted = (0, _formatWebpackMessages).default({\n        errors: errors,\n        warnings: []\n    });\n    // Only show the first error.\n    (0, _client).onBuildError(formatted.errors[0]);\n    // Also log them to the console.\n    if (typeof console !== 'undefined' && typeof console.error === 'function') {\n        for(var i = 0; i < formatted.errors.length; i++){\n            console.error((0, _stripAnsi).default(formatted.errors[i]));\n        }\n    }\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (undefined) {\n        if (self.__NEXT_HMR_CB) {\n            self.__NEXT_HMR_CB(formatted.errors[0]);\n            self.__NEXT_HMR_CB = null;\n        }\n    }\n}\nvar startLatency = undefined;\nfunction onFastRefresh(hasUpdates) {\n    (0, _client).onBuildOk();\n    if (hasUpdates) {\n        (0, _client).onRefresh();\n    }\n    if (startLatency) {\n        var latency = Date.now() - startLatency;\n        console.log(\"[Fast Refresh] done in \".concat(latency, \"ms\"));\n        if (self.__NEXT_HMR_LATENCY_CB) {\n            self.__NEXT_HMR_LATENCY_CB(latency);\n        }\n    }\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n// Handle messages from the server.\nfunction processMessage(e) {\n    var obj = JSON.parse(e.data);\n    switch(obj.action){\n        case 'building':\n            {\n                startLatency = Date.now();\n                console.log('[Fast Refresh] rebuilding');\n                break;\n            }\n        case 'built':\n        case 'sync':\n            {\n                if (obj.hash) {\n                    handleAvailableHash(obj.hash);\n                }\n                var errors = obj.errors, warnings = obj.warnings;\n                var hasErrors = Boolean(errors && errors.length);\n                if (hasErrors) {\n                    return handleErrors(errors);\n                }\n                var hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    return handleWarnings(warnings);\n                }\n                return handleSuccess();\n            }\n        default:\n            {\n                if (customHmrEventHandler) {\n                    customHmrEventHandler(obj);\n                    break;\n                }\n                break;\n            }\n    }\n}\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    return mostRecentCompilationHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === 'idle';\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === 'idle') {\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        module.hot.addStatusHandler(handler);\n    }\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdates(onHotUpdateSuccess) {\n    var handleApplyUpdates = function handleApplyUpdates(err, updatedModules) {\n        if (err || hadRuntimeError || !updatedModules) {\n            if (err) {\n                console.warn('[Fast Refresh] performing full reload\\n\\n' + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' + 'Fast Refresh requires at least one parent function component in your React tree.');\n            } else if (hadRuntimeError) {\n                console.warn('[Fast Refresh] performing full reload because your application had an unrecoverable error');\n            }\n            window.location.reload();\n            return;\n        }\n        var hasUpdates = Boolean(updatedModules.length);\n        if (typeof onHotUpdateSuccess === 'function') {\n            // Maybe we want to do something.\n            onHotUpdateSuccess(hasUpdates);\n        }\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            tryApplyUpdates(hasUpdates ? _client.onBuildOk : onHotUpdateSuccess);\n        } else {\n            (0, _client).onBuildOk();\n            if (undefined) {\n                afterApplyUpdates(function() {\n                    if (self.__NEXT_HMR_CB) {\n                        self.__NEXT_HMR_CB();\n                        self.__NEXT_HMR_CB = null;\n                    }\n                });\n            }\n        }\n    };\n    if (false) {}\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        (0, _client).onBuildOk();\n        return;\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    module.hot.check(/* autoApply */ true).then(function(updatedModules) {\n        handleApplyUpdates(null, updatedModules);\n    }, function(err) {\n        handleApplyUpdates(err, null);\n    });\n} //# sourceMappingURL=hot-dev-client.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdHLE9BQU87QUFDekIsR0FBRyxDQUFDQyxPQUFPLEdBQUdDLG1CQUFPLENBQUMsZ0dBQW9DO0FBQzFELEdBQUcsQ0FBQ0MsVUFBVSxHQUFHQyxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyw0RkFBK0I7QUFDL0UsR0FBRyxDQUFDRyxVQUFVLEdBQUdILG1CQUFPLENBQUMsbUZBQWE7QUFDdEMsR0FBRyxDQUFDSSxzQkFBc0IsR0FBR0Ysc0JBQXNCLENBQUNGLG1CQUFPLENBQUMsK0dBQTJCO1NBQzlFRSxzQkFBc0IsQ0FBQ0csR0FBRyxFQUFFLENBQUM7SUFDbEMsTUFBTSxDQUFDQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHRCxHQUFHLEdBQUcsQ0FBQztRQUNsQ1IsT0FBTyxFQUFFUSxHQUFHO0lBQ2hCLENBQUM7QUFDTCxDQUFDO0FBQ0QsRUFBbUU7QUFDbkUsRUFBK0U7QUFDL0UsRUFBc0U7QUFDdEUsRUFBOEU7QUFDOUUsRUFBK0U7QUFDL0UsRUFBOEU7QUFDOUUsRUFBc0Q7QUFDdEQsR0FBRyxDQUFDRSxlQUFlLEdBQUcsS0FBSztBQUMzQixHQUFHLENBQUNDLHFCQUFxQjtTQUNoQlYsT0FBTyxHQUFHLENBQUM7S0FDZixDQUFDLEVBQUVDLE9BQU8sRUFBRVUsUUFBUTtLQUNwQixDQUFDLEVBQUVOLFVBQVUsRUFBRU8sa0JBQWtCLENBQUMsUUFBUSxDQUFQQyxLQUFLLEVBQUcsQ0FBQztRQUN6QyxFQUFFLEVBQUVBLEtBQUssQ0FBQ0MsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBUSxjQUFPLENBQUMsRUFBRSxNQUFNO1FBQy9DLEdBQUcsQ0FBQyxDQUFDO1lBQ0RDLGNBQWMsQ0FBQ0gsS0FBSztRQUN4QixDQUFDLENBQUMsS0FBSyxFQUFFSSxFQUFFLEVBQUUsQ0FBQztZQUNWQyxPQUFPLENBQUNDLElBQUksQ0FBQyxDQUF1Qix5QkFBR04sS0FBSyxDQUFDQyxJQUFJLEdBQUcsQ0FBSSxLQUFFRyxFQUFFO1FBQ2hFLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxDQUFDLENBQUM7UUFDSkcsbUJBQW1CLEVBQW5CQSxRQUFRLENBQWFDLE9BQU8sRUFBRSxDQUFDO1lBQzNCWCxxQkFBcUIsR0FBR1csT0FBTztRQUNuQyxDQUFDO1FBQ0RDLG9CQUFvQixFQUFwQkEsUUFBUSxHQUFnQixDQUFDO1lBQ3JCYixlQUFlLEdBQUcsSUFBSTtRQUMxQixDQUFDO0lBQ0wsQ0FBQztBQUNMLENBQUM7QUFDRCxFQUF5RDtBQUN6RCxHQUFHLENBQUNjLGtCQUFrQixHQUFHLElBQUk7QUFDN0IsR0FBRyxDQUFDQyx5QkFBeUIsR0FBRyxJQUFJO0FBQ3BDLEdBQUcsQ0FBQ0MsZ0JBQWdCLEdBQUcsS0FBSztTQUNuQkMsbUJBQW1CLEdBQUcsQ0FBQztJQUM1QixFQUE0QztJQUM1QyxFQUFFLEVBQUUsTUFBTSxDQUFDUixPQUFPLEtBQUssQ0FBVyxjQUFJLE1BQU0sQ0FBQ0EsT0FBTyxDQUFDUyxLQUFLLEtBQUssQ0FBVSxXQUFFLENBQUM7UUFDeEUsRUFBRSxFQUFFRixnQkFBZ0IsRUFBRSxDQUFDO1lBQ25CUCxPQUFPLENBQUNTLEtBQUs7UUFDakIsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDO0FBQ0QsRUFBMEI7U0FDakJDLGFBQWEsR0FBRyxDQUFDO0lBQ3RCRixtQkFBbUI7SUFDbkIsR0FBSyxDQUFDRyxXQUFXLElBQUlOLGtCQUFrQixJQUFJTyxNQUFNLENBQUNDLGFBQWEsQ0FBQ0MsSUFBSSxLQUFLLENBQVMsWUFBSUMsaUJBQWlCO0lBQ3ZHVixrQkFBa0IsR0FBRyxLQUFLO0lBQzFCRSxnQkFBZ0IsR0FBRyxLQUFLO0lBQ3hCLEVBQTBDO0lBQzFDLEVBQUUsRUFBRUksV0FBVyxFQUFFLENBQUM7UUFDZEssZUFBZSxDQUFDLFFBQVEsQ0FBQ0MscUJBQXFCLENBQUNDLFVBQVUsRUFBRSxDQUFDO1lBQ3hELEVBQXFEO1lBQ3JELEVBQXNEO1lBQ3REQyxhQUFhLENBQUNELFVBQVU7UUFDNUIsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDO0FBQ0QsRUFBMkM7U0FDbENFLGNBQWMsQ0FBQ0MsUUFBUSxFQUFFLENBQUM7UUFLdEJDLGFBQWEsR0FBdEIsUUFBUSxDQUFDQSxhQUFhLEdBQUcsQ0FBQztRQUN0QixFQUFpQztRQUNqQyxHQUFLLENBQUNDLFNBQVMsSUFBSSxDQUFDLEVBQUVuQyxzQkFBc0IsRUFBRVAsT0FBTyxDQUFDLENBQUM7WUFDbkR3QyxRQUFRLEVBQUVBLFFBQVE7WUFDbEJHLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDZCxDQUFDO1FBQ0QsRUFBRSxFQUFFLE1BQU0sQ0FBQ3hCLE9BQU8sS0FBSyxDQUFXLGNBQUksTUFBTSxDQUFDQSxPQUFPLENBQUNDLElBQUksS0FBSyxDQUFVLFdBQUUsQ0FBQztZQUN2RSxHQUFHLENBQUMsR0FBRyxDQUFDd0IsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRixTQUFTLENBQUNGLFFBQVEsQ0FBQ0ssTUFBTSxFQUFFRCxDQUFDLEdBQUcsQ0FBQztnQkFDL0MsRUFBRSxFQUFFQSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7b0JBQ1Z6QixPQUFPLENBQUNDLElBQUksQ0FBQyxDQUE0Qyw4Q0FBRyxDQUE4QztvQkFDMUcsS0FBSztnQkFDVCxDQUFDO2dCQUNERCxPQUFPLENBQUNDLElBQUksRUFBRSxDQUFDLEVBQUVoQixVQUFVLEVBQUVKLE9BQU8sQ0FBQzBDLFNBQVMsQ0FBQ0YsUUFBUSxDQUFDSSxDQUFDO1lBQzdELENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQztJQW5CRGpCLG1CQUFtQjtJQUNuQixHQUFLLENBQUNHLFdBQVcsSUFBSU4sa0JBQWtCO0lBQ3ZDQSxrQkFBa0IsR0FBRyxLQUFLO0lBQzFCRSxnQkFBZ0IsR0FBRyxLQUFLO0lBaUJ4QmUsYUFBYTtJQUNiLEVBQTBDO0lBQzFDLEVBQUUsRUFBRVgsV0FBVyxFQUFFLENBQUM7UUFDZEssZUFBZSxDQUFDLFFBQVEsQ0FBQ0MscUJBQXFCLENBQUNDLFVBQVUsRUFBRSxDQUFDO1lBQ3hELEVBQXFEO1lBQ3JELEVBQXNEO1lBQ3REQyxhQUFhLENBQUNELFVBQVU7UUFDNUIsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDO0FBQ0QsRUFBa0U7U0FDekRTLFlBQVksQ0FBQ0gsTUFBTSxFQUFFLENBQUM7SUFDM0JoQixtQkFBbUI7SUFDbkJILGtCQUFrQixHQUFHLEtBQUs7SUFDMUJFLGdCQUFnQixHQUFHLElBQUk7SUFDdkIsRUFBOEI7SUFDOUIsR0FBRyxDQUFDZ0IsU0FBUyxJQUFJLENBQUMsRUFBRW5DLHNCQUFzQixFQUFFUCxPQUFPLENBQUMsQ0FBQztRQUNqRDJDLE1BQU0sRUFBRUEsTUFBTTtRQUNkSCxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ2hCLENBQUM7SUFDRCxFQUE2QjtLQUM1QixDQUFDLEVBQUV0QyxPQUFPLEVBQUU2QyxZQUFZLENBQUNMLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLENBQUM7SUFDNUMsRUFBZ0M7SUFDaEMsRUFBRSxFQUFFLE1BQU0sQ0FBQ3hCLE9BQU8sS0FBSyxDQUFXLGNBQUksTUFBTSxDQUFDQSxPQUFPLENBQUM2QixLQUFLLEtBQUssQ0FBVSxXQUFFLENBQUM7UUFDeEUsR0FBRyxDQUFDLEdBQUcsQ0FBQ0osQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRixTQUFTLENBQUNDLE1BQU0sQ0FBQ0UsTUFBTSxFQUFFRCxDQUFDLEdBQUcsQ0FBQztZQUM3Q3pCLE9BQU8sQ0FBQzZCLEtBQUssRUFBRSxDQUFDLEVBQUU1QyxVQUFVLEVBQUVKLE9BQU8sQ0FBQzBDLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDQyxDQUFDO1FBQzVELENBQUM7SUFDTCxDQUFDO0lBQ0QsRUFBZ0M7SUFDaEMsRUFBMEM7SUFDMUMsRUFBRSxFQUFFSyxTQUE0QixFQUFFLENBQUM7UUFDL0IsRUFBRSxFQUFFRyxJQUFJLENBQUNDLGFBQWEsRUFBRSxDQUFDO1lBQ3JCRCxJQUFJLENBQUNDLGFBQWEsQ0FBQ1gsU0FBUyxDQUFDQyxNQUFNLENBQUMsQ0FBQztZQUNyQ1MsSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSTtRQUM3QixDQUFDO0lBQ0wsQ0FBQztBQUNMLENBQUM7QUFDRCxHQUFHLENBQUNDLFlBQVksR0FBR0MsU0FBUztTQUNuQmpCLGFBQWEsQ0FBQ0QsVUFBVSxFQUFFLENBQUM7S0FDL0IsQ0FBQyxFQUFFbkMsT0FBTyxFQUFFc0QsU0FBUztJQUN0QixFQUFFLEVBQUVuQixVQUFVLEVBQUUsQ0FBQztTQUNaLENBQUMsRUFBRW5DLE9BQU8sRUFBRXVELFNBQVM7SUFDMUIsQ0FBQztJQUNELEVBQUUsRUFBRUgsWUFBWSxFQUFFLENBQUM7UUFDZixHQUFLLENBQUNJLE9BQU8sR0FBR0MsSUFBSSxDQUFDQyxHQUFHLEtBQUtOLFlBQVk7UUFDekNuQyxPQUFPLENBQUMwQyxHQUFHLENBQUUsQ0FBdUIseUJBQVUsTUFBRSxDQUFWSCxPQUFPLEVBQUMsQ0FBRTtRQUNoRCxFQUFFLEVBQUVOLElBQUksQ0FBQ1UscUJBQXFCLEVBQUUsQ0FBQztZQUM3QlYsSUFBSSxDQUFDVSxxQkFBcUIsQ0FBQ0osT0FBTztRQUN0QyxDQUFDO0lBQ0wsQ0FBQztBQUNMLENBQUM7QUFDRCxFQUFrRDtTQUN6Q0ssbUJBQW1CLENBQUNDLElBQUksRUFBRSxDQUFDO0lBQ2hDLEVBQXNDO0lBQ3RDdkMseUJBQXlCLEdBQUd1QyxJQUFJO0FBQ3BDLENBQUM7QUFDRCxFQUFtQztTQUMxQi9DLGNBQWMsQ0FBQ2dELENBQUMsRUFBRSxDQUFDO0lBQ3hCLEdBQUssQ0FBQ3pELEdBQUcsR0FBRzBELElBQUksQ0FBQ0MsS0FBSyxDQUFDRixDQUFDLENBQUNsRCxJQUFJO0lBQzdCLE1BQU0sQ0FBQ1AsR0FBRyxDQUFDNEQsTUFBTTtRQUNiLElBQUksQ0FBQyxDQUFVO1lBQ1gsQ0FBQztnQkFDR2QsWUFBWSxHQUFHSyxJQUFJLENBQUNDLEdBQUc7Z0JBQ3ZCekMsT0FBTyxDQUFDMEMsR0FBRyxDQUFDLENBQTJCO2dCQUN2QyxLQUFLO1lBQ1QsQ0FBQztRQUNMLElBQUksQ0FBQyxDQUFPO1FBQ1osSUFBSSxDQUFDLENBQU07WUFDUCxDQUFDO2dCQUNHLEVBQUUsRUFBRXJELEdBQUcsQ0FBQ3dELElBQUksRUFBRSxDQUFDO29CQUNYRCxtQkFBbUIsQ0FBQ3ZELEdBQUcsQ0FBQ3dELElBQUk7Z0JBQ2hDLENBQUM7Z0JBQ0QsR0FBSyxDQUFHckIsTUFBTSxHQUFpQm5DLEdBQUcsQ0FBMUJtQyxNQUFNLEVBQUdILFFBQVEsR0FBTWhDLEdBQUcsQ0FBakJnQyxRQUFRO2dCQUN6QixHQUFLLENBQUM2QixTQUFTLEdBQUdDLE9BQU8sQ0FBQzNCLE1BQU0sSUFBSUEsTUFBTSxDQUFDRSxNQUFNO2dCQUNqRCxFQUFFLEVBQUV3QixTQUFTLEVBQUUsQ0FBQztvQkFDWixNQUFNLENBQUN2QixZQUFZLENBQUNILE1BQU07Z0JBQzlCLENBQUM7Z0JBQ0QsR0FBSyxDQUFDNEIsV0FBVyxHQUFHRCxPQUFPLENBQUM5QixRQUFRLElBQUlBLFFBQVEsQ0FBQ0ssTUFBTTtnQkFDdkQsRUFBRSxFQUFFMEIsV0FBVyxFQUFFLENBQUM7b0JBQ2QsTUFBTSxDQUFDaEMsY0FBYyxDQUFDQyxRQUFRO2dCQUNsQyxDQUFDO2dCQUNELE1BQU0sQ0FBQ1gsYUFBYTtZQUN4QixDQUFDOztZQUVELENBQUM7Z0JBQ0csRUFBRSxFQUFFbEIscUJBQXFCLEVBQUUsQ0FBQztvQkFDeEJBLHFCQUFxQixDQUFDSCxHQUFHO29CQUN6QixLQUFLO2dCQUNULENBQUM7Z0JBQ0QsS0FBSztZQUNULENBQUM7O0FBRWIsQ0FBQztBQUNELEVBQW1EO1NBQzFDMEIsaUJBQWlCLEdBQUcsQ0FBQztJQUMxQixFQUE4Qiw2QkFBQyxFQUEyRDtJQUMxRixFQUE4QztJQUM5QyxNQUFNLENBQUNULHlCQUF5QixLQUFLK0MsdUJBQWdCO0FBQ3pELENBQUM7QUFDRCxFQUE2QztTQUNwQ0MsZUFBZSxHQUFHLENBQUM7SUFDeEIsTUFBTSxDQUFDQyxVQUFVLENBQUNFLE1BQU0sT0FBTyxDQUFNO0FBQ3pDLENBQUM7U0FDUUMsaUJBQWlCLENBQUNDLEVBQUUsRUFBRSxDQUFDO0lBQzVCLEVBQUUsRUFBRUwsZUFBZSxJQUFJLENBQUM7UUFDcEJLLEVBQUU7SUFDTixDQUFDLE1BQU0sQ0FBQztpQkFDS3hELE9BQU8sQ0FBQ3NELE1BQU0sRUFBRSxDQUFDO1lBQ3RCLEVBQUUsRUFBRUEsTUFBTSxLQUFLLENBQU0sT0FBRSxDQUFDO2dCQUNwQkYsVUFBVSxDQUFDSyxtQkFBbUIsQ0FBQ3pELE9BQU87Z0JBQ3RDd0QsRUFBRTtZQUNOLENBQUM7UUFDTCxDQUFDO1FBQ0RKLFVBQVUsQ0FBQ00sZ0JBQWdCLENBQUMxRCxPQUFPO0lBQ3ZDLENBQUM7QUFDTCxDQUFDO0FBQ0QsRUFBaUU7U0FDeERhLGVBQWUsQ0FBQzhDLGtCQUFrQixFQUFFLENBQUM7UUFXakNDLGtCQUFrQixHQUEzQixRQUFRLENBQUNBLGtCQUFrQixDQUFDQyxHQUFHLEVBQUVDLGNBQWMsRUFBRSxDQUFDO1FBQzlDLEVBQUUsRUFBRUQsR0FBRyxJQUFJekUsZUFBZSxLQUFLMEUsY0FBYyxFQUFFLENBQUM7WUFDNUMsRUFBRSxFQUFFRCxHQUFHLEVBQUUsQ0FBQztnQkFDTmhFLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLENBQTJDLDZDQUFHLENBQWdJLGtJQUFHLENBQWtJLG9JQUFHLENBQTRHLDhHQUFHLENBQTJILDZIQUFHLENBQWtGO1lBQ3RvQixDQUFDLE1BQU0sRUFBRSxFQUFFVixlQUFlLEVBQUUsQ0FBQztnQkFDekJTLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLENBQTJGO1lBQzVHLENBQUM7WUFDRFcsTUFBTSxDQUFDc0QsUUFBUSxDQUFDQyxNQUFNO1lBQ3RCLE1BQU07UUFDVixDQUFDO1FBQ0QsR0FBSyxDQUFDakQsVUFBVSxHQUFHaUMsT0FBTyxDQUFDYyxjQUFjLENBQUN2QyxNQUFNO1FBQ2hELEVBQUUsRUFBRSxNQUFNLENBQUNvQyxrQkFBa0IsS0FBSyxDQUFVLFdBQUUsQ0FBQztZQUMzQyxFQUFpQztZQUNqQ0Esa0JBQWtCLENBQUM1QyxVQUFVO1FBQ2pDLENBQUM7UUFDRCxFQUFFLEVBQUVILGlCQUFpQixJQUFJLENBQUM7WUFDdEIsRUFBK0Q7WUFDL0RDLGVBQWUsQ0FBQ0UsVUFBVSxHQUFHbkMsT0FBTyxDQUFDc0QsU0FBUyxHQUFHeUIsa0JBQWtCO1FBQ3ZFLENBQUMsTUFBTSxDQUFDO2FBQ0gsQ0FBQyxFQUFFL0UsT0FBTyxFQUFFc0QsU0FBUztZQUN0QixFQUFFLEVBQUVQLFNBQTRCLEVBQUUsQ0FBQztnQkFDL0I0QixpQkFBaUIsQ0FBQyxRQUNoQyxHQURvQyxDQUFDO29CQUNuQixFQUFFLEVBQUV6QixJQUFJLENBQUNDLGFBQWEsRUFBRSxDQUFDO3dCQUNyQkQsSUFBSSxDQUFDQyxhQUFhO3dCQUNsQkQsSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSTtvQkFDN0IsQ0FBQztnQkFDTCxDQUFDO1lBQ0wsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBdkNELEVBQUUsRUFBRSxLQUFXLEVBQUUsRUFLaEI7SUFDRCxFQUFFLEdBQUduQixpQkFBaUIsT0FBT3VDLGVBQWUsSUFBSSxDQUFDO1NBQzVDLENBQUMsRUFBRXZFLE9BQU8sRUFBRXNELFNBQVM7UUFDdEIsTUFBTTtJQUNWLENBQUM7SUErQkQsRUFBMkQ7SUFDM0RrQixVQUFVLENBQUNhLEtBQUssQ0FBQyxFQUFlLGNBQUMsSUFBSSxFQUFFQyxJQUFJLENBQUMsUUFBUSxDQUFQSixjQUFjLEVBQUcsQ0FBQztRQUMzREYsa0JBQWtCLENBQUMsSUFBSSxFQUFFRSxjQUFjO0lBQzNDLENBQUMsRUFBRSxRQUFRLENBQVBELEdBQUcsRUFBRyxDQUFDO1FBQ1BELGtCQUFrQixDQUFDQyxHQUFHLEVBQUUsSUFBSTtJQUNoQyxDQUFDO0FBQ0wsQ0FBQyxDQUV5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudC5qcz8xNjAwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29ubmVjdDtcbnZhciBfY2xpZW50ID0gcmVxdWlyZShcIkBuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9jbGllbnRcIik7XG52YXIgX3N0cmlwQW5zaSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpXCIpKTtcbnZhciBfd2Vic29ja2V0ID0gcmVxdWlyZShcIi4vd2Vic29ja2V0XCIpO1xudmFyIF9mb3JtYXRXZWJwYWNrTWVzc2FnZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbi8vIFRoaXMgYWx0ZXJuYXRpdmUgV2VicGFja0RldlNlcnZlciBjb21iaW5lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZjpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9ibG9iL3dlYnBhY2stMS9jbGllbnQvaW5kZXguanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi93ZWJwYWNrLTEvaG90L2Rldi1zZXJ2ZXIuanNcbi8vIEl0IG9ubHkgc3VwcG9ydHMgdGhlaXIgc2ltcGxlc3QgY29uZmlndXJhdGlvbiAoaG90IHVwZGF0ZXMgb24gc2FtZSBzZXJ2ZXIpLlxuLy8gSXQgbWFrZXMgc29tZSBvcGluaW9uYXRlZCBjaG9pY2VzIG9uIHRvcCwgbGlrZSBhZGRpbmcgYSBzeW50YXggZXJyb3Igb3ZlcmxheVxuLy8gdGhhdCBsb29rcyBzaW1pbGFyIHRvIG91ciBjb25zb2xlIG91dHB1dC4gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgYnk6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmVcbmxldCBoYWRSdW50aW1lRXJyb3IgPSBmYWxzZTtcbmxldCBjdXN0b21IbXJFdmVudEhhbmRsZXI7XG5mdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICgwLCBfY2xpZW50KS5yZWdpc3RlcigpO1xuICAgICgwLCBfd2Vic29ja2V0KS5hZGRNZXNzYWdlTGlzdGVuZXIoKGV2ZW50KT0+e1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdhY3Rpb24nKSA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2Nlc3NNZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBITVIgbWVzc2FnZTogJyArIGV2ZW50LmRhdGEgKyAnXFxuJywgZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlVG9IbXJFdmVudCAoaGFuZGxlcikge1xuICAgICAgICAgICAgY3VzdG9tSG1yRXZlbnRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgfSxcbiAgICAgICAgb25VbnJlY292ZXJhYmxlRXJyb3IgKCkge1xuICAgICAgICAgICAgaGFkUnVudGltZUVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBSZW1lbWJlciBzb21lIHN0YXRlIHJlbGF0ZWQgdG8gaG90IG1vZHVsZSByZXBsYWNlbWVudC5cbnZhciBpc0ZpcnN0Q29tcGlsYXRpb24gPSB0cnVlO1xudmFyIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggPSBudWxsO1xudmFyIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZTtcbmZ1bmN0aW9uIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKSB7XG4gICAgLy8gQ2xlYW4gdXAgb3V0ZGF0ZWQgY29tcGlsZSBlcnJvcnMsIGlmIGFueS5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChoYXNDb21waWxlRXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgICBjbGVhck91dGRhdGVkRXJyb3JzKCk7XG4gICAgY29uc3QgaXNIb3RVcGRhdGUgPSAhaXNGaXJzdENvbXBpbGF0aW9uIHx8IHdpbmRvdy5fX05FWFRfREFUQV9fLnBhZ2UgIT09ICcvX2Vycm9yJyAmJiBpc1VwZGF0ZUF2YWlsYWJsZSgpO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZTtcbiAgICAvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbiAgICBpZiAoaXNIb3RVcGRhdGUpIHtcbiAgICAgICAgdHJ5QXBwbHlVcGRhdGVzKGZ1bmN0aW9uIG9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZShoYXNVcGRhdGVzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRpc21pc3MgaXQgd2hlbiB3ZSdyZSBzdXJlIGl0J3MgYSBob3QgdXBkYXRlLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGZsaWNrZXIgcmlnaHQgYmVmb3JlIHRoZSByZWxvYWQuXG4gICAgICAgICAgICBvbkZhc3RSZWZyZXNoKGhhc1VwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBDb21waWxhdGlvbiB3aXRoIHdhcm5pbmdzIChlLmcuIEVTTGludCkuXG5mdW5jdGlvbiBoYW5kbGVXYXJuaW5ncyh3YXJuaW5ncykge1xuICAgIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKTtcbiAgICBjb25zdCBpc0hvdFVwZGF0ZSA9ICFpc0ZpcnN0Q29tcGlsYXRpb247XG4gICAgaXNGaXJzdENvbXBpbGF0aW9uID0gZmFsc2U7XG4gICAgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHByaW50V2FybmluZ3MoKSB7XG4gICAgICAgIC8vIFByaW50IHdhcm5pbmdzIHRvIHRoZSBjb25zb2xlLlxuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSAoMCwgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcykuZGVmYXVsdCh7XG4gICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgICAgICAgICBlcnJvcnM6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQud2FybmluZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGlmIChpID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlcmUgd2VyZSBtb3JlIHdhcm5pbmdzIGluIG90aGVyIGZpbGVzLlxcbicgKyAnWW91IGNhbiBmaW5kIGEgY29tcGxldGUgbG9nIGluIHRoZSB0ZXJtaW5hbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgX3N0cmlwQW5zaSkuZGVmYXVsdChmb3JtYXR0ZWQud2FybmluZ3NbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmludFdhcm5pbmdzKCk7XG4gICAgLy8gQXR0ZW1wdCB0byBhcHBseSBob3QgdXBkYXRlcyBvciByZWxvYWQuXG4gICAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgICAgIHRyeUFwcGx5VXBkYXRlcyhmdW5jdGlvbiBvblN1Y2Nlc3NmdWxIb3RVcGRhdGUoaGFzVXBkYXRlcykge1xuICAgICAgICAgICAgLy8gT25seSBkaXNtaXNzIGl0IHdoZW4gd2UncmUgc3VyZSBpdCdzIGEgaG90IHVwZGF0ZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCB3b3VsZCBmbGlja2VyIHJpZ2h0IGJlZm9yZSB0aGUgcmVsb2FkLlxuICAgICAgICAgICAgb25GYXN0UmVmcmVzaChoYXNVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcnMoZXJyb3JzKSB7XG4gICAgY2xlYXJPdXRkYXRlZEVycm9ycygpO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSB0cnVlO1xuICAgIC8vIFwiTWFzc2FnZVwiIHdlYnBhY2sgbWVzc2FnZXMuXG4gICAgdmFyIGZvcm1hdHRlZCA9ICgwLCBfZm9ybWF0V2VicGFja01lc3NhZ2VzKS5kZWZhdWx0KHtcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHdhcm5pbmdzOiBbXVxuICAgIH0pO1xuICAgIC8vIE9ubHkgc2hvdyB0aGUgZmlyc3QgZXJyb3IuXG4gICAgKDAsIF9jbGllbnQpLm9uQnVpbGRFcnJvcihmb3JtYXR0ZWQuZXJyb3JzWzBdKTtcbiAgICAvLyBBbHNvIGxvZyB0aGVtIHRvIHRoZSBjb25zb2xlLlxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdHRlZC5lcnJvcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigoMCwgX3N0cmlwQW5zaSkuZGVmYXVsdChmb3JtYXR0ZWQuZXJyb3JzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVsb2FkIG5vdy5cbiAgICAvLyBXZSB3aWxsIHJlbG9hZCBvbiBuZXh0IHN1Y2Nlc3MgaW5zdGVhZC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoZm9ybWF0dGVkLmVycm9yc1swXSk7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHN0YXJ0TGF0ZW5jeSA9IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcykge1xuICAgICgwLCBfY2xpZW50KS5vbkJ1aWxkT2soKTtcbiAgICBpZiAoaGFzVXBkYXRlcykge1xuICAgICAgICAoMCwgX2NsaWVudCkub25SZWZyZXNoKCk7XG4gICAgfVxuICAgIGlmIChzdGFydExhdGVuY3kpIHtcbiAgICAgICAgY29uc3QgbGF0ZW5jeSA9IERhdGUubm93KCkgLSBzdGFydExhdGVuY3k7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRmFzdCBSZWZyZXNoXSBkb25lIGluICR7bGF0ZW5jeX1tc2ApO1xuICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0xBVEVOQ1lfQ0IpIHtcbiAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCKGxhdGVuY3kpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlcmUgaXMgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBjb2RlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIGhhbmRsZUF2YWlsYWJsZUhhc2goaGFzaCkge1xuICAgIC8vIFVwZGF0ZSBsYXN0IGtub3duIGNvbXBpbGF0aW9uIGhhc2guXG4gICAgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IGhhc2g7XG59XG4vLyBIYW5kbGUgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyLlxuZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2UoZSkge1xuICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICBzd2l0Y2gob2JqLmFjdGlvbil7XG4gICAgICAgIGNhc2UgJ2J1aWxkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydExhdGVuY3kgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbRmFzdCBSZWZyZXNoXSByZWJ1aWxkaW5nJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2J1aWx0JzpcbiAgICAgICAgY2FzZSAnc3luYyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUF2YWlsYWJsZUhhc2gob2JqLmhhc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycyAsIHdhcm5pbmdzICB9ID0gb2JqO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0Vycm9ycyA9IEJvb2xlYW4oZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9ycyhlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNXYXJuaW5ncyA9IEJvb2xlYW4od2FybmluZ3MgJiYgd2FybmluZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzV2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVdhcm5pbmdzKHdhcm5pbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tSG1yRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUhtckV2ZW50SGFuZGxlcihvYmopO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuLy8gSXMgdGhlcmUgYSBuZXdlciB2ZXJzaW9uIG9mIHRoaXMgY29kZSBhdmFpbGFibGU/XG5mdW5jdGlvbiBpc1VwZGF0ZUF2YWlsYWJsZSgpIHtcbiAgICAvKiBnbG9iYWxzIF9fd2VicGFja19oYXNoX18gKi8gLy8gX193ZWJwYWNrX2hhc2hfXyBpcyB0aGUgaGFzaCBvZiB0aGUgY3VycmVudCBjb21waWxhdGlvbi5cbiAgICAvLyBJdCdzIGEgZ2xvYmFsIHZhcmlhYmxlIGluamVjdGVkIGJ5IFdlYnBhY2suXG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggIT09IF9fd2VicGFja19oYXNoX187XG59XG4vLyBXZWJwYWNrIGRpc2FsbG93cyB1cGRhdGVzIGluIG90aGVyIHN0YXRlcy5cbmZ1bmN0aW9uIGNhbkFwcGx5VXBkYXRlcygpIHtcbiAgICByZXR1cm4gbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gJ2lkbGUnO1xufVxuZnVuY3Rpb24gYWZ0ZXJBcHBseVVwZGF0ZXMoZm4pIHtcbiAgICBpZiAoY2FuQXBwbHlVcGRhdGVzKCkpIHtcbiAgICAgICAgZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKHN0YXR1cykge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5yZW1vdmVTdGF0dXNIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlLmhvdC5hZGRTdGF0dXNIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbn1cbi8vIEF0dGVtcHQgdG8gdXBkYXRlIGNvZGUgb24gdGhlIGZseSwgZmFsbCBiYWNrIHRvIGEgaGFyZCByZWxvYWQuXG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXMob25Ib3RVcGRhdGVTdWNjZXNzKSB7XG4gICAgaWYgKCFtb2R1bGUuaG90KSB7XG4gICAgICAgIC8vIEhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIGlzIG5vdCBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0hvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIGlzIG5vdCBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzVXBkYXRlQXZhaWxhYmxlKCkgfHwgIWNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgICAgICgwLCBfY2xpZW50KS5vbkJ1aWxkT2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBcHBseVVwZGF0ZXMoZXJyLCB1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICBpZiAoZXJyIHx8IGhhZFJ1bnRpbWVFcnJvciB8fCAhdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWRcXG5cXG4nICsgXCJGYXN0IFJlZnJlc2ggd2lsbCBwZXJmb3JtIGEgZnVsbCByZWxvYWQgd2hlbiB5b3UgZWRpdCBhIGZpbGUgdGhhdCdzIGltcG9ydGVkIGJ5IG1vZHVsZXMgb3V0c2lkZSBvZiB0aGUgUmVhY3QgcmVuZGVyaW5nIHRyZWUuXFxuXCIgKyAnWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIGV4cG9ydHMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50IGZpbGUuXFxuJyArICdDb25zaWRlciBtaWdyYXRpbmcgdGhlIG5vbi1SZWFjdCBjb21wb25lbnQgZXhwb3J0IHRvIGEgc2VwYXJhdGUgZmlsZSBhbmQgaW1wb3J0aW5nIGl0IGludG8gYm90aCBmaWxlcy5cXG5cXG4nICsgJ0l0IGlzIGFsc28gcG9zc2libGUgdGhlIHBhcmVudCBjb21wb25lbnQgb2YgdGhlIGNvbXBvbmVudCB5b3UgZWRpdGVkIGlzIGEgY2xhc3MgY29tcG9uZW50LCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuJyArICdGYXN0IFJlZnJlc2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmVudCBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWQgYmVjYXVzZSB5b3VyIGFwcGxpY2F0aW9uIGhhZCBhbiB1bnJlY292ZXJhYmxlIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVXBkYXRlcyA9IEJvb2xlYW4odXBkYXRlZE1vZHVsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkhvdFVwZGF0ZVN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIE1heWJlIHdlIHdhbnQgdG8gZG8gc29tZXRoaW5nLlxuICAgICAgICAgICAgb25Ib3RVcGRhdGVTdWNjZXNzKGhhc1VwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VwZGF0ZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBXaGlsZSB3ZSB3ZXJlIHVwZGF0aW5nLCB0aGVyZSB3YXMgYSBuZXcgdXBkYXRlISBEbyBpdCBhZ2Fpbi5cbiAgICAgICAgICAgIHRyeUFwcGx5VXBkYXRlcyhoYXNVcGRhdGVzID8gX2NsaWVudC5vbkJ1aWxkT2sgOiBvbkhvdFVwZGF0ZVN1Y2Nlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKDAsIF9jbGllbnQpLm9uQnVpbGRPaygpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgICAgICAgICBhZnRlckFwcGx5VXBkYXRlcygoKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNjaGVja1xuICAgIG1vZHVsZS5ob3QuY2hlY2soLyogYXV0b0FwcGx5ICovIHRydWUpLnRoZW4oKHVwZGF0ZWRNb2R1bGVzKT0+e1xuICAgICAgICBoYW5kbGVBcHBseVVwZGF0ZXMobnVsbCwgdXBkYXRlZE1vZHVsZXMpO1xuICAgIH0sIChlcnIpPT57XG4gICAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsIG51bGwpO1xuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3QtZGV2LWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiY29ubmVjdCIsIl9jbGllbnQiLCJyZXF1aXJlIiwiX3N0cmlwQW5zaSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfd2Vic29ja2V0IiwiX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJoYWRSdW50aW1lRXJyb3IiLCJjdXN0b21IbXJFdmVudEhhbmRsZXIiLCJyZWdpc3RlciIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsImluZGV4T2YiLCJwcm9jZXNzTWVzc2FnZSIsImV4IiwiY29uc29sZSIsIndhcm4iLCJzdWJzY3JpYmVUb0htckV2ZW50IiwiaGFuZGxlciIsIm9uVW5yZWNvdmVyYWJsZUVycm9yIiwiaXNGaXJzdENvbXBpbGF0aW9uIiwibW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCIsImhhc0NvbXBpbGVFcnJvcnMiLCJjbGVhck91dGRhdGVkRXJyb3JzIiwiY2xlYXIiLCJoYW5kbGVTdWNjZXNzIiwiaXNIb3RVcGRhdGUiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwicGFnZSIsImlzVXBkYXRlQXZhaWxhYmxlIiwidHJ5QXBwbHlVcGRhdGVzIiwib25TdWNjZXNzZnVsSG90VXBkYXRlIiwiaGFzVXBkYXRlcyIsIm9uRmFzdFJlZnJlc2giLCJoYW5kbGVXYXJuaW5ncyIsIndhcm5pbmdzIiwicHJpbnRXYXJuaW5ncyIsImZvcm1hdHRlZCIsImVycm9ycyIsImkiLCJsZW5ndGgiLCJoYW5kbGVFcnJvcnMiLCJvbkJ1aWxkRXJyb3IiLCJlcnJvciIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVEVTVF9NT0RFIiwic2VsZiIsIl9fTkVYVF9ITVJfQ0IiLCJzdGFydExhdGVuY3kiLCJ1bmRlZmluZWQiLCJvbkJ1aWxkT2siLCJvblJlZnJlc2giLCJsYXRlbmN5IiwiRGF0ZSIsIm5vdyIsImxvZyIsIl9fTkVYVF9ITVJfTEFURU5DWV9DQiIsImhhbmRsZUF2YWlsYWJsZUhhc2giLCJoYXNoIiwiZSIsIkpTT04iLCJwYXJzZSIsImFjdGlvbiIsImhhc0Vycm9ycyIsIkJvb2xlYW4iLCJoYXNXYXJuaW5ncyIsIl9fd2VicGFja19oYXNoX18iLCJjYW5BcHBseVVwZGF0ZXMiLCJtb2R1bGUiLCJob3QiLCJzdGF0dXMiLCJhZnRlckFwcGx5VXBkYXRlcyIsImZuIiwicmVtb3ZlU3RhdHVzSGFuZGxlciIsImFkZFN0YXR1c0hhbmRsZXIiLCJvbkhvdFVwZGF0ZVN1Y2Nlc3MiLCJoYW5kbGVBcHBseVVwZGF0ZXMiLCJlcnIiLCJ1cGRhdGVkTW9kdWxlcyIsImxvY2F0aW9uIiwicmVsb2FkIiwiY2hlY2siLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/regenerator-runtime/runtime.js */ \"./node_modules/regenerator-runtime/runtime.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _router = _interopRequireDefault1(__webpack_require__(/*! next/router */ \"./node_modules/next/router.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar _default = _asyncToGenerator(_runtimeJs.default.mark(function _callee(page) {\n    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n        while(1)switch(_ctx.prev = _ctx.next){\n            case 0:\n                if (page) {\n                    // in AMP the router isn't initialized on the client and\n                    // client-transitions don't occur so ping initial page\n                    setInterval(function() {\n                        (0, _websocket).sendMessage(JSON.stringify({\n                            event: 'ping',\n                            page: page\n                        }));\n                    }, 2500);\n                } else {\n                    _router.default.ready(function() {\n                        setInterval(function() {\n                            (0, _websocket).sendMessage(JSON.stringify({\n                                event: 'ping',\n                                page: _router.default.pathname\n                            }));\n                        }, 2500);\n                    });\n                }\n                (0, _websocket).addMessageListener(function(event) {\n                    if (event.data.indexOf('{') === -1) return;\n                    try {\n                        var payload = JSON.parse(event.data);\n                        // don't attempt fetching the page if we're already showing\n                        // the dev overlay as this can cause the error to be triggered\n                        // repeatedly\n                        if (payload.event === 'pong' && payload.invalid && !self.__NEXT_DATA__.err) {\n                            // Payload can be invalid even if the page does exist.\n                            // So, we check if it can be created.\n                            fetch(location.href, {\n                                credentials: 'same-origin'\n                            }).then(function(pageRes) {\n                                if (pageRes.status === 200) {\n                                    // Page exists now, reload\n                                    location.reload();\n                                } else {\n                                    // Page doesn't exist\n                                    if (self.__NEXT_DATA__.page === _router.default.pathname && _router.default.pathname !== '/_error') {\n                                        // We are still on the page,\n                                        // reload to show 404 error page\n                                        location.reload();\n                                    }\n                                }\n                            });\n                        }\n                    } catch (err) {\n                        console.error('on-demand-entries failed to parse response', err);\n                    }\n                });\n            case 2:\n            case \"end\":\n                return _ctx.stop();\n        }\n    }, _callee);\n}));\nexports[\"default\"] = _default; //# sourceMappingURL=on-demand-entries-client.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7Ozs7OztBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN4QixHQUFHLENBQUNHLE9BQU8sR0FBR0MsdUJBQXNCLENBQUNDLG1CQUFPLENBQUMsa0RBQWE7QUFDMUQsR0FBRyxDQUFDQyxVQUFVLEdBQUdELG1CQUFPLENBQUMsaUdBQTJCO1NBQzNDRSxrQkFBa0IsQ0FBQ0MsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFLENBQUM7SUFDeEUsR0FBRyxDQUFDLENBQUM7UUFDRCxHQUFHLENBQUNDLElBQUksR0FBR1AsR0FBRyxDQUFDSyxHQUFHLEVBQUVDLEdBQUc7UUFDdkIsR0FBRyxDQUFDYixLQUFLLEdBQUdjLElBQUksQ0FBQ2QsS0FBSztJQUMxQixDQUFDLENBQUMsS0FBSyxFQUFFZSxLQUFLLEVBQUUsQ0FBQztRQUNiTixNQUFNLENBQUNNLEtBQUs7UUFDWixNQUFNO0lBQ1YsQ0FBQztJQUNELEVBQUUsRUFBRUQsSUFBSSxDQUFDRSxJQUFJLEVBQUUsQ0FBQztRQUNaUixPQUFPLENBQUNSLEtBQUs7SUFDakIsQ0FBQyxNQUFNLENBQUM7UUFDSmlCLE9BQU8sQ0FBQ1QsT0FBTyxDQUFDUixLQUFLLEVBQUVrQixJQUFJLENBQUNSLEtBQUssRUFBRUMsTUFBTTtJQUM3QyxDQUFDO0FBQ0wsQ0FBQztTQUNRUSxpQkFBaUIsQ0FBQ0MsRUFBRSxFQUFFLENBQUM7SUFDNUIsTUFBTSxDQUFDLFFBQVEsR0FBRyxDQUFDO1FBQ2YsR0FBRyxDQUFDQyxJQUFJLEdBQUcsSUFBSSxFQUFFQyxJQUFJLEdBQUdDLFNBQVM7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LEVBQUUsQ0FBQztvQ0FDekIsRUFBMEI7b0NBQzFCSixRQUFRLENBQUNLLE1BQU07Z0NBQ25CLENBQUMsTUFBTSxDQUFDO29DQUNKLEVBQXFCO29DQUNyQixFQUFFLEVBQUU5QixJQUFJLENBQUN1QixhQUFhLENBQUNkLElBQUksS0FBSzVCLE9BQU8sQ0FBQ0QsT0FBTyxDQUFDb0MsUUFBUSxJQUFJbkMsT0FBTyxDQUFDRCxPQUFPLENBQUNvQyxRQUFRLEtBQUssQ0FBUyxVQUFFLENBQUM7d0NBQ2pHLEVBQTRCO3dDQUM1QixFQUFnQzt3Q0FDaENTLFFBQVEsQ0FBQ0ssTUFBTTtvQ0FDbkIsQ0FBQztnQ0FDTCxDQUFDOzRCQUNMLENBQUM7d0JBQ0wsQ0FBQztvQkFDTCxDQUFDLENBQUMsS0FBSyxFQUFFMUIsR0FBRyxFQUFFLENBQUM7d0JBQ1gyQixPQUFPLENBQUNyQyxLQUFLLENBQUMsQ0FBNEMsNkNBQUVVLEdBQUc7b0JBQ25FLENBQUM7Z0JBQ0wsQ0FBQzs7Ozs7O0FBQ0wsQ0FBQztBQUNEMUIsa0JBQWUsR0FBRzhCLFFBQVEsQ0FFMUIsQ0FBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcz84NDVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yb3V0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKSk7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbnZhciBfZGVmYXVsdCA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKihwYWdlKSB7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgLy8gaW4gQU1QIHRoZSByb3V0ZXIgaXNuJ3QgaW5pdGlhbGl6ZWQgb24gdGhlIGNsaWVudCBhbmRcbiAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb25zIGRvbid0IG9jY3VyIHNvIHBpbmcgaW5pdGlhbCBwYWdlXG4gICAgICAgIHNldEludGVydmFsKCgpPT57XG4gICAgICAgICAgICAoMCwgX3dlYnNvY2tldCkuc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiAncGluZycsXG4gICAgICAgICAgICAgICAgcGFnZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LCAyNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfcm91dGVyLmRlZmF1bHQucmVhZHkoKCk9PntcbiAgICAgICAgICAgIHNldEludGVydmFsKCgpPT57XG4gICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdwaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSwgMjUwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCk9PntcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZigneycpID09PSAtMSkgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAvLyBkb24ndCBhdHRlbXB0IGZldGNoaW5nIHRoZSBwYWdlIGlmIHdlJ3JlIGFscmVhZHkgc2hvd2luZ1xuICAgICAgICAgICAgLy8gdGhlIGRldiBvdmVybGF5IGFzIHRoaXMgY2FuIGNhdXNlIHRoZSBlcnJvciB0byBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICAgIC8vIHJlcGVhdGVkbHlcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmV2ZW50ID09PSAncG9uZycgJiYgcGF5bG9hZC5pbnZhbGlkICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gUGF5bG9hZCBjYW4gYmUgaW52YWxpZCBldmVuIGlmIHRoZSBwYWdlIGRvZXMgZXhpc3QuXG4gICAgICAgICAgICAgICAgLy8gU28sIHdlIGNoZWNrIGlmIGl0IGNhbiBiZSBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIGZldGNoKGxvY2F0aW9uLmhyZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgICAgICAgICAgICAgICB9KS50aGVuKChwYWdlUmVzKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFnZVJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFnZSBleGlzdHMgbm93LCByZWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFnZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfREFUQV9fLnBhZ2UgPT09IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSAmJiBfcm91dGVyLmRlZmF1bHQucGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzdGlsbCBvbiB0aGUgcGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxvYWQgdG8gc2hvdyA0MDQgZXJyb3IgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignb24tZGVtYW5kLWVudHJpZXMgZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcm91dGVyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfd2Vic29ja2V0IiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93Iiwia2V5IiwiYXJnIiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2RlZmF1bHQiLCJwYWdlIiwic2V0SW50ZXJ2YWwiLCJzZW5kTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudCIsInJlYWR5IiwicGF0aG5hbWUiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJkYXRhIiwiaW5kZXhPZiIsInBheWxvYWQiLCJwYXJzZSIsImludmFsaWQiLCJfX05FWFRfREFUQV9fIiwiZmV0Y2giLCJsb2NhdGlvbiIsImhyZWYiLCJjcmVkZW50aWFscyIsInBhZ2VSZXMiLCJzdGF0dXMiLCJyZWxvYWQiLCJjb25zb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/on-demand-entries-client.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/regenerator-runtime/runtime.js */ \"./node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nvar _s2 = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.initNext = initNext;\nexports.render = render;\nexports.renderError = renderError;\nexports.emitter = exports.router = exports.version = void 0;\n__webpack_require__(/*! @next/polyfill-module */ \"./node_modules/@next/polyfill-module/dist/polyfill-module.js\");\nvar _react = _interopRequireDefault1(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _reactDom = _interopRequireDefault1(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nvar _styledJsx = __webpack_require__(/*! styled-jsx */ \"./node_modules/styled-jsx/index.js\");\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nvar _headManager = _interopRequireDefault1(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nvar _pageLoader = _interopRequireDefault1(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nvar _performanceRelayer = _interopRequireDefault1(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nvar _router1 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _isError = _interopRequireDefault1(__webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _vitals = __webpack_require__(/*! ./vitals */ \"./node_modules/next/dist/client/vitals.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard1(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _objectSpread(target) {\n    var _arguments = arguments, _loop = function(i) {\n        var source = _arguments[i] != null ? _arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    };\n    for(var i = 1; i < arguments.length; i++)_loop(i);\n    return target;\n}\nvar data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\nwindow.__NEXT_DATA__ = data;\nvar version = \"12.0.7\";\nexports.version = version;\nvar looseToArray = function(input) {\n    return [].slice.call(input);\n};\nvar hydrateProps = data.props, hydrateErr = data.err, page = data.page, query = data.query, buildId = data.buildId, assetPrefix = data.assetPrefix, runtimeConfig = data.runtimeConfig, dynamicIds = data.dynamicIds, isFallback = data.isFallback, locale = data.locale, locales = data.locales, domainLocales = data.domainLocales, isPreview = data.isPreview, rsc = data.rsc;\nvar defaultLocale = data.defaultLocale;\nvar prefix = assetPrefix || '';\n// With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n// So, this is how we do it in the client side at runtime\n__webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n;\n// Initialize next/config with the environment configuration\n(0, _runtimeConfig).setConfig({\n    serverRuntimeConfig: {\n    },\n    publicRuntimeConfig: runtimeConfig || {\n    }\n});\nvar asPath = (0, _utils).getURL();\n// make sure not to attempt stripping basePath for 404s\nif ((0, _router).hasBasePath(asPath)) {\n    asPath = (0, _router).delBasePath(asPath);\n}\nif (false) { var detectedDomain, localePathResult, parsedAs, formatUrl, parseRelativeUrl, detectDomainLocale, normalizeLocalePath; }\nif (data.scriptLoader) {\n    var initScriptLoader = (__webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\").initScriptLoader);\n    initScriptLoader(data.scriptLoader);\n}\nvar pageLoader = new _pageLoader.default(buildId, prefix);\nvar register = function(param) {\n    var _param = _slicedToArray(param, 2), r = _param[0], f = _param[1];\n    return pageLoader.routeLoader.onEntrypoint(r, f);\n};\nif (window.__NEXT_P) {\n    // Defer page registration for another tick. This will increase the overall\n    // latency in hydrating the page, but reduce the total blocking time.\n    window.__NEXT_P.map(function(p) {\n        return setTimeout(function() {\n            return register(p);\n        }, 0);\n    });\n}\nwindow.__NEXT_P = [];\nwindow.__NEXT_P.push = register;\nvar headManager = (0, _headManager).default();\nvar appElement = document.getElementById('__next');\nvar lastRenderReject;\nvar webpackHMR;\nvar router;\nexports.router = router;\nvar CachedApp, onPerfEntry;\nheadManager.getIsSsr = function() {\n    return router.isSsr;\n};\nvar Container = /*#__PURE__*/ function(_Component) {\n    _inherits(Container, _Component);\n    var _super = _createSuper(Container);\n    function Container() {\n        _classCallCheck(this, Container);\n        return _super.apply(this, arguments);\n    }\n    _createClass(Container, [\n        {\n            key: \"componentDidCatch\",\n            value: function componentDidCatch(componentErr, info) {\n                this.props.fn(componentErr, info);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.scrollToHash();\n                // We need to replace the router state if:\n                // - the page was (auto) exported and has a query string or search (hash)\n                // - it was auto exported and is a dynamic route (to provide params)\n                // - if it is a client-side skeleton (fallback render)\n                if (router.isSsr && // the asPath unexpectedly e.g. adding basePath when\n                // it wasn't originally present\n                page !== '/404' && page !== '/_error' && (isFallback || data.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false) || hydrateProps && hydrateProps.__N_SSG && (location.search || false))) {\n                    // update query on mount for exported pages\n                    router.replace(router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                        // @ts-ignore\n                        // WARNING: `_h` is an internal option for handing Next.js\n                        // client-side hydration. Your app should _never_ use this property.\n                        // It may change at any time without notice.\n                        _h: 1,\n                        // Fallback pages must trigger the data fetch, so the transition is\n                        // not shallow.\n                        // Other pages (strictly updating query) happens shallowly, as data\n                        // requirements would already be present.\n                        shallow: !isFallback\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                this.scrollToHash();\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash() {\n                var hash = location.hash;\n                hash = hash && hash.substring(1);\n                if (!hash) return;\n                var el = document.getElementById(hash);\n                if (!el) return;\n                // If we call scrollIntoView() in here without a setTimeout\n                // it won't scroll properly.\n                setTimeout(function() {\n                    return el.scrollIntoView();\n                }, 0);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (false) {} else {\n                    var ReactDevOverlay = (__webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\").ReactDevOverlay);\n                    return(/*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children));\n                }\n            }\n        }\n    ]);\n    return Container;\n}(_react.default.Component);\nvar emitter = (0, _mitt).default();\nexports.emitter = emitter;\nvar CachedComponent;\nfunction _initNext() {\n    _initNext = _asyncToGenerator(_runtimeJs.default.mark(function _callee(param1) {\n        var opts, initialErr, appEntrypoint, app, mod, exportedReportWebVitals, pageEntrypoint, isValidElementType, getNodeError, renderCtx;\n        return _runtimeJs.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    opts = param1 === void 0 ? {\n                    } : param1;\n                    // This makes sure this specific lines are removed in production\n                    if (true) {\n                        webpackHMR = opts.webpackHMR;\n                    }\n                    initialErr = hydrateErr;\n                    _ctx.prev = 3;\n                    _ctx.next = 6;\n                    return pageLoader.routeLoader.whenEntrypoint('/_app');\n                case 6:\n                    appEntrypoint = _ctx.sent;\n                    if (!('error' in appEntrypoint)) {\n                        _ctx.next = 9;\n                        break;\n                    }\n                    throw appEntrypoint.error;\n                case 9:\n                    app = appEntrypoint.component, mod = appEntrypoint.exports;\n                    CachedApp = app;\n                    exportedReportWebVitals = mod && mod.reportWebVitals;\n                    onPerfEntry = function(param) {\n                        var id = param.id, name = param.name, startTime = param.startTime, value = param.value, duration = param.duration, entryType = param.entryType, entries = param.entries;\n                        // Combines timestamp with random number for unique ID\n                        var uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9000000000000 - 1)) + 1000000000000);\n                        var perfStartEntry;\n                        if (entries && entries.length) {\n                            perfStartEntry = entries[0].startTime;\n                        }\n                        var webVitals = {\n                            id: id || uniqueID,\n                            name: name,\n                            startTime: startTime || perfStartEntry,\n                            value: value == null ? duration : value,\n                            label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                        };\n                        exportedReportWebVitals === null || exportedReportWebVitals === void 0 ? void 0 : exportedReportWebVitals(webVitals);\n                        (0, _vitals).trackWebVitalMetric(webVitals);\n                    };\n                    if (// error, so we need to skip waiting for the entrypoint.\n                    !( true && hydrateErr)) {\n                        _ctx.next = 17;\n                        break;\n                    }\n                    _ctx.t0 = {\n                        error: hydrateErr\n                    };\n                    _ctx.next = 20;\n                    break;\n                case 17:\n                    _ctx.next = 19;\n                    return pageLoader.routeLoader.whenEntrypoint(page);\n                case 19:\n                    _ctx.t0 = _ctx.sent;\n                case 20:\n                    pageEntrypoint = _ctx.t0;\n                    if (!('error' in pageEntrypoint)) {\n                        _ctx.next = 23;\n                        break;\n                    }\n                    throw pageEntrypoint.error;\n                case 23:\n                    CachedComponent = pageEntrypoint.component;\n                    if (false) {}\n                    isValidElementType = (__webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\").isValidElementType);\n                    if (isValidElementType(CachedComponent)) {\n                        _ctx.next = 28;\n                        break;\n                    }\n                    throw new Error(\"The default export is not a React Component in page: \\\"\".concat(page, \"\\\"\"));\n                case 28:\n                    _ctx.next = 33;\n                    break;\n                case 30:\n                    _ctx.prev = 30;\n                    _ctx.t1 = _ctx[\"catch\"](3);\n                    // This catches errors like throwing in the top level of a module\n                    initialErr = (0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + '');\n                case 33:\n                    if (true) {\n                        getNodeError = (__webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\").getNodeError);\n                        // Server-side runtime errors need to be re-thrown on the client-side so\n                        // that the overlay is rendered.\n                        if (initialErr) {\n                            if (initialErr === hydrateErr) {\n                                setTimeout(function() {\n                                    var error;\n                                    try {\n                                        // Generate a new error object. We `throw` it because some browsers\n                                        // will set the `stack` when thrown, and we want to ensure ours is\n                                        // not overridden when we re-throw it below.\n                                        throw new Error(initialErr.message);\n                                    } catch (e) {\n                                        error = e;\n                                    }\n                                    error.name = initialErr.name;\n                                    error.stack = initialErr.stack;\n                                    // Errors from the middleware are reported as client-side errors\n                                    // since the middleware is compiled using the client compiler\n                                    if ('middleware' in hydrateErr) {\n                                        throw error;\n                                    }\n                                    var node = getNodeError(error);\n                                    throw node;\n                                });\n                            } else {\n                                setTimeout(function() {\n                                    throw initialErr;\n                                });\n                            }\n                        }\n                    }\n                    if (!window.__NEXT_PRELOADREADY) {\n                        _ctx.next = 37;\n                        break;\n                    }\n                    _ctx.next = 37;\n                    return window.__NEXT_PRELOADREADY(dynamicIds);\n                case 37:\n                    exports.router = router = (0, _router1).createRouter(page, query, asPath, {\n                        initialProps: hydrateProps,\n                        pageLoader: pageLoader,\n                        App: CachedApp,\n                        Component: CachedComponent,\n                        wrapApp: wrapApp,\n                        err: initialErr,\n                        isFallback: Boolean(isFallback),\n                        subscription: function(info, App, scroll) {\n                            return render(Object.assign({\n                            }, info, {\n                                App: App,\n                                scroll: scroll\n                            }));\n                        },\n                        locale: locale,\n                        locales: locales,\n                        defaultLocale: defaultLocale,\n                        domainLocales: domainLocales,\n                        isPreview: isPreview\n                    });\n                    renderCtx = {\n                        App: CachedApp,\n                        initial: true,\n                        Component: CachedComponent,\n                        props: hydrateProps,\n                        err: initialErr\n                    };\n                    if (true) {\n                        _ctx.next = 44;\n                        break;\n                    }\n                    render(renderCtx);\n                    return _ctx.abrupt(\"return\", emitter);\n                case 44:\n                    return _ctx.abrupt(\"return\", {\n                        emitter: emitter,\n                        renderCtx: renderCtx\n                    });\n                case 45:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                3,\n                30\n            ]\n        ]);\n    }));\n    return _initNext.apply(this, arguments);\n}\nfunction initNext() {\n    return _initNext.apply(this, arguments);\n}\nfunction _render() {\n    _render = _asyncToGenerator(_runtimeJs.default.mark(function _callee(renderingProps) {\n        var renderErr;\n        return _runtimeJs.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (!renderingProps.err) {\n                        _ctx.next = 4;\n                        break;\n                    }\n                    _ctx.next = 3;\n                    return renderError(renderingProps);\n                case 3:\n                    return _ctx.abrupt(\"return\");\n                case 4:\n                    _ctx.prev = 4;\n                    _ctx.next = 7;\n                    return doRender(renderingProps);\n                case 7:\n                    _ctx.next = 17;\n                    break;\n                case 9:\n                    _ctx.prev = 9;\n                    _ctx.t0 = _ctx[\"catch\"](4);\n                    renderErr = _instanceof(_ctx.t0, Error) ? _ctx.t0 : new Error(_ctx.t0 + '');\n                    if (!renderErr.cancelled) {\n                        _ctx.next = 14;\n                        break;\n                    }\n                    throw renderErr;\n                case 14:\n                    if (true) {\n                        // Ensure this error is displayed in the overlay in development\n                        setTimeout(function() {\n                            throw renderErr;\n                        });\n                    }\n                    _ctx.next = 17;\n                    return renderError(_objectSpread({\n                    }, renderingProps, {\n                        err: renderErr\n                    }));\n                case 17:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                4,\n                9\n            ]\n        ]);\n    }));\n    return _render.apply(this, arguments);\n}\nfunction render(renderingProps) {\n    return _render.apply(this, arguments);\n}\nfunction renderError(renderErrorProps) {\n    var App = renderErrorProps.App, err = renderErrorProps.err;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        return doRender({\n            App: function() {\n                return null;\n            },\n            props: {\n            },\n            Component: function() {\n                return null;\n            },\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage('/_error').then(function(param) {\n        var ErrorComponent = param.page, styleSheets = param.styleSheets;\n        return (lastAppProps === null || lastAppProps === void 0 ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(function() {\n            return _interopRequireWildcard(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"));\n        }).then(function(m) {\n            return {\n                ErrorComponent: m.default,\n                styleSheets: []\n            };\n        }) : {\n            ErrorComponent: ErrorComponent,\n            styleSheets: styleSheets\n        };\n    }).then(function(param) {\n        var ErrorComponent = param.ErrorComponent, styleSheets = param.styleSheets;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        var AppTree = wrapApp(App);\n        var appCtx = {\n            Component: ErrorComponent,\n            AppTree: AppTree,\n            router: router,\n            ctx: {\n                err: err,\n                pathname: page,\n                query: query,\n                asPath: asPath,\n                AppTree: AppTree\n            }\n        };\n        return Promise.resolve(renderErrorProps.props ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then(function(initProps) {\n            return doRender(_objectSpread({\n            }, renderErrorProps, {\n                err: err,\n                Component: ErrorComponent,\n                styleSheets: styleSheets,\n                props: initProps\n            }));\n        });\n    });\n}\nvar reactRoot = null;\n// On initial render a hydrate should always happen\nvar shouldHydrate = true;\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark('beforeRender');\n    }\n    var reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (false) {} else {\n        // The check for `.hydrate` is there to support React alternatives like preact\n        if (shouldHydrate) {\n            _reactDom.default.hydrate(reactEl, domEl);\n            shouldHydrate = false;\n        } else {\n            _reactDom.default.render(reactEl, domEl);\n        }\n    }\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark('afterHydrate') // mark end of hydration\n    ;\n    performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');\n    performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');\n    if (onPerfEntry) {\n        performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark('afterRender') // mark end of render\n    ;\n    var navStartEntries = performance.getEntriesByName('routeChange', 'mark');\n    if (!navStartEntries.length) return;\n    performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');\n    performance.measure('Next.js-render', 'beforeRender', 'afterRender');\n    if (onPerfEntry) {\n        performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);\n        performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        'Next.js-route-change-to-render',\n        'Next.js-render'\n    ].forEach(function(measure) {\n        return performance.clearMeasures(measure);\n    });\n}\nfunction clearMarks() {\n    [\n        'beforeRender',\n        'afterHydrate',\n        'afterRender',\n        'routeChange'\n    ].forEach(function(mark) {\n        return performance.clearMarks(mark);\n    });\n}\nfunction AppContainer(param) {\n    var children = param.children;\n    return(/*#__PURE__*/ _react.default.createElement(Container, {\n        fn: function(error) {\n            return renderError({\n                App: CachedApp,\n                err: error\n            }).catch(function(err) {\n                return console.error('Error rendering page: ', err);\n            });\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_routerContext.RouterContext.Provider, {\n        value: (0, _router1).makePublicRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_styledJsx.StyleRegistry, null, children)))));\n}\n_c = AppContainer;\nvar wrapApp = function(App) {\n    return function(wrappedAppProps) {\n        var appProps = _objectSpread({\n        }, wrappedAppProps, {\n            Component: CachedComponent,\n            err: hydrateErr,\n            router: router\n        });\n        return(/*#__PURE__*/ _react.default.createElement(AppContainer, null, /*#__PURE__*/ _react.default.createElement(App, Object.assign({\n        }, appProps))));\n    };\n};\nvar RSCComponent;\nif (false) { var RSCWrapper, rscCache, createResponseCache; }\nvar lastAppProps;\nfunction doRender(input) {\n    var onStart = // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // unless we're in production:\n        \"development\" !== 'production') {\n            return false;\n        }\n        var currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        var currentHrefs = new Set(currentStyleTags.map(function(tag) {\n            return tag.getAttribute('data-n-href');\n        }));\n        var noscript = document.querySelector('noscript[data-n-css]');\n        var nonce = noscript === null || noscript === void 0 ? void 0 : noscript.getAttribute('data-n-css');\n        styleSheets.forEach(function(param) {\n            var href = param.href, text = param.text;\n            if (!currentHrefs.has(href)) {\n                var styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    };\n    var onHeadCommit = function onHeadCommit() {\n        if (// unless we're in production:\n        false) { var referenceNode, idx, currentHrefs, currentStyleTags, desiredHrefs; }\n        if (input.scroll) {\n            window.scrollTo(input.scroll.x, input.scroll.y);\n        }\n    };\n    var onRootCommit = function onRootCommit() {\n        resolvePromise();\n    };\n    var App = input.App, Component = input.Component, props = input.props, err = input.err, __N_RSC = input.__N_RSC;\n    var styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    var isRSC =  false ? 0 : !!__N_RSC;\n    var appProps = _objectSpread({\n    }, props, {\n        Component: isRSC ? RSCComponent : Component,\n        err: err,\n        router: router\n    });\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    var canceled = false;\n    var resolvePromise;\n    var renderPromise = new Promise(function(resolve, reject) {\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = function() {\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = function() {\n            canceled = true;\n            lastRenderReject = null;\n            var error = new Error('Cancel rendering route');\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    onStart();\n    var elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, /*#__PURE__*/ _react.default.createElement(App, Object.assign({\n    }, appProps)), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeAnnouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, function(callback) {\n        /*#__PURE__*/ return _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  false ? /*#__PURE__*/ 0 : elem);\n    });\n    return renderPromise;\n}\nfunction Root(param) {\n    var callbacks = param.callbacks, children = param.children;\n    _s2();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(function() {\n        return callbacks.forEach(function(callback) {\n            return callback();\n        });\n    }, [\n        callbacks\n    ]);\n    if (undefined) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        _react.default.useEffect(function() {\n            window.__NEXT_HYDRATED = true;\n            if (window.__NEXT_HYDRATED_CB) {\n                window.__NEXT_HYDRATED_CB();\n            }\n        }, []);\n    }\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(function() {\n        (0, _performanceRelayer).default(onPerfEntry);\n    }, []);\n    return children;\n}\n_s2(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c1 = Root;\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    var callback = param.callback;\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(function() {\n        return callback();\n    }, [\n        callback\n    ]);\n    return null;\n} //# sourceMappingURL=index.js.map\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c2 = Head;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Root\");\n$RefreshReg$(_c2, \"Head\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGdCQUFnQixHQUFHRSxRQUFRO0FBQzNCRixjQUFjLEdBQUdHLE1BQU07QUFDdkJILG1CQUFtQixHQUFHSSxXQUFXO0FBQ2pDSixlQUFlLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQzNEUSxtQkFBTyxDQUFDLDJGQUF1QjtBQUMvQixHQUFHLENBQUNDLE1BQU0sR0FBR0MsdUJBQXNCLENBQUNGLG1CQUFPLENBQUMsNENBQU87QUFDbkQsR0FBRyxDQUFDRyxTQUFTLEdBQUdELHVCQUFzQixDQUFDRixtQkFBTyxDQUFDLG9EQUFXO0FBQzFELEdBQUcsQ0FBQ0ksVUFBVSxHQUFHSixtQkFBTyxDQUFDLHNEQUFZO0FBQ3JDLEdBQUcsQ0FBQ0ssbUJBQW1CLEdBQUdMLG1CQUFPLENBQUMsdUdBQW9DO0FBQ3RFLEdBQUcsQ0FBQ00sS0FBSyxHQUFHSix1QkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyx1RUFBb0I7QUFDL0QsR0FBRyxDQUFDTyxjQUFjLEdBQUdQLG1CQUFPLENBQUMsMkZBQThCO0FBQzNELEdBQUcsQ0FBQ1EsT0FBTyxHQUFHUixtQkFBTyxDQUFDLHlGQUE2QjtBQUNuRCxHQUFHLENBQUNTLFVBQVUsR0FBR1QsbUJBQU8sQ0FBQyw2R0FBdUM7QUFDaEUsR0FBRyxDQUFDVSxZQUFZLEdBQUdWLG1CQUFPLENBQUMsK0dBQXdDO0FBQ25F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R0FBRyxJQUFJO1lBQzdCLEVBQUUsRUFBRXRRLE1BQU0sQ0FBQ3VRLGtCQUFrQixFQUFFLENBQUM7Z0JBQzVCdlEsTUFBTSxDQUFDdVEsa0JBQWtCO1lBQzdCLENBQUM7UUFDTCxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ1QsQ0FBQztJQUNELEVBQTBFO0lBQzFFLEVBQW1DO0lBQ25DbFYsTUFBTSxDQUFDK0MsT0FBTyxDQUFDaVMsU0FBUyxDQUFDLFFBQzNCLEdBRCtCLENBQUM7U0FDekIsQ0FBQyxFQUFFalUsbUJBQW1CLEVBQUVnQyxPQUFPLENBQUMyRixXQUFXO0lBQ2hELENBQUMsRUFBRSxDQUFDLENBQUM7SUFDTCxNQUFNLENBQUN5QixRQUFRO0FBQ25CLENBQUM7SUF2QlF1SyxJQUFJO01BQUpBLElBQUk7QUF3QmIsRUFBbUU7QUFDbkUsRUFBeUQ7U0FDaERMLElBQUksQ0FBQyxLQUFhLEVBQUUsQ0FBQztRQUFkQyxRQUFRLEdBQVYsS0FBYSxDQUFYQSxRQUFROztJQUNwQixFQUFpRTtJQUNqRSxFQUF1QztJQUN2Q3RVLE1BQU0sQ0FBQytDLE9BQU8sQ0FBQytSLGVBQWUsQ0FBQyxRQUFRO1FBQUpSLE1BQU0sQ0FBTkEsUUFBUTtPQUN6QyxDQUFDO1FBQ0NBLFFBQVE7SUFDWixDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUk7QUFDZixDQUFDLENBRWdDO0lBVnhCRCxJQUFJO01BQUpBLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW5kZXguanM/NDZjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaW5pdE5leHQgPSBpbml0TmV4dDtcbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy5yZW5kZXJFcnJvciA9IHJlbmRlckVycm9yO1xuZXhwb3J0cy5lbWl0dGVyID0gZXhwb3J0cy5yb3V0ZXIgPSBleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5yZXF1aXJlKFwiQG5leHQvcG9seWZpbGwtbW9kdWxlXCIpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9zdHlsZWRKc3ggPSByZXF1aXJlKFwic3R5bGVkLWpzeFwiKTtcbnZhciBfaGVhZE1hbmFnZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHRcIik7XG52YXIgX21pdHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL21pdHRcIikpO1xudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXJcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbnZhciBfcnVudGltZUNvbmZpZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3J1bnRpbWUtY29uZmlnXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xudmFyIF9wb3J0YWwgPSByZXF1aXJlKFwiLi9wb3J0YWxcIik7XG52YXIgX2hlYWRNYW5hZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIikpO1xudmFyIF9wYWdlTG9hZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYWdlLWxvYWRlclwiKSk7XG52YXIgX3BlcmZvcm1hbmNlUmVsYXllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGVyZm9ybWFuY2UtcmVsYXllclwiKSk7XG52YXIgX3JvdXRlQW5ub3VuY2VyID0gcmVxdWlyZShcIi4vcm91dGUtYW5ub3VuY2VyXCIpO1xudmFyIF9yb3V0ZXIxID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xudmFyIF9pc0Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbGliL2lzLWVycm9yXCIpKTtcbnZhciBfdml0YWxzID0gcmVxdWlyZShcIi4vdml0YWxzXCIpO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdPYmogPSB7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBkYXRhID0gSlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpLnRleHRDb250ZW50KTtcbndpbmRvdy5fX05FWFRfREFUQV9fID0gZGF0YTtcbmNvbnN0IHZlcnNpb24gPSBcIjEyLjAuN1wiO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmNvbnN0IGxvb3NlVG9BcnJheSA9IChpbnB1dCk9PltdLnNsaWNlLmNhbGwoaW5wdXQpXG47XG5jb25zdCB7IHByb3BzOiBoeWRyYXRlUHJvcHMgLCBlcnI6IGh5ZHJhdGVFcnIgLCBwYWdlICwgcXVlcnkgLCBidWlsZElkICwgYXNzZXRQcmVmaXggLCBydW50aW1lQ29uZmlnICwgZHluYW1pY0lkcyAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAsIHJzYyAsICB9ID0gZGF0YTtcbmxldCB7IGRlZmF1bHRMb2NhbGUgIH0gPSBkYXRhO1xuY29uc3QgcHJlZml4ID0gYXNzZXRQcmVmaXggfHwgJyc7XG4vLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4vLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbl9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYCR7cHJlZml4fS9fbmV4dC9gIC8vZXNsaW50LWRpc2FibGUtbGluZVxuO1xuLy8gSW5pdGlhbGl6ZSBuZXh0L2NvbmZpZyB3aXRoIHRoZSBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9uXG4oMCwgX3J1bnRpbWVDb25maWcpLnNldENvbmZpZyh7XG4gICAgc2VydmVyUnVudGltZUNvbmZpZzoge1xuICAgIH0sXG4gICAgcHVibGljUnVudGltZUNvbmZpZzogcnVudGltZUNvbmZpZyB8fCB7XG4gICAgfVxufSk7XG5sZXQgYXNQYXRoID0gKDAsIF91dGlscykuZ2V0VVJMKCk7XG4vLyBtYWtlIHN1cmUgbm90IHRvIGF0dGVtcHQgc3RyaXBwaW5nIGJhc2VQYXRoIGZvciA0MDRzXG5pZiAoKDAsIF9yb3V0ZXIpLmhhc0Jhc2VQYXRoKGFzUGF0aCkpIHtcbiAgICBhc1BhdGggPSAoMCwgX3JvdXRlcikuZGVsQmFzZVBhdGgoYXNQYXRoKTtcbn1cbmlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpO1xuICAgIGNvbnN0IHsgZGV0ZWN0RG9tYWluTG9jYWxlICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJyk7XG4gICAgY29uc3QgeyBwYXJzZVJlbGF0aXZlVXJsICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJyk7XG4gICAgY29uc3QgeyBmb3JtYXRVcmwgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJyk7XG4gICAgaWYgKGxvY2FsZXMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBsb2NhbGVzKTtcbiAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGRlZmF1bHQgbG9jYWxlIGlmIGl0IHdhc24ndCBkZXRlY3RlZCBpbiB0aGUgYXNQYXRoXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBwcmVyZW5kZXIgc3RhdGljIHBhZ2VzIHdpdGggYWxsIHBvc3NpYmxlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGxvY2FsZXNcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXR0ZW1wdCBkZXRlY3RpbmcgZGVmYXVsdCBsb2NhbGUgYmFzZWQgb24gaG9zdG5hbWVcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fRE9NQUlOUywgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgICAgLy8gaHlkcmF0aW9uIHRvIHByZXZlbnQgbWlzbWF0Y2hlZCByZW5kZXJzXG4gICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoZGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICBjb25zdCB7IGluaXRTY3JpcHRMb2FkZXIgIH0gPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuICAgIGluaXRTY3JpcHRMb2FkZXIoZGF0YS5zY3JpcHRMb2FkZXIpO1xufVxuY29uc3QgcGFnZUxvYWRlciA9IG5ldyBfcGFnZUxvYWRlci5kZWZhdWx0KGJ1aWxkSWQsIHByZWZpeCk7XG5jb25zdCByZWdpc3RlciA9IChbciwgZl0pPT5wYWdlTG9hZGVyLnJvdXRlTG9hZGVyLm9uRW50cnlwb2ludChyLCBmKVxuO1xuaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApPT5zZXRUaW1lb3V0KCgpPT5yZWdpc3RlcihwKVxuICAgICAgICAsIDApXG4gICAgKTtcbn1cbndpbmRvdy5fX05FWFRfUCA9IFtdO1xud2luZG93Ll9fTkVYVF9QLnB1c2ggPSByZWdpc3RlcjtcbmNvbnN0IGhlYWRNYW5hZ2VyID0gKDAsIF9oZWFkTWFuYWdlcikuZGVmYXVsdCgpO1xuY29uc3QgYXBwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKTtcbmxldCBsYXN0UmVuZGVyUmVqZWN0O1xubGV0IHdlYnBhY2tITVI7XG5sZXQgcm91dGVyO1xuZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXI7XG5sZXQgQ2FjaGVkQXBwLCBvblBlcmZFbnRyeTtcbmhlYWRNYW5hZ2VyLmdldElzU3NyID0gKCk9PntcbiAgICByZXR1cm4gcm91dGVyLmlzU3NyO1xufTtcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyLCBpbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMuZm4oY29tcG9uZW50RXJyLCBpbmZvKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuICAgICAgICAvLyAtIHRoZSBwYWdlIHdhcyAoYXV0bykgZXhwb3J0ZWQgYW5kIGhhcyBhIHF1ZXJ5IHN0cmluZyBvciBzZWFyY2ggKGhhc2gpXG4gICAgICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuICAgICAgICBpZiAocm91dGVyLmlzU3NyICYmIC8vIFdlIGRvbid0IHVwZGF0ZSBmb3IgNDA0IHJlcXVlc3RzIGFzIHRoaXMgY2FuIG1vZGlmeVxuICAgICAgICAvLyB0aGUgYXNQYXRoIHVuZXhwZWN0ZWRseSBlLmcuIGFkZGluZyBiYXNlUGF0aCB3aGVuXG4gICAgICAgIC8vIGl0IHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnRcbiAgICAgICAgcGFnZSAhPT0gJy80MDQnICYmIHBhZ2UgIT09ICcvX2Vycm9yJyAmJiAoaXNGYWxsYmFjayB8fCBkYXRhLm5leHRFeHBvcnQgJiYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpIHx8IGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB8fCBoeWRyYXRlUHJvcHMgJiYgaHlkcmF0ZVByb3BzLl9fTl9TU0cgJiYgKGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSkpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgICAgICAgIHJvdXRlci5yZXBsYWNlKHJvdXRlci5wYXRobmFtZSArICc/JyArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nKS5hc3NpZ24oKDAsIF9xdWVyeXN0cmluZykudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhyb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgYXNQYXRoLCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgICAgICAgIHNoYWxsb3c6ICFpc0ZhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaCgpIHtcbiAgICAgICAgbGV0IHsgaGFzaCAgfSA9IGxvY2F0aW9uO1xuICAgICAgICBoYXNoID0gaGFzaCAmJiBoYXNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgY2FsbCBzY3JvbGxJbnRvVmlldygpIGluIGhlcmUgd2l0aG91dCBhIHNldFRpbWVvdXRcbiAgICAgICAgLy8gaXQgd29uJ3Qgc2Nyb2xsIHByb3Blcmx5LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT5lbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICwgMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBSZWFjdERldk92ZXJsYXkgIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4oLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0RGV2T3ZlcmxheSwgbnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZW1pdHRlciA9ICgwLCBfbWl0dCkuZGVmYXVsdCgpO1xuZXhwb3J0cy5lbWl0dGVyID0gZW1pdHRlcjtcbmxldCBDYWNoZWRDb21wb25lbnQ7XG5mdW5jdGlvbiBfaW5pdE5leHQoKSB7XG4gICAgX2luaXROZXh0ID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qKG9wdHMgPSB7XG4gICAgfSkge1xuICAgICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgd2VicGFja0hNUiA9IG9wdHMud2VicGFja0hNUjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdGlhbEVyciA9IGh5ZHJhdGVFcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0geWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludCgnL19hcHAnKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCAsIGV4cG9ydHM6IG1vZCAgfSA9IGFwcEVudHJ5cG9pbnQ7XG4gICAgICAgICAgICBDYWNoZWRBcHAgPSBhcHA7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9IG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzO1xuICAgICAgICAgICAgb25QZXJmRW50cnkgPSAoeyBpZCAsIG5hbWUgLCBzdGFydFRpbWUgLCB2YWx1ZSAsIGR1cmF0aW9uICwgZW50cnlUeXBlICwgZW50cmllcyAgfSk9PntcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVJRCA9IGAke0RhdGUubm93KCl9LSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDkwMDAwMDAwMDAwMDAgLSAxKSkgKyAxMDAwMDAwMDAwMDAwfWA7XG4gICAgICAgICAgICAgICAgbGV0IHBlcmZTdGFydEVudHJ5O1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZTdGFydEVudHJ5ID0gZW50cmllc1swXS5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdlYlZpdGFscyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkIHx8IHVuaXF1ZUlELFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSB8fCBwZXJmU3RhcnRFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlID09IG51bGwgPyBkdXJhdGlvbiA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZW50cnlUeXBlID09PSAnbWFyaycgfHwgZW50cnlUeXBlID09PSAnbWVhc3VyZScgPyAnY3VzdG9tJyA6ICd3ZWItdml0YWwnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9PT0gbnVsbCB8fCBleHBvcnRlZFJlcG9ydFdlYlZpdGFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwb3J0ZWRSZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKTtcbiAgICAgICAgICAgICAgICAoMCwgX3ZpdGFscykudHJhY2tXZWJWaXRhbE1ldHJpYyh3ZWJWaXRhbHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID0gLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgICAgICAgIC8vIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIGVudHJ5cG9pbnQuXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBoeWRyYXRlRXJyID8ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBoeWRyYXRlRXJyXG4gICAgICAgICAgICB9IDogeWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChwYWdlKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGFnZUVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDYWNoZWRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGFnZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgbGlrZSB0aHJvd2luZyBpbiB0aGUgdG9wIGxldmVsIG9mIGEgbW9kdWxlXG4gICAgICAgICAgICBpbml0aWFsRXJyID0gKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycm9yKSA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yICsgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgeyBnZXROb2RlRXJyb3IgIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7XG4gICAgICAgICAgICAvLyBTZXJ2ZXItc2lkZSBydW50aW1lIGVycm9ycyBuZWVkIHRvIGJlIHJlLXRocm93biBvbiB0aGUgY2xpZW50LXNpZGUgc29cbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVycikge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRXJyID09PSBoeWRyYXRlRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9ycyBmcm9tIHRoZSBtaWRkbGV3YXJlIGFyZSByZXBvcnRlZCBhcyBjbGllbnQtc2lkZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBtaWRkbGV3YXJlIGlzIGNvbXBpbGVkIHVzaW5nIHRoZSBjbGllbnQgY29tcGlsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnbWlkZGxld2FyZScgaW4gaHlkcmF0ZUVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdldE5vZGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgICAgICAgICB5aWVsZCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShkeW5hbWljSWRzKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnJvdXRlciA9IHJvdXRlciA9ICgwLCBfcm91dGVyMSkuY3JlYXRlUm91dGVyKHBhZ2UsIHF1ZXJ5LCBhc1BhdGgsIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wczogaHlkcmF0ZVByb3BzLFxuICAgICAgICAgICAgcGFnZUxvYWRlcixcbiAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICB3cmFwQXBwLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyLFxuICAgICAgICAgICAgaXNGYWxsYmFjazogQm9vbGVhbihpc0ZhbGxiYWNrKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogKGluZm8sIEFwcCwgc2Nyb2xsKT0+cmVuZGVyKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIH0sIGluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgQXBwLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgIGxvY2FsZXMsXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgICAgIGlzUHJldmlld1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wczogaHlkcmF0ZVByb3BzLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZW5kZXIocmVuZGVyQ3R4KTtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLFxuICAgICAgICAgICAgICAgIHJlbmRlckN0eFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfaW5pdE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGluaXROZXh0KCkge1xuICAgIHJldHVybiBfaW5pdE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgX3JlbmRlciA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKihyZW5kZXJpbmdQcm9wcykge1xuICAgICAgICBpZiAocmVuZGVyaW5nUHJvcHMuZXJyKSB7XG4gICAgICAgICAgICB5aWVsZCByZW5kZXJFcnJvcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIGRvUmVuZGVyKHJlbmRlcmluZ1Byb3BzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJFcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihlcnIgKyAnJyk7XG4gICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICBpZiAocmVuZGVyRXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGVycm9yIGlzIGRpc3BsYXllZCBpbiB0aGUgb3ZlcmxheSBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcmVuZGVyRXJyb3IoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICB9LCByZW5kZXJpbmdQcm9wcywge1xuICAgICAgICAgICAgICAgIGVycjogcmVuZGVyRXJyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckVycm9yKHJlbmRlckVycm9yUHJvcHMpIHtcbiAgICBjb25zdCB7IEFwcCAsIGVyciAgfSA9IHJlbmRlckVycm9yUHJvcHM7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgICAgIC8vIEZJWE1FOiBsZXQncyBtYWtlIHRoaXMgcmVjb3ZlcmFibGUgKGVycm9yIGluIEdJUCBjbGllbnQtdHJhbnNpdGlvbilcbiAgICAgICAgd2VicGFja0hNUi5vblVucmVjb3ZlcmFibGVFcnJvcigpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSA8QXBwPiBzbyB0aGF0IHRoZSBgPFJlYWN0RGV2T3ZlcmxheT5gIGNhblxuICAgICAgICAvLyByZW5kZXIgaXRzZWxmLlxuICAgICAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgICAgICAgQXBwOiAoKT0+bnVsbFxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb21wb25lbnQ6ICgpPT5udWxsXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLCBvdGhlcndpc2UgdXNlcnMgY2FuJ3QgdHJhY2sgZG93biBpc3N1ZXMuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGNvbnNvbGUuZXJyb3IoYEEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkYCk7XG4gICAgcmV0dXJuIHBhZ2VMb2FkZXIubG9hZFBhZ2UoJy9fZXJyb3InKS50aGVuKCh7IHBhZ2U6IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIHJldHVybiAobGFzdEFwcFByb3BzID09PSBudWxsIHx8IGxhc3RBcHBQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdEFwcFByb3BzLkNvbXBvbmVudCkgPT09IEVycm9yQ29tcG9uZW50ID8gaW1wb3J0KCcuLi9wYWdlcy9fZXJyb3InKS50aGVuKChtKT0+KHtcbiAgICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKSA6IHtcbiAgICAgICAgICAgIEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgc3R5bGVTaGVldHNcbiAgICAgICAgfTtcbiAgICB9KS50aGVuKCh7IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgZG8gYSBub3JtYWwgcmVuZGVyIHdpdGggdGhlIGBFcnJvckNvbXBvbmVudGAgYXMgY29tcG9uZW50LlxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHdyYXBBcHAoQXBwKTtcbiAgICAgICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IHBhZ2UsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgICAgIEFwcFRyZWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJFcnJvclByb3BzLnByb3BzID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcyA6ICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCBhcHBDdHgpKS50aGVuKChpbml0UHJvcHMpPT5kb1JlbmRlcihfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIH0sIHJlbmRlckVycm9yUHJvcHMsIHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdFByb3BzXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cbmxldCByZWFjdFJvb3QgPSBudWxsO1xuLy8gT24gaW5pdGlhbCByZW5kZXIgYSBoeWRyYXRlIHNob3VsZCBhbHdheXMgaGFwcGVuXG5sZXQgc2hvdWxkSHlkcmF0ZSA9IHRydWU7XG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoZG9tRWwsIGZuKSB7XG4gICAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnYmVmb3JlUmVuZGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0RWwgPSBmbihzaG91bGRIeWRyYXRlID8gbWFya0h5ZHJhdGVDb21wbGV0ZSA6IG1hcmtSZW5kZXJDb21wbGV0ZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ST09UKSB7XG4gICAgICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgICAgICAvLyBVbmxpa2Ugd2l0aCBjcmVhdGVSb290LCB5b3UgZG9uJ3QgbmVlZCBhIHNlcGFyYXRlIHJvb3QucmVuZGVyKCkgY2FsbCBoZXJlXG4gICAgICAgICAgICByZWFjdFJvb3QgPSBfcmVhY3REb20uZGVmYXVsdC5oeWRyYXRlUm9vdChkb21FbCwgcmVhY3RFbCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFjdFJvb3QucmVuZGVyKHJlYWN0RWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNoZWNrIGZvciBgLmh5ZHJhdGVgIGlzIHRoZXJlIHRvIHN1cHBvcnQgUmVhY3QgYWx0ZXJuYXRpdmVzIGxpa2UgcHJlYWN0XG4gICAgICAgIGlmIChzaG91bGRIeWRyYXRlKSB7XG4gICAgICAgICAgICBfcmVhY3REb20uZGVmYXVsdC5oeWRyYXRlKHJlYWN0RWwsIGRvbUVsKTtcbiAgICAgICAgICAgIHNob3VsZEh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZWFjdERvbS5kZWZhdWx0LnJlbmRlcihyZWFjdEVsLCBkb21FbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJIeWRyYXRlJykgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG4gICAgO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtYmVmb3JlLWh5ZHJhdGlvbicsICduYXZpZ2F0aW9uU3RhcnQnLCAnYmVmb3JlUmVuZGVyJyk7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVySHlkcmF0ZScpO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLWh5ZHJhdGlvbicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKSB7XG4gICAgaWYgKCFfdXRpbHMuU1QpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlclJlbmRlcicpIC8vIG1hcmsgZW5kIG9mIHJlbmRlclxuICAgIDtcbiAgICBjb25zdCBuYXZTdGFydEVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyb3V0ZUNoYW5nZScsICdtYXJrJyk7XG4gICAgaWYgKCFuYXZTdGFydEVudHJpZXMubGVuZ3RoKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJywgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsICdiZWZvcmVSZW5kZXInKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJlbmRlcicsICdiZWZvcmVSZW5kZXInLCAnYWZ0ZXJSZW5kZXInKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yZW5kZXInKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbiAgICBbXG4gICAgICAgICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLFxuICAgICAgICAnTmV4dC5qcy1yZW5kZXInXG4gICAgXS5mb3JFYWNoKChtZWFzdXJlKT0+cGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlKVxuICAgICk7XG59XG5mdW5jdGlvbiBjbGVhck1hcmtzKCkge1xuICAgIFtcbiAgICAgICAgJ2JlZm9yZVJlbmRlcicsXG4gICAgICAgICdhZnRlckh5ZHJhdGUnLFxuICAgICAgICAnYWZ0ZXJSZW5kZXInLFxuICAgICAgICAncm91dGVDaGFuZ2UnXG4gICAgXS5mb3JFYWNoKChtYXJrKT0+cGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKVxuICAgICk7XG59XG5mdW5jdGlvbiBBcHBDb250YWluZXIoeyBjaGlsZHJlbiAgfSkge1xuICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7XG4gICAgICAgIGZuOiAoZXJyb3IpPT5yZW5kZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvclxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PmNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLCBlcnIpXG4gICAgICAgICAgICApXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZXJDb250ZXh0LlJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfcm91dGVyMSkubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGhlYWRNYW5hZ2VyXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9zdHlsZWRKc3guU3R5bGVSZWdpc3RyeSwgbnVsbCwgY2hpbGRyZW4pKSkpKTtcbn1cbmNvbnN0IHdyYXBBcHAgPSAoQXBwKT0+KHdyYXBwZWRBcHBQcm9wcyk9PntcbiAgICAgICAgY29uc3QgYXBwUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgfSwgd3JhcHBlZEFwcFByb3BzLCB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIGVycjogaHlkcmF0ZUVycixcbiAgICAgICAgICAgIHJvdXRlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHBDb250YWluZXIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHAsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB9LCBhcHBQcm9wcykpKSk7XG4gICAgfVxuO1xubGV0IFJTQ0NvbXBvbmVudDtcbmlmIChwcm9jZXNzLmVudi5fX05FWFRfUlNDKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgY29uc3QgcnNjQ2FjaGUgPSBjcmVhdGVSZXNwb25zZUNhY2hlKCk7XG4gICAgY29uc3QgUlNDV3JhcHBlciA9ICh7IGNhY2hlS2V5ICwgc2VyaWFsaXplZCAsIF9mcmVzaCAgfSk9PntcbiAgICAgICAgY29uc3QgeyBjcmVhdGVGcm9tRmV0Y2ggLCAgfSA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2snKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gcnNjQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gY2FjaGUsIG9yIHRoZXJlIGlzIHNlcmlhbGl6ZWQgZGF0YSBhbHJlYWR5XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gY3JlYXRlRnJvbUZldGNoKHNlcmlhbGl6ZWQgPyAoKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgIHQud3JpdGFibGUuZ2V0V3JpdGVyKCkud3JpdGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdC5yZWFkYWJsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKSA6ICgoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHRSZXFVcmwgPSBsb2NhdGlvbi5wYXRobmFtZSArIHNlYXJjaCArIChzZWFyY2ggPyAnJl9fZmxpZ2h0X18nIDogJz9fX2ZsaWdodF9fJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoKGZsaWdodFJlcVVybCk7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgIHJzY0NhY2hlLnNldChjYWNoZUtleSwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3QgPSByZXNwb25zZS5yZWFkUm9vdCgpO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIFJTQ0NvbXBvbmVudCA9IChwcm9wcyk9PntcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAoMCwgX3JvdXRlcjEpLnVzZVJvdXRlcigpLmFzUGF0aDtcbiAgICAgICAgY29uc3QgeyBfX2ZsaWdodF9zZXJpYWxpemVkX18gLCBfX2ZsaWdodF9mcmVzaF9fICB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiBudWxsXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSU0NXcmFwcGVyLCB7XG4gICAgICAgICAgICBjYWNoZUtleTogY2FjaGVLZXksXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBfX2ZsaWdodF9zZXJpYWxpemVkX18sXG4gICAgICAgICAgICBfZnJlc2g6IF9fZmxpZ2h0X2ZyZXNoX19cbiAgICAgICAgfSkpKTtcbiAgICB9O1xufVxubGV0IGxhc3RBcHBQcm9wcztcbmZ1bmN0aW9uIGRvUmVuZGVyKGlucHV0KSB7XG4gICAgbGV0IHsgQXBwICwgQ29tcG9uZW50ICwgcHJvcHMgLCBlcnIgLCBfX05fUlNDICB9ID0gaW5wdXQ7XG4gICAgbGV0IHN0eWxlU2hlZXRzID0gJ2luaXRpYWwnIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHM7XG4gICAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnQ7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHM7XG4gICAgY29uc3QgaXNSU0MgPSBwcm9jZXNzLmVudi5fX05FWFRfUlNDICYmICdpbml0aWFsJyBpbiBpbnB1dCA/ICEhcnNjIDogISFfX05fUlNDO1xuICAgIGNvbnN0IGFwcFByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgfSwgcHJvcHMsIHtcbiAgICAgICAgQ29tcG9uZW50OiBpc1JTQyA/IFJTQ0NvbXBvbmVudCA6IENvbXBvbmVudCxcbiAgICAgICAgZXJyLFxuICAgICAgICByb3V0ZXJcbiAgICB9KTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDYW5jZWwgcmVuZGVyaW5nIHJvdXRlJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gICAgLy8gUHJvbWlzZS4gSXQgc2hvdWxkIHJlbWFpbiBzeW5jaHJvbm91cy5cbiAgICBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICBpZiAoIXN0eWxlU2hlZXRzIHx8IC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3MgPSBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJykpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpXG4gICAgICAgICkpO1xuICAgICAgICBjb25zdCBub3NjcmlwdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbm9zY3JpcHQgPT09IG51bGwgfHwgbm9zY3JpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1uLWNzcycpO1xuICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYgLCB0ZXh0ICB9KT0+e1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50SHJlZnMuaGFzKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKTtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSGVhZENvbW1pdCgpIHtcbiAgICAgICAgaWYgKC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAvLyBXZSBjYW4gc2tpcCB0aGlzIGR1cmluZyBoeWRyYXRpb24uIFJ1bm5pbmcgaXQgd29udCBjYXVzZSBhbnkgaGFybSwgYnV0XG4gICAgICAgIC8vIHdlIG1heSBhcyB3ZWxsIHNhdmUgdGhlIENQVSBjeWNsZXM6XG4gICAgICAgIHN0eWxlU2hlZXRzICYmIC8vIEVuc3VyZSB0aGlzIHJlbmRlciB3YXMgbm90IGNhbmNlbGVkXG4gICAgICAgICFjYW5jZWxlZCkge1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZEhyZWZzID0gbmV3IFNldChzdHlsZVNoZWV0cy5tYXAoKHMpPT5zLmhyZWZcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBjdXJyZW50U3R5bGVUYWdzLm1hcCgodGFnKT0+dGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgICAgICAgZm9yKGxldCBpZHggPSAwOyBpZHggPCBjdXJyZW50SHJlZnMubGVuZ3RoOyArK2lkeCl7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1uLWhyZWY9XCIke2hyZWZ9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZGF0YS1uLXBdJykpLmZvckVhY2goKGVsKT0+e1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LnNjcm9sbCkge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKGlucHV0LnNjcm9sbC54LCBpbnB1dC5zY3JvbGwueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Sb290Q29tbWl0KCkge1xuICAgICAgICByZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cbiAgICBvblN0YXJ0KCk7XG4gICAgY29uc3QgZWxlbSA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhlYWQsIHtcbiAgICAgICAgY2FsbGJhY2s6IG9uSGVhZENvbW1pdFxuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwLCBPYmplY3QuYXNzaWduKHtcbiAgICB9LCBhcHBQcm9wcykpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZUFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSlcbiAgICApO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuZnVuY3Rpb24gUm9vdCh7IGNhbGxiYWNrcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2tzIGFyZSBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spPT5jYWxsYmFjaygpXG4gICAgICAgIClcbiAgICAsIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWU7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICAvLyBXZSBzaG91bGQgYXNrIHRvIG1lYXN1cmUgdGhlIFdlYiBWaXRhbHMgYWZ0ZXIgcmVuZGVyaW5nIGNvbXBsZXRlcyBzbyB3ZVxuICAgIC8vIGRvbid0IGNhdXNlIGFueSBoeWRyYXRpb24gZGVsYXk6XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICgwLCBfcGVyZm9ybWFuY2VSZWxheWVyKS5kZWZhdWx0KG9uUGVyZkVudHJ5KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuLy8gRHVtbXkgY29tcG9uZW50IHRoYXQgd2UgcmVuZGVyIGFzIGEgY2hpbGQgb2YgUm9vdCBzbyB0aGF0IHdlIGNhblxuLy8gdG9nZ2xlIHRoZSBjb3JyZWN0IHN0eWxlcyBiZWZvcmUgdGhlIHBhZ2UgaXMgcmVuZGVyZWQuXG5mdW5jdGlvbiBIZWFkKHsgY2FsbGJhY2sgIH0pIHtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2soKVxuICAgICwgW1xuICAgICAgICBjYWxsYmFja1xuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0TmV4dCIsInJlbmRlciIsInJlbmRlckVycm9yIiwiZW1pdHRlciIsInJvdXRlciIsInZlcnNpb24iLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdERvbSIsIl9zdHlsZWRKc3giLCJfaGVhZE1hbmFnZXJDb250ZXh0IiwiX21pdHQiLCJfcm91dGVyQ29udGV4dCIsIl9yb3V0ZXIiLCJfaXNEeW5hbWljIiwiX3F1ZXJ5c3RyaW5nIiwiX3J1bnRpbWVDb25maWciLCJfdXRpbHMiLCJfcG9ydGFsIiwiX2hlYWRNYW5hZ2VyIiwiX3BhZ2VMb2FkZXIiLCJfcGVyZm9ybWFuY2VSZWxheWVyIiwiX3JvdXRlQW5ub3VuY2VyIiwiX3JvdXRlcjEiLCJfaXNFcnJvciIsIl92aXRhbHMiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJrZXkiLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwic2VsZiIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsImVyciIsInVuZGVmaW5lZCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJuZXdPYmoiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsInNvdXJjZSIsImkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImZvckVhY2giLCJsZW5ndGgiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInRleHRDb250ZW50Iiwid2luZG93IiwiX19ORVhUX0RBVEFfXyIsImxvb3NlVG9BcnJheSIsImlucHV0Iiwic2xpY2UiLCJoeWRyYXRlUHJvcHMiLCJwcm9wcyIsImh5ZHJhdGVFcnIiLCJwYWdlIiwicXVlcnkiLCJidWlsZElkIiwiYXNzZXRQcmVmaXgiLCJydW50aW1lQ29uZmlnIiwiZHluYW1pY0lkcyIsImlzRmFsbGJhY2siLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInJzYyIsImRlZmF1bHRMb2NhbGUiLCJwcmVmaXgiLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsInNldENvbmZpZyIsInNlcnZlclJ1bnRpbWVDb25maWciLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwiYXNQYXRoIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJkZWxCYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsImRldGVjdERvbWFpbkxvY2FsZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJmb3JtYXRVcmwiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJwYXRobmFtZSIsImRldGVjdGVkTG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwibG9jYXRpb24iLCJob3N0bmFtZSIsInNjcmlwdExvYWRlciIsImluaXRTY3JpcHRMb2FkZXIiLCJwYWdlTG9hZGVyIiwicmVnaXN0ZXIiLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwic2V0VGltZW91dCIsInB1c2giLCJoZWFkTWFuYWdlciIsImFwcEVsZW1lbnQiLCJsYXN0UmVuZGVyUmVqZWN0Iiwid2VicGFja0hNUiIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiZ2V0SXNTc3IiLCJpc1NzciIsIkNvbnRhaW5lciIsImNvbXBvbmVudERpZENhdGNoIiwiY29tcG9uZW50RXJyIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2giLCJzaGFsbG93IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwic2Nyb2xsSW50b1ZpZXciLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsImNyZWF0ZUVsZW1lbnQiLCJDb21wb25lbnQiLCJDYWNoZWRDb21wb25lbnQiLCJfaW5pdE5leHQiLCJvcHRzIiwiaW5pdGlhbEVyciIsImFwcEVudHJ5cG9pbnQiLCJhcHAiLCJtb2QiLCJleHBvcnRlZFJlcG9ydFdlYlZpdGFscyIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0Tm9kZUVycm9yIiwicmVuZGVyQ3R4Iiwid2hlbkVudHJ5cG9pbnQiLCJjb21wb25lbnQiLCJyZXBvcnRXZWJWaXRhbHMiLCJuYW1lIiwiaWQiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJ1bmlxdWVJRCIsIk1hdGgiLCJEYXRlIiwibm93IiwiZmxvb3IiLCJyYW5kb20iLCJwZXJmU3RhcnRFbnRyeSIsIndlYlZpdGFscyIsImxhYmVsIiwidHJhY2tXZWJWaXRhbE1ldHJpYyIsIkVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsIm5vZGUiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJzY3JvbGwiLCJpbml0aWFsIiwiX3JlbmRlciIsInJlbmRlcmluZ1Byb3BzIiwicmVuZGVyRXJyIiwiZG9SZW5kZXIiLCJjYW5jZWxsZWQiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJzdHlsZVNoZWV0cyIsImNvbnNvbGUiLCJsb2FkUGFnZSIsIkVycm9yQ29tcG9uZW50IiwibGFzdEFwcFByb3BzIiwibSIsIkFwcFRyZWUiLCJhcHBDdHgiLCJjdHgiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwicmVhY3RSb290Iiwic2hvdWxkSHlkcmF0ZSIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJyZWFjdEVsIiwibWFya0h5ZHJhdGVDb21wbGV0ZSIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIl9fTkVYVF9SRUFDVF9ST09UIiwiaHlkcmF0ZVJvb3QiLCJoeWRyYXRlIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwiY2xlYXJNZWFzdXJlcyIsIkFwcENvbnRhaW5lciIsImNhdGNoIiwiUm91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiU3R5bGVSZWdpc3RyeSIsIndyYXBwZWRBcHBQcm9wcyIsImFwcFByb3BzIiwiUlNDQ29tcG9uZW50IiwiX19ORVhUX1JTQyIsImNyZWF0ZVJlc3BvbnNlQ2FjaGUiLCJNYXAiLCJyc2NDYWNoZSIsIlJTQ1dyYXBwZXIiLCJjYWNoZUtleSIsInNlcmlhbGl6ZWQiLCJfZnJlc2giLCJjcmVhdGVGcm9tRmV0Y2giLCJyZXNwb25zZSIsInQiLCJUcmFuc2Zvcm1TdHJlYW0iLCJnZXRXcml0ZXIiLCJ3cml0ZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYm9keSIsInJlYWRhYmxlIiwiZmxpZ2h0UmVxVXJsIiwiZmV0Y2giLCJyb290IiwicmVhZFJvb3QiLCJ1c2VSb3V0ZXIiLCJfX2ZsaWdodF9zZXJpYWxpemVkX18iLCJfX2ZsaWdodF9mcmVzaF9fIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwib25IZWFkQ29tbWl0IiwiY2FuY2VsZWQiLCJkZXNpcmVkSHJlZnMiLCJzIiwiaWR4IiwicmVtb3ZlQXR0cmlidXRlIiwicmVmZXJlbmNlTm9kZSIsInRhcmdldFRhZyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsInJlbW92ZUNoaWxkIiwic2Nyb2xsVG8iLCJ4IiwieSIsIm9uUm9vdENvbW1pdCIsInJlc29sdmVQcm9taXNlIiwiX19OX1JTQyIsImlzUlNDIiwicmVuZGVyUHJvbWlzZSIsImVsZW0iLCJGcmFnbWVudCIsIkhlYWQiLCJjYWxsYmFjayIsIlBvcnRhbCIsInR5cGUiLCJSb3V0ZUFubm91bmNlciIsIlJvb3QiLCJjYWxsYmFja3MiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwidXNlTGF5b3V0RWZmZWN0IiwiX19ORVhUX1RFU1RfTU9ERSIsInVzZUVmZmVjdCIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9DQiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n        for(var i = 0, arr2 = new Array(arr.length); i < arr.length; i++){\n            arr2[i] = arr[i];\n        }\n        return arr2;\n    }\n}\nfunction _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nvar _ = __webpack_require__(/*! ./ */ \"./node_modules/next/dist/client/index.js\");\nvar _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nvar _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ \"./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\"));\nvar _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ \"./node_modules/next/dist/client/dev/dev-build-watcher.js\"));\nvar _fouc = __webpack_require__(/*! ./dev/fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nvar _websocket = __webpack_require__(/*! ./dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar assetPrefix = window.__NEXT_DATA__.assetPrefix;\nvar prefix = assetPrefix || '';\nvar webpackHMR = (0, _webpackHotMiddlewareClient).default();\n(0, _websocket).connectHMR({\n    assetPrefix: prefix,\n    path: '/_next/webpack-hmr'\n});\nif (!window._nextSetupHydrationWarning) {\n    var origConsoleError = window.console.error;\n    window.console.error = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var isHydrateError = args.some(function(arg) {\n            return typeof arg === 'string' && arg.match(/Warning:.*?did not match.*?Server:/);\n        });\n        if (isHydrateError) {\n            args = _toConsumableArray(args).concat([\n                \"\\n\\nSee more info here: https://nextjs.org/docs/messages/react-hydration-error\", \n            ]);\n        }\n        origConsoleError.apply(window.console, args);\n    };\n    window._nextSetupHydrationWarning = true;\n}\nwindow.next = {\n    version: _.version,\n    // router is initialized later so it has to be live-binded\n    get router () {\n        return _.router;\n    },\n    emitter: _.emitter,\n    render: _.render,\n    renderError: _.renderError\n};\n(0, _).initNext({\n    webpackHMR: webpackHMR\n}).then(function(param) {\n    var renderCtx = param.renderCtx;\n    var devPagesManifestListener = function devPagesManifestListener(event) {\n        if (event.data.indexOf('devPagesManifest') !== -1) {\n            fetch(\"\".concat(prefix, \"/_next/static/development/_devPagesManifest.json\")).then(function(res) {\n                return res.json();\n            }).then(function(manifest) {\n                window.__DEV_PAGES_MANIFEST = manifest;\n            }).catch(function(err) {\n                console.log(\"Failed to fetch devPagesManifest\", err);\n            });\n        } else if (event.data.indexOf('middlewareChanges') !== -1) {\n            return window.location.reload();\n        } else if (event.data.indexOf('serverOnlyChanges') !== -1) {\n            var pages = JSON.parse(event.data).pages;\n            // Make sure to reload when the dev-overlay is showing for an\n            // API route\n            if (pages.includes(_.router.query.__NEXT_PAGE)) {\n                return window.location.reload();\n            }\n            if (!_.router.clc && pages.includes(_.router.pathname)) {\n                console.log('Refreshing page data due to server-side change');\n                buildIndicatorHandler('building');\n                var clearIndicator = function() {\n                    return buildIndicatorHandler('built');\n                };\n                _.router.replace(_.router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(_.router.query), new URLSearchParams(location.search))), _.router.asPath).finally(clearIndicator);\n            }\n        }\n    };\n    (0, _onDemandEntriesClient).default();\n    var buildIndicatorHandler = function() {\n    };\n    (0, _websocket).addMessageListener(devPagesManifestListener);\n    if (true) {\n        (0, _devBuildWatcher).default(function(handler) {\n            buildIndicatorHandler = handler;\n        }, \"bottom-right\");\n    }\n    // delay rendering until after styles have been applied in development\n    (0, _fouc).displayContent(function() {\n        (0, _).render(renderCtx);\n    });\n}).catch(function(err) {\n    console.error('Error was not caught', err);\n}); //# sourceMappingURL=next-dev.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNaLEdBQUcsQ0FBQ0EsQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLG9EQUFJO0FBQ3BCLEdBQUcsQ0FBQ0Msc0JBQXNCLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVHQUFnQztBQUM1RixHQUFHLENBQUNHLDJCQUEyQixHQUFHRCxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyxpSEFBcUM7QUFDdEcsR0FBRyxDQUFDSSxnQkFBZ0IsR0FBR0Ysc0JBQXNCLENBQUNGLG1CQUFPLENBQUMseUZBQXlCO0FBQy9FLEdBQUcsQ0FBQ0ssS0FBSyxHQUFHTCxtQkFBTyxDQUFDLCtEQUFZO0FBQ2hDLEdBQUcsQ0FBQ00sVUFBVSxHQUFHTixtQkFBTyxDQUFDLHFHQUErQjtBQUN4RCxHQUFHLENBQUNPLFlBQVksR0FBR1AsbUJBQU8sQ0FBQywrR0FBd0M7U0FDMURFLHNCQUFzQixDQUFDTSxHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLENBQUNBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEdBQUdELEdBQUcsR0FBRyxDQUFDO1FBQ2xDRSxPQUFPLEVBQUVGLEdBQUc7SUFDaEIsQ0FBQztBQUNMLENBQUM7QUFDRCxHQUFLLENBQW9CRyxXQUFXLEdBQVdDLE1BQU0sQ0FBN0NDLGFBQWEsQ0FBSUYsV0FBVztBQUNwQyxHQUFLLENBQUNHLE1BQU0sR0FBR0gsV0FBVyxJQUFJLENBQUU7QUFDaEMsR0FBSyxDQUFDSSxVQUFVLElBQUksQ0FBQyxFQUFFWiwyQkFBMkIsRUFBRU8sT0FBTztDQUMxRCxDQUFDLEVBQUVKLFVBQVUsRUFBRVUsVUFBVSxDQUFDLENBQUM7SUFDeEJMLFdBQVcsRUFBRUcsTUFBTTtJQUNuQkcsSUFBSSxFQUFFLENBQW9CO0FBQzlCLENBQUM7QUFDRCxFQUFFLEdBQUdMLE1BQU0sQ0FBQ00sMEJBQTBC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QUFDLEVBQUVqRSxLQUFLLEVBQUVzRSxjQUFjLENBQUMsUUFDNUIsR0FEZ0MsQ0FBQztTQUMxQixDQUFDLEVBQUU1RSxDQUFDLEVBQUVpQyxNQUFNLENBQUNJLFNBQVM7SUFDM0IsQ0FBQztBQUNMLENBQUMsRUFBRVUsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7SUFDYjNCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLENBQXNCLHVCQUFFMEIsR0FBRztBQUM3QyxDQUFDLEVBRUQsQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbmV4dC1kZXYuanM/MzUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfID0gcmVxdWlyZShcIi4vXCIpO1xudmFyIF9vbkRlbWFuZEVudHJpZXNDbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO1xudmFyIF93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50XCIpKTtcbnZhciBfZGV2QnVpbGRXYXRjaGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvZGV2LWJ1aWxkLXdhdGNoZXJcIikpO1xudmFyIF9mb3VjID0gcmVxdWlyZShcIi4vZGV2L2ZvdWNcIik7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Rldi9lcnJvci1vdmVybGF5L3dlYnNvY2tldFwiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmdcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5jb25zdCB7IF9fTkVYVF9EQVRBX186IHsgYXNzZXRQcmVmaXggIH0gLCAgfSA9IHdpbmRvdztcbmNvbnN0IHByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnO1xuY29uc3Qgd2VicGFja0hNUiA9ICgwLCBfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQpLmRlZmF1bHQoKTtcbigwLCBfd2Vic29ja2V0KS5jb25uZWN0SE1SKHtcbiAgICBhc3NldFByZWZpeDogcHJlZml4LFxuICAgIHBhdGg6ICcvX25leHQvd2VicGFjay1obXInXG59KTtcbmlmICghd2luZG93Ll9uZXh0U2V0dXBIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgY29uc3Qgb3JpZ0NvbnNvbGVFcnJvciA9IHdpbmRvdy5jb25zb2xlLmVycm9yO1xuICAgIHdpbmRvdy5jb25zb2xlLmVycm9yID0gKC4uLmFyZ3MpPT57XG4gICAgICAgIGNvbnN0IGlzSHlkcmF0ZUVycm9yID0gYXJncy5zb21lKChhcmcpPT50eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBhcmcubWF0Y2goL1dhcm5pbmc6Lio/ZGlkIG5vdCBtYXRjaC4qP1NlcnZlcjovKVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNIeWRyYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgICAgICBgXFxuXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9yZWFjdC1oeWRyYXRpb24tZXJyb3JgLCBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ0NvbnNvbGVFcnJvci5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncyk7XG4gICAgfTtcbiAgICB3aW5kb3cuX25leHRTZXR1cEh5ZHJhdGlvbldhcm5pbmcgPSB0cnVlO1xufVxud2luZG93Lm5leHQgPSB7XG4gICAgdmVyc2lvbjogXy52ZXJzaW9uLFxuICAgIC8vIHJvdXRlciBpcyBpbml0aWFsaXplZCBsYXRlciBzbyBpdCBoYXMgdG8gYmUgbGl2ZS1iaW5kZWRcbiAgICBnZXQgcm91dGVyICgpIHtcbiAgICAgICAgcmV0dXJuIF8ucm91dGVyO1xuICAgIH0sXG4gICAgZW1pdHRlcjogXy5lbWl0dGVyLFxuICAgIHJlbmRlcjogXy5yZW5kZXIsXG4gICAgcmVuZGVyRXJyb3I6IF8ucmVuZGVyRXJyb3Jcbn07XG4oMCwgXykuaW5pdE5leHQoe1xuICAgIHdlYnBhY2tITVJcbn0pLnRoZW4oKHsgcmVuZGVyQ3R4ICB9KT0+e1xuICAgICgwLCBfb25EZW1hbmRFbnRyaWVzQ2xpZW50KS5kZWZhdWx0KCk7XG4gICAgbGV0IGJ1aWxkSW5kaWNhdG9ySGFuZGxlciA9ICgpPT57XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZXZQYWdlc01hbmlmZXN0TGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignZGV2UGFnZXNNYW5pZmVzdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgZmV0Y2goYCR7cHJlZml4fS9fbmV4dC9zdGF0aWMvZGV2ZWxvcG1lbnQvX2RldlBhZ2VzTWFuaWZlc3QuanNvbmApLnRoZW4oKHJlcyk9PnJlcy5qc29uKClcbiAgICAgICAgICAgICkudGhlbigobWFuaWZlc3QpPT57XG4gICAgICAgICAgICAgICAgd2luZG93Ll9fREVWX1BBR0VTX01BTklGRVNUID0gbWFuaWZlc3Q7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gZmV0Y2ggZGV2UGFnZXNNYW5pZmVzdGAsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ21pZGRsZXdhcmVDaGFuZ2VzJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignc2VydmVyT25seUNoYW5nZXMnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFnZXMgIH0gPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvIHJlbG9hZCB3aGVuIHRoZSBkZXYtb3ZlcmxheSBpcyBzaG93aW5nIGZvciBhblxuICAgICAgICAgICAgLy8gQVBJIHJvdXRlXG4gICAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMoXy5yb3V0ZXIucXVlcnkuX19ORVhUX1BBR0UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5yb3V0ZXIuY2xjICYmIHBhZ2VzLmluY2x1ZGVzKF8ucm91dGVyLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWZyZXNoaW5nIHBhZ2UgZGF0YSBkdWUgdG8gc2VydmVyLXNpZGUgY2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgYnVpbGRJbmRpY2F0b3JIYW5kbGVyKCdidWlsZGluZycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFySW5kaWNhdG9yID0gKCk9PmJ1aWxkSW5kaWNhdG9ySGFuZGxlcignYnVpbHQnKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBfLnJvdXRlci5yZXBsYWNlKF8ucm91dGVyLnBhdGhuYW1lICsgJz8nICsgU3RyaW5nKCgwLCBfcXVlcnlzdHJpbmcpLmFzc2lnbigoMCwgX3F1ZXJ5c3RyaW5nKS51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKF8ucm91dGVyLnF1ZXJ5KSwgbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpKSksIF8ucm91dGVyLmFzUGF0aCkuZmluYWxseShjbGVhckluZGljYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIF93ZWJzb2NrZXQpLmFkZE1lc3NhZ2VMaXN0ZW5lcihkZXZQYWdlc01hbmlmZXN0TGlzdGVuZXIpO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQlVJTERfSU5ESUNBVE9SKSB7XG4gICAgICAgICgwLCBfZGV2QnVpbGRXYXRjaGVyKS5kZWZhdWx0KChoYW5kbGVyKT0+e1xuICAgICAgICAgICAgYnVpbGRJbmRpY2F0b3JIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX0JVSUxEX0lORElDQVRPUl9QT1NJVElPTik7XG4gICAgfVxuICAgIC8vIGRlbGF5IHJlbmRlcmluZyB1bnRpbCBhZnRlciBzdHlsZXMgaGF2ZSBiZWVuIGFwcGxpZWQgaW4gZGV2ZWxvcG1lbnRcbiAgICAoMCwgX2ZvdWMpLmRpc3BsYXlDb250ZW50KCgpPT57XG4gICAgICAgICgwLCBfKS5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICB9KTtcbn0pLmNhdGNoKChlcnIpPT57XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igd2FzIG5vdCBjYXVnaHQnLCBlcnIpO1xufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQtZGV2LmpzLm1hcCJdLCJuYW1lcyI6WyJfIiwicmVxdWlyZSIsIl9vbkRlbWFuZEVudHJpZXNDbGllbnQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3dlYnBhY2tIb3RNaWRkbGV3YXJlQ2xpZW50IiwiX2RldkJ1aWxkV2F0Y2hlciIsIl9mb3VjIiwiX3dlYnNvY2tldCIsIl9xdWVyeXN0cmluZyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiYXNzZXRQcmVmaXgiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwicHJlZml4Iiwid2VicGFja0hNUiIsImNvbm5lY3RITVIiLCJwYXRoIiwiX25leHRTZXR1cEh5ZHJhdGlvbldhcm5pbmciLCJvcmlnQ29uc29sZUVycm9yIiwiY29uc29sZSIsImVycm9yIiwiYXJncyIsImlzSHlkcmF0ZUVycm9yIiwic29tZSIsImFyZyIsIm1hdGNoIiwiYXBwbHkiLCJuZXh0IiwidmVyc2lvbiIsInJvdXRlciIsImVtaXR0ZXIiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsImluaXROZXh0IiwidGhlbiIsInJlbmRlckN0eCIsImRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsImluZGV4T2YiLCJmZXRjaCIsInJlcyIsImpzb24iLCJtYW5pZmVzdCIsIl9fREVWX1BBR0VTX01BTklGRVNUIiwiY2F0Y2giLCJlcnIiLCJsb2ciLCJsb2NhdGlvbiIsInJlbG9hZCIsInBhZ2VzIiwiSlNPTiIsInBhcnNlIiwiaW5jbHVkZXMiLCJxdWVyeSIsIl9fTkVYVF9QQUdFIiwiY2xjIiwicGF0aG5hbWUiLCJidWlsZEluZGljYXRvckhhbmRsZXIiLCJjbGVhckluZGljYXRvciIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiYXNQYXRoIiwiZmluYWxseSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQlVJTERfSU5ESUNBVE9SIiwiaGFuZGxlciIsIl9fTkVYVF9CVUlMRF9JTkRJQ0FUT1JfUE9TSVRJT04iLCJkaXNwbGF5Q29udGVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/next-dev.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ../shared/lib/router/utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ./route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction normalizeRoute(route) {\n    if (route[0] !== '/') {\n        throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\".concat(route, \"\\\"\"));\n    }\n    if (route === '/') return route;\n    return route.replace(/\\/$/, '');\n}\nvar PageLoader = /*#__PURE__*/ function() {\n    function PageLoader(buildId, assetPrefix) {\n        _classCallCheck(this, PageLoader);\n        this.routeLoader = (0, _routeLoader).createRouteLoader(assetPrefix);\n        this.buildId = buildId;\n        this.assetPrefix = assetPrefix;\n        this.promisedSsgManifest = new Promise(function(resolve) {\n            if (window.__SSG_MANIFEST) {\n                resolve(window.__SSG_MANIFEST);\n            } else {\n                window.__SSG_MANIFEST_CB = function() {\n                    resolve(window.__SSG_MANIFEST);\n                };\n            }\n        });\n    }\n    _createClass(PageLoader, [\n        {\n            key: \"getPageList\",\n            value: function getPageList() {\n                if (false) {} else {\n                    if (window.__DEV_PAGES_MANIFEST) {\n                        return window.__DEV_PAGES_MANIFEST.pages;\n                    } else {\n                        if (!this.promisedDevPagesManifest) {\n                            // TODO: Decide what should happen when fetching fails instead of asserting\n                            // @ts-ignore\n                            this.promisedDevPagesManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/development/_devPagesManifest.json\")).then(function(res) {\n                                return res.json();\n                            }).then(function(manifest) {\n                                window.__DEV_PAGES_MANIFEST = manifest;\n                                return manifest.pages;\n                            }).catch(function(err) {\n                                console.log(\"Failed to fetch devPagesManifest\", err);\n                            });\n                        }\n                        // TODO Remove this assertion as this could be undefined\n                        return this.promisedDevPagesManifest;\n                    }\n                }\n            }\n        },\n        {\n            key: \"getMiddlewareList\",\n            value: function getMiddlewareList() {\n                if (false) {} else {\n                    if (window.__DEV_MIDDLEWARE_MANIFEST) {\n                        return window.__DEV_MIDDLEWARE_MANIFEST;\n                    } else {\n                        if (!this.promisedMiddlewareManifest) {\n                            // TODO: Decide what should happen when fetching fails instead of asserting\n                            // @ts-ignore\n                            this.promisedMiddlewareManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/\").concat(this.buildId, \"/_devMiddlewareManifest.json\")).then(function(res) {\n                                return res.json();\n                            }).then(function(manifest) {\n                                window.__DEV_MIDDLEWARE_MANIFEST = manifest;\n                                return manifest;\n                            }).catch(function(err) {\n                                console.log(\"Failed to fetch _devMiddlewareManifest\", err);\n                            });\n                        }\n                        // TODO Remove this assertion as this could be undefined\n                        return this.promisedMiddlewareManifest;\n                    }\n                }\n            }\n        },\n        {\n            /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   * @returns {string}\n   */ key: \"getDataHref\",\n            value: function getDataHref(param) {\n                var href = param.href, asPath = param.asPath, ssg = param.ssg, rsc = param.rsc, locale = param.locale;\n                var _this = this;\n                var ref = (0, _parseRelativeUrl).parseRelativeUrl(href), hrefPathname = ref.pathname, query = ref.query, search = ref.search;\n                var ref1 = (0, _parseRelativeUrl).parseRelativeUrl(asPath), asPathname = ref1.pathname;\n                var route = normalizeRoute(hrefPathname);\n                var getHrefForSlug = function(path) {\n                    if (rsc) return path + '?__flight__';\n                    var dataRoute = (0, _getAssetPathFromRoute).default((0, _normalizeTrailingSlash).removePathTrailingSlash((0, _router).addLocale(path, locale)), '.json');\n                    return (0, _router).addBasePath(\"/_next/data/\".concat(_this.buildId).concat(dataRoute).concat(ssg ? '' : search));\n                };\n                var isDynamic = (0, _isDynamic).isDynamicRoute(route);\n                var interpolatedRoute = isDynamic ? (0, _router).interpolateAs(hrefPathname, asPathname, query).result : '';\n                return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n            }\n        },\n        {\n            /**\n   * @param {string} route - the route (file-system path)\n   */ key: \"_isSsg\",\n            value: function _isSsg(route) {\n                return this.promisedSsgManifest.then(function(manifest) {\n                    return manifest.has(route);\n                });\n            }\n        },\n        {\n            key: \"loadPage\",\n            value: function loadPage(route) {\n                return this.routeLoader.loadRoute(route).then(function(res) {\n                    if ('component' in res) {\n                        return {\n                            page: res.component,\n                            mod: res.exports,\n                            styleSheets: res.styles.map(function(o) {\n                                return {\n                                    href: o.href,\n                                    text: o.content\n                                };\n                            })\n                        };\n                    }\n                    throw res.error;\n                });\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: function prefetch(route) {\n                return this.routeLoader.prefetch(route);\n            }\n        }\n    ]);\n    return PageLoader;\n}();\nexports[\"default\"] = PageLoader; //# sourceMappingURL=page-loader.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3hCLEdBQUcsQ0FBQ0csT0FBTyxHQUFHQyxtQkFBTyxDQUFDLHlGQUE2QjtBQUNuRCxHQUFHLENBQUNDLHNCQUFzQixHQUFHQyxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQywySUFBc0Q7QUFDbEgsR0FBRyxDQUFDRyxVQUFVLEdBQUdILG1CQUFPLENBQUMsNkdBQXVDO0FBQ2hFLEdBQUcsQ0FBQ0ksaUJBQWlCLEdBQUdKLG1CQUFPLENBQUMsNkhBQStDO0FBQy9FLEdBQUcsQ0FBQ0ssdUJBQXVCLEdBQUdMLG1CQUFPLENBQUMsK0ZBQTRCO0FBQ2xFLEdBQUcsQ0FBQ00sWUFBWSxHQUFHTixtQkFBTyxDQUFDLHVFQUFnQjtTQUNsQ0Usc0JBQXNCLENBQUNLLEdBQUcsRUFBRSxDQUFDO0lBQ2xDLE1BQU0sQ0FBQ0EsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsR0FBR0QsR0FBRyxHQUFHLENBQUM7UUFDbENULE9BQU8sRUFBRVMsR0FBRztJQUNoQixDQUFDO0FBQ0wsQ0FBQztTQUNRRSxjQUFjLENBQUNDLEtBQUssRUFBRSxDQUFDO0lBQzVCLEVBQUUsRUFBRUEsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFHLElBQUUsQ0FBQztRQUNuQixLQUFLLENBQUMsR0FBRyxDQUFDQyxLQUFLLENBQUUsQ0FBeUMsOENBQVEsTUFBQyxDQUFQRCxLQUFLLEVBQUMsQ0FBQztJQUN2RSxDQUFDO0lBQ0QsRUFBRSxFQUFFQSxLQUFLLEtBQUssQ0FBRyxJQUFFLE1BQU0sQ0FBQ0EsS0FBSztJQUMvQixNQUFNLENBQUNBLEtBQUssQ0FBQ0UsT0FBTyxRQUFRLENBQUU7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LENBQVE7bUJBQVJBLFFBQVEsQ0FBUkEsUUFBUSxDQUFDMUQsS0FBSyxFQUFFLENBQUM7Z0JBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQ00sV0FBVyxDQUFDcUQsU0FBUyxDQUFDM0QsS0FBSyxFQUFFZ0IsSUFBSSxDQUFDLFFBQVEsQ0FBUE8sR0FBRyxFQUFHLENBQUM7b0JBQ2xELEVBQUUsRUFBRSxDQUFXLGNBQUlBLEdBQUcsRUFBRSxDQUFDO3dCQUNyQixNQUFNLENBQUMsQ0FBQzs0QkFDSnFDLElBQUksRUFBRXJDLEdBQUcsQ0FBQ3NDLFNBQVM7NEJBQ25CQyxHQUFHLEVBQUV2QyxHQUFHLENBQUNyQyxPQUFPOzRCQUNoQjZFLFdBQVcsRUFBRXhDLEdBQUcsQ0FBQ3lDLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDLFFBQ2hELENBRGlEQyxDQUFDO2dDQUFHLE1BQ2xELENBRG1ELENBQUM7b0NBQzNCaEMsSUFBSSxFQUFFZ0MsQ0FBQyxDQUFDaEMsSUFBSTtvQ0FDWmlDLElBQUksRUFBRUQsQ0FBQyxDQUFDRSxPQUFPO2dDQUNuQixDQUFDOzt3QkFFVCxDQUFDO29CQUNMLENBQUM7b0JBQ0QsS0FBSyxDQUFDN0MsR0FBRyxDQUFDOEMsS0FBSztnQkFDbkIsQ0FBQztZQUNMLENBQUM7OztZQUNEQyxHQUFRLEVBQVJBLENBQVE7bUJBQVJBLFFBQVEsQ0FBUkEsUUFBUSxDQUFDdEUsS0FBSyxFQUFFLENBQUM7Z0JBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQ00sV0FBVyxDQUFDZ0UsUUFBUSxDQUFDdEUsS0FBSztZQUMxQyxDQUFDOzs7V0F6RkNHLFVBQVU7O0FBeUdoQmpCLGtCQUFlLEdBQUdpQixVQUFVLENBRTVCLENBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3BhZ2UtbG9hZGVyLmpzP2U4N2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXJcIik7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcGFyc2VSZWxhdGl2ZVVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG52YXIgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX3JvdXRlTG9hZGVyID0gcmVxdWlyZShcIi4vcm91dGUtbG9hZGVyXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUm91dGUocm91dGUpIHtcbiAgICBpZiAocm91dGVbMF0gIT09ICcvJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYSBcIi9cIiwgZ290IFwiJHtyb3V0ZX1cImApO1xuICAgIH1cbiAgICBpZiAocm91dGUgPT09ICcvJykgcmV0dXJuIHJvdXRlO1xuICAgIHJldHVybiByb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpO1xufVxuY2xhc3MgUGFnZUxvYWRlciB7XG4gICAgZ2V0UGFnZUxpc3QoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+bWFuaWZlc3Quc29ydGVkUGFnZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fREVWX1BBR0VTX01BTklGRVNUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVC5wYWdlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb21pc2VkRGV2UGFnZXNNYW5pZmVzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBEZWNpZGUgd2hhdCBzaG91bGQgaGFwcGVuIHdoZW4gZmV0Y2hpbmcgZmFpbHMgaW5zdGVhZCBvZiBhc3NlcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VkRGV2UGFnZXNNYW5pZmVzdCA9IGZldGNoKGAke3RoaXMuYXNzZXRQcmVmaXh9L19uZXh0L3N0YXRpYy9kZXZlbG9wbWVudC9fZGV2UGFnZXNNYW5pZmVzdC5qc29uYCkudGhlbigocmVzKT0+cmVzLmpzb24oKVxuICAgICAgICAgICAgICAgICAgICApLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Ll9fREVWX1BBR0VTX01BTklGRVNUID0gbWFuaWZlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QucGFnZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGZldGNoIGRldlBhZ2VzTWFuaWZlc3RgLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBSZW1vdmUgdGhpcyBhc3NlcnRpb24gYXMgdGhpcyBjb3VsZCBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlZERldlBhZ2VzTWFuaWZlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWlkZGxld2FyZUxpc3QoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yb3V0ZUxvYWRlcikuZ2V0TWlkZGxld2FyZU1hbmlmZXN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fREVWX01JRERMRVdBUkVfTUFOSUZFU1QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93Ll9fREVWX01JRERMRVdBUkVfTUFOSUZFU1Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9taXNlZE1pZGRsZXdhcmVNYW5pZmVzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBEZWNpZGUgd2hhdCBzaG91bGQgaGFwcGVuIHdoZW4gZmV0Y2hpbmcgZmFpbHMgaW5zdGVhZCBvZiBhc3NlcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hbmlmZXN0ID0gZmV0Y2goYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvc3RhdGljLyR7dGhpcy5idWlsZElkfS9fZGV2TWlkZGxld2FyZU1hbmlmZXN0Lmpzb25gKS50aGVuKChyZXMpPT5yZXMuanNvbigpXG4gICAgICAgICAgICAgICAgICAgICkudGhlbigobWFuaWZlc3QpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuX19ERVZfTUlERExFV0FSRV9NQU5JRkVTVCA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBfZGV2TWlkZGxld2FyZU1hbmlmZXN0YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gUmVtb3ZlIHRoaXMgYXNzZXJ0aW9uIGFzIHRoaXMgY291bGQgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZWRNaWRkbGV3YXJlTWFuaWZlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIHRoZSByb3V0ZSBocmVmIChmaWxlLXN5c3RlbSBwYXRoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXNQYXRoIHRoZSBVUkwgYXMgc2hvd24gaW4gYnJvd3NlciAodmlydHVhbCBwYXRoKTsgdXNlZCBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovIGdldERhdGFIcmVmKHsgaHJlZiAsIGFzUGF0aCAsIHNzZyAsIHJzYyAsIGxvY2FsZSAgfSkge1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lOiBocmVmUGF0aG5hbWUgLCBxdWVyeSAsIHNlYXJjaCAgfSA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChocmVmKTtcbiAgICAgICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpO1xuICAgICAgICBjb25zdCByb3V0ZSA9IG5vcm1hbGl6ZVJvdXRlKGhyZWZQYXRobmFtZSk7XG4gICAgICAgIGNvbnN0IGdldEhyZWZGb3JTbHVnID0gKHBhdGgpPT57XG4gICAgICAgICAgICBpZiAocnNjKSByZXR1cm4gcGF0aCArICc/X19mbGlnaHRfXyc7XG4gICAgICAgICAgICBjb25zdCBkYXRhUm91dGUgPSAoMCwgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSkuZGVmYXVsdCgoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKCgwLCBfcm91dGVyKS5hZGRMb2NhbGUocGF0aCwgbG9jYWxlKSksICcuanNvbicpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcm91dGVyKS5hZGRCYXNlUGF0aChgL19uZXh0L2RhdGEvJHt0aGlzLmJ1aWxkSWR9JHtkYXRhUm91dGV9JHtzc2cgPyAnJyA6IHNlYXJjaH1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXNEeW5hbWljID0gKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHJvdXRlKTtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkUm91dGUgPSBpc0R5bmFtaWMgPyAoMCwgX3JvdXRlcikuaW50ZXJwb2xhdGVBcyhocmVmUGF0aG5hbWUsIGFzUGF0aG5hbWUsIHF1ZXJ5KS5yZXN1bHQgOiAnJztcbiAgICAgICAgcmV0dXJuIGlzRHluYW1pYyA/IGludGVycG9sYXRlZFJvdXRlICYmIGdldEhyZWZGb3JTbHVnKGludGVycG9sYXRlZFJvdXRlKSA6IGdldEhyZWZGb3JTbHVnKHJvdXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZSAtIHRoZSByb3V0ZSAoZmlsZS1zeXN0ZW0gcGF0aClcbiAgICovIF9pc1NzZyhyb3V0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlZFNzZ01hbmlmZXN0LnRoZW4oKG1hbmlmZXN0KT0+bWFuaWZlc3QuaGFzKHJvdXRlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBsb2FkUGFnZShyb3V0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5sb2FkUm91dGUocm91dGUpLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICgnY29tcG9uZW50JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiByZXMuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBtb2Q6IHJlcy5leHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlcy5tYXAoKG8pPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IG8uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBvLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJlZmV0Y2gocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVMb2FkZXIucHJlZmV0Y2gocm91dGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihidWlsZElkLCBhc3NldFByZWZpeCl7XG4gICAgICAgIHRoaXMucm91dGVMb2FkZXIgPSAoMCwgX3JvdXRlTG9hZGVyKS5jcmVhdGVSb3V0ZUxvYWRlcihhc3NldFByZWZpeCk7XG4gICAgICAgIHRoaXMuYnVpbGRJZCA9IGJ1aWxkSWQ7XG4gICAgICAgIHRoaXMuYXNzZXRQcmVmaXggPSBhc3NldFByZWZpeDtcbiAgICAgICAgdGhpcy5wcm9taXNlZFNzZ01hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fU1NHX01BTklGRVNUKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh3aW5kb3cuX19TU0dfTUFOSUZFU1QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19TU0dfTUFOSUZFU1RfQ0IgPSAoKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGFnZUxvYWRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9yb3V0ZXIiLCJyZXF1aXJlIiwiX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaXNEeW5hbWljIiwiX3BhcnNlUmVsYXRpdmVVcmwiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsIl9yb3V0ZUxvYWRlciIsIm9iaiIsIl9fZXNNb2R1bGUiLCJub3JtYWxpemVSb3V0ZSIsInJvdXRlIiwiRXJyb3IiLCJyZXBsYWNlIiwiUGFnZUxvYWRlciIsImJ1aWxkSWQiLCJhc3NldFByZWZpeCIsInJvdXRlTG9hZGVyIiwiY3JlYXRlUm91dGVMb2FkZXIiLCJwcm9taXNlZFNzZ01hbmlmZXN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ3aW5kb3ciLCJfX1NTR19NQU5JRkVTVCIsIl9fU1NHX01BTklGRVNUX0NCIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwidGhlbiIsIm1hbmlmZXN0Iiwic29ydGVkUGFnZXMiLCJfX0RFVl9QQUdFU19NQU5JRkVTVCIsInBhZ2VzIiwicHJvbWlzZWREZXZQYWdlc01hbmlmZXN0IiwiZmV0Y2giLCJyZXMiLCJqc29uIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwibG9nIiwiZ2V0TWlkZGxld2FyZUxpc3QiLCJnZXRNaWRkbGV3YXJlTWFuaWZlc3QiLCJfX0RFVl9NSURETEVXQVJFX01BTklGRVNUIiwicHJvbWlzZWRNaWRkbGV3YXJlTWFuaWZlc3QiLCJnZXREYXRhSHJlZiIsImhyZWYiLCJhc1BhdGgiLCJzc2ciLCJyc2MiLCJsb2NhbGUiLCJwYXJzZVJlbGF0aXZlVXJsIiwiaHJlZlBhdGhuYW1lIiwicGF0aG5hbWUiLCJxdWVyeSIsInNlYXJjaCIsImFzUGF0aG5hbWUiLCJnZXRIcmVmRm9yU2x1ZyIsInBhdGgiLCJkYXRhUm91dGUiLCJyZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCIsImFkZExvY2FsZSIsImFkZEJhc2VQYXRoIiwiaXNEeW5hbWljIiwiaXNEeW5hbWljUm91dGUiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImludGVycG9sYXRlQXMiLCJyZXN1bHQiLCJfaXNTc2ciLCJoYXMiLCJsb2FkUGFnZSIsImxvYWRSb3V0ZSIsInBhZ2UiLCJjb21wb25lbnQiLCJtb2QiLCJzdHlsZVNoZWV0cyIsInN0eWxlcyIsIm1hcCIsIm8iLCJ0ZXh0IiwiY29udGVudCIsImVycm9yIiwicHJlZmV0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/page-loader.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nvar MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    var entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    var resolver;\n    var prom = new Promise(function(resolve) {\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator() // eslint-disable-next-line no-sequences\n    .then(function(value) {\n        return resolver(value), value;\n    }).catch(function(err) {\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// with relList.support\n        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nvar canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise(function(res, rej) {\n        var selector = \"\\n      link[rel=\\\"prefetch\\\"][href^=\\\"\".concat(href, \"\\\"],\\n      link[rel=\\\"preload\\\"][href^=\\\"\").concat(href, \"\\\"],\\n      script[src^=\\\"\").concat(href, \"\\\"]\");\n        if (document.querySelector(selector)) {\n            return res();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = \"prefetch\";\n        link.crossOrigin = undefined;\n        link.onload = res;\n        link.onerror = rej;\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nvar ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {\n    });\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction appendScript(src, script) {\n    return new Promise(function(resolve, reject) {\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = function() {\n            return reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n        };\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = undefined;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nvar devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise(function(resolve, reject) {\n        var cancelled = false;\n        p.then(function(r) {\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (true) {\n            (devBuildPromise || Promise.resolve()).then(function() {\n                (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return setTimeout(function() {\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms);\n                });\n            });\n        }\n        if (false) {}\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    var onBuildManifest = new Promise(function(resolve) {\n        // Mandatory because this is not concurrent safe:\n        var cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = function() {\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getMiddlewareManifest() {\n    if (self.__MIDDLEWARE_MANIFEST) {\n        return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n    }\n    var onMiddlewareManifest = new Promise(function(resolve) {\n        var cb = self.__MIDDLEWARE_MANIFEST_CB;\n        self.__MIDDLEWARE_MANIFEST_CB = function() {\n            resolve(self.__MIDDLEWARE_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (true) {\n        return Promise.resolve({\n            scripts: [\n                assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js')), \n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then(function(manifest) {\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n        }\n        var allFiles = manifest[route].map(function(entry) {\n            return assetPrefix + '/_next/' + encodeURI(entry);\n        });\n        return {\n            scripts: allFiles.filter(function(v) {\n                return v.endsWith('.js');\n            }),\n            css: allFiles.filter(function(v) {\n                return v.endsWith('.css');\n            })\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    var maybeExecuteScript = function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (false) { var prom; } else {\n            return appendScript(src);\n        }\n    };\n    var fetchStyleSheet = function fetchStyleSheet(href) {\n        var prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then(function(res) {\n            if (!res.ok) {\n                throw new Error(\"Failed to load stylesheet: \".concat(href));\n            }\n            return res.text().then(function(text) {\n                return {\n                    href: href,\n                    content: text\n                };\n            });\n        }).catch(function(err) {\n            throw markAssetError(err);\n        }));\n        return prom;\n    };\n    var entrypoints = new Map();\n    var loadedScripts = new Map();\n    var styleSheets = new Map();\n    var routes = new Map();\n    return {\n        whenEntrypoint: function(route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint: function(route, execute) {\n            (execute ? Promise.resolve().then(function() {\n                return execute();\n            }).then(function(exports) {\n                return {\n                    component: exports && exports.default || exports,\n                    exports: exports\n                };\n            }, function(err) {\n                return {\n                    error: err\n                };\n            }) : Promise.resolve(undefined)).then(function(input) {\n                var old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute: function(route, prefetch) {\n            var _this = this;\n            return withFuture(route, routes, function() {\n                var _this1 = _this;\n                var devBuildPromiseResolve;\n                if (true) {\n                    devBuildPromise = new Promise(function(resolve) {\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(function(param) {\n                    var scripts = param.scripts, css = param.css;\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet)), \n                    ]);\n                }).then(function(res) {\n                    return _this1.whenEntrypoint(route).then(function(entrypoint) {\n                        return {\n                            entrypoint: entrypoint,\n                            styles: res[1]\n                        };\n                    });\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then(function(param) {\n                    var entrypoint = param.entrypoint, styles = param.styles;\n                    var res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch(function(err) {\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(function() {\n                    return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch: function(route) {\n            var _this = this;\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            var cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then(function(output) {\n                return Promise.all(canPrefetch ? output.scripts.map(function(script) {\n                    return prefetchViaDom(script, 'script');\n                }) : []);\n            }).then(function() {\n                var _this2 = _this;\n                (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return _this2.loadRoute(route, true).catch(function() {\n                    });\n                });\n            }).catch(function() {\n            });\n        }\n    };\n} //# sourceMappingURL=route-loader.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFZO0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0UsY0FBYztBQUN2Q0Ysb0JBQW9CLEdBQUdHLFlBQVk7QUFDbkNILDhCQUE4QixHQUFHSSxzQkFBc0I7QUFDdkRKLDZCQUE2QixHQUFHSyxxQkFBcUI7QUFDckRMLHlCQUF5QixHQUFHTSxpQkFBaUI7QUFDN0MsR0FBRyxDQUFDQyxzQkFBc0IsR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsMklBQXNEO0FBQ2xILEdBQUcsQ0FBQ0Msb0JBQW9CLEdBQUdELG1CQUFPLENBQUMseUZBQXlCO1NBQ25ERCxzQkFBc0IsQ0FBQ0csR0FBRyxFQUFFLENBQUM7SUFDbEMsTUFBTSxDQUFDQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHRCxHQUFHLEdBQUcsQ0FBQztRQUNsQ0UsT0FBTyxFQUFFRixHQUFHO0lBQ2hCLENBQUM7QUFDTCxDQUFDO0FBQ0QsRUFBdUU7QUFDdkUsRUFBeUU7QUFDekUsRUFBMkU7QUFDM0UsRUFBb0M7QUFDcEMsR0FBSyxDQUFDRyxpQkFBaUIsR0FBRyxJQUFJO1NBQ3JCQyxVQUFVLENBQUNDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxTQUFTLEVBQUUsQ0FBQztJQUN0QyxHQUFHLENBQUNDLEtBQUssR0FBR0YsR0FBRyxDQUFDRyxHQUFHLENBQUNKLEdBQUc7SUFDdkIsRUFBRSxFQUFFRyxLQUFLLEVBQUUsQ0FBQztRQUNSLEVBQUUsRUFBRSxDQUFRLFdBQUlBLEtBQUssRUFBRSxDQUFDO1lBQ3BCLE1BQU0sQ0FBQ0EsS0FBSyxDQUFDRSxNQUFNO1FBQ3ZCLENBQUM7UUFDRCxNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDSixLQUFLO0lBQ2hDLENBQUM7SUFDRCxHQUFH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LE9BQU87WUFDMUUsQ0FBQztZQUNELE1BQU0sQ0FBQzJELGdCQUFnQixDQUFDQyxXQUFXLEVBQUVDLEtBQUssRUFBRXpELElBQUksQ0FBQyxRQUFRLENBQVBvRyxNQUFNO2dCQUFHekcsTUFBTSxDQUFOQSxPQUFPLENBQUM2RixHQUFHLENBQUMxRSxXQUFXLEdBQUdzRixNQUFNLENBQUMxQyxPQUFPLENBQUNwRSxHQUFHLENBQUMsUUFBUSxDQUFQNkMsTUFBTTtvQkFBR3BCLE1BQU0sQ0FBTkEsY0FBYyxDQUFDb0IsTUFBTSxFQUFFLENBQVE7cUJBQ3pJLENBQUMsQ0FBQztlQUNSbkMsSUFBSSxDQUFDLFFBQ2pCLEdBRHFCLENBQUM7O2lCQUNQLENBQUMsRUFBRWpCLG9CQUFvQixFQUFFOEQsbUJBQW1CLENBQUMsUUFBUTtvQkFBSixNQUFNLFFBQUR3QyxTQUFTLENBQUM1QixLQUFLLEVBQUUsSUFBSSxFQUFFeEQsS0FBSyxDQUFDLFFBQ2xHLEdBRHNHLENBQUM7b0JBQ3JGLENBQUM7O1lBRVQsQ0FBQyxFQUFFQSxLQUFLLENBQ1IsUUFDVixHQURjLENBQUM7WUFDTCxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDLENBRXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLWxvYWRlci5qcz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXJrQXNzZXRFcnJvciA9IG1hcmtBc3NldEVycm9yO1xuZXhwb3J0cy5pc0Fzc2V0RXJyb3IgPSBpc0Fzc2V0RXJyb3I7XG5leHBvcnRzLmdldENsaWVudEJ1aWxkTWFuaWZlc3QgPSBnZXRDbGllbnRCdWlsZE1hbmlmZXN0O1xuZXhwb3J0cy5nZXRNaWRkbGV3YXJlTWFuaWZlc3QgPSBnZXRNaWRkbGV3YXJlTWFuaWZlc3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRlTG9hZGVyID0gY3JlYXRlUm91dGVMb2FkZXI7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMDtcbmZ1bmN0aW9uIHdpdGhGdXR1cmUoa2V5LCBtYXAsIGdlbmVyYXRvcikge1xuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZXI7XG4gICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbWFwLnNldChrZXksIGVudHJ5ID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcbiAgICAgICAgZnV0dXJlOiBwcm9tXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgIC50aGVuKCh2YWx1ZSk9PihyZXNvbHZlcih2YWx1ZSksIHZhbHVlKVxuICAgICkuY2F0Y2goKGVycik9PntcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkgOiBwcm9tO1xufVxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaykge1xuICAgIHRyeSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIHJldHVybigvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB8fCBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGNhblByZWZldGNoID0gaGFzUHJlZmV0Y2goKTtcbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKGhyZWYsIGFzLCBsaW5rKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaik9PntcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBgXG4gICAgICBsaW5rW3JlbD1cInByZWZldGNoXCJdW2hyZWZePVwiJHtocmVmfVwiXSxcbiAgICAgIGxpbmtbcmVsPVwicHJlbG9hZFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXG4gICAgICBzY3JpcHRbc3JjXj1cIiR7aHJlZn1cIl1gO1xuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsOlxuICAgICAgICBpZiAoYXMpIGxpbmsuYXMgPSBhcztcbiAgICAgICAgbGluay5yZWwgPSBgcHJlZmV0Y2hgO1xuICAgICAgICBsaW5rLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgbGluay5vbmxvYWQgPSByZXM7XG4gICAgICAgIGxpbmsub25lcnJvciA9IHJlajtcbiAgICAgICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9KTtcbn1cbmNvbnN0IEFTU0VUX0xPQURfRVJST1IgPSBTeW1ib2woJ0FTU0VUX0xPQURfRVJST1InKTtcbmZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0Fzc2V0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVycjtcbn1cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChzcmMsIHNjcmlwdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAgICAgLy8gMS4gU2V0dXAgc3VjY2Vzcy9mYWlsdXJlIGhvb2tzIGluIGNhc2UgdGhlIGJyb3dzZXIgc3luY2hyb25vdXNseVxuICAgICAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gKCk9PnJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuICAgICAgICA7XG4gICAgICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgICAgICAvLyAgICBicm93c2VyIGJlZ2lucyB0byBmZXRjaC5cbiAgICAgICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgLy8gMy4gRmluYWxseSwgc2V0IHRoZSBzb3VyY2UgYW5kIGluamVjdCBpbnRvIHRoZSBET00gaW4gY2FzZSB0aGUgY2hpbGRcbiAgICAgICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcbn1cbi8vIFdlIHdhaXQgZm9yIHBhZ2VzIHRvIGJlIGJ1aWx0IGluIGRldiBiZWZvcmUgd2Ugc3RhcnQgdGhlIHJvdXRlIHRyYW5zaXRpb25cbi8vIHRpbWVvdXQgdG8gcHJldmVudCBhbiB1bi1uZWNlc3NhcnkgaGFyZCBuYXZpZ2F0aW9uIGluIGRldmVsb3BtZW50LlxubGV0IGRldkJ1aWxkUHJvbWlzZTtcbi8vIFJlc29sdmUgYSBwcm9taXNlIHRoYXQgdGltZXMgb3V0IGFmdGVyIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KHAsIG1zLCBlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBwLnRoZW4oKHIpPT57XG4gICAgICAgICAgICAvLyBSZXNvbHZlZCwgY2FuY2VsIHRoZSB0aW1lb3V0XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgLy8gV2Ugd3JhcCB0aGVzZSBjaGVja3Mgc2VwYXJhdGVseSBmb3IgYmV0dGVyIGRlYWQtY29kZSBlbGltaW5hdGlvbiBpblxuICAgICAgICAvLyBwcm9kdWN0aW9uIGJ1bmRsZXMuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKGRldkJ1aWxkUHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgbXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG1zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcbiAgICB9XG4gICAgY29uc3Qgb25CdWlsZE1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIC8vIE1hbmRhdG9yeSBiZWNhdXNlIHRoaXMgaXMgbm90IGNvbmN1cnJlbnQgc2FmZTpcbiAgICAgICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpPT57XG4gICAgICAgICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVCk7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KG9uQnVpbGRNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IGJ1aWxkIG1hbmlmZXN0JykpKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fTUlERExFV0FSRV9NQU5JRkVTVCk7XG4gICAgfVxuICAgIGNvbnN0IG9uTWlkZGxld2FyZU1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIGNvbnN0IGNiID0gc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19NSURETEVXQVJFX01BTklGRVNUX0NCID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChvbk1pZGRsZXdhcmVNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IG1pZGRsZXdhcmUgbWFuaWZlc3QnKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzY3JpcHRzOiBbXG4gICAgICAgICAgICAgICAgYXNzZXRQcmVmaXggKyAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICsgZW5jb2RlVVJJKCgwLCBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKS5kZWZhdWx0KHJvdXRlLCAnLmpzJykpLCBcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICBjc3M6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KT0+di5lbmRzV2l0aCgnLmpzJylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXgpIHtcbiAgICBjb25zdCBlbnRyeXBvaW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBsb2FkZWRTY3JpcHRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjKSB7XG4gICAgICAgIC8vIFdpdGggSE1SIHdlIG1pZ2h0IG5lZWQgdG8gXCJyZWxvYWRcIiBzY3JpcHRzIHdoZW4gdGhleSBhcmVcbiAgICAgICAgLy8gZGlzcG9zZWQgYW5kIHJlYWRkZWQuIEV4ZWN1dGluZyBzY3JpcHRzIHR3aWNlIGhhcyBubyBmdW5jdGlvbmFsXG4gICAgICAgIC8vIGRpZmZlcmVuY2VzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgbGV0IHByb20gPSBsb2FkZWRTY3JpcHRzLmdldChzcmMpO1xuICAgICAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLCBwcm9tID0gYXBwZW5kU2NyaXB0KHNyYykpO1xuICAgICAgICAgICAgcmV0dXJuIHByb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kU2NyaXB0KHNyYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTdHlsZVNoZWV0KGhyZWYpIHtcbiAgICAgICAgbGV0IHByb20gPSBzdHlsZVNoZWV0cy5nZXQoaHJlZik7XG4gICAgICAgIGlmIChwcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVNoZWV0cy5zZXQoaHJlZiwgcHJvbSA9IGZldGNoKGhyZWYpLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdHlsZXNoZWV0OiAke2hyZWZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKCh0ZXh0KT0+KHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2hlbkVudHJ5cG9pbnQgKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudHJ5cG9pbnQgKHJvdXRlLCBleGVjdXRlKSB7XG4gICAgICAgICAgICAoZXhlY3V0ZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmV4ZWN1dGUoKVxuICAgICAgICAgICAgKS50aGVuKChleHBvcnRzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBleHBvcnRzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICwgKGVycik9Pih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKS50aGVuKChpbnB1dCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnJlc29sdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZSBpcyBvdXRkYXRlZCBhbmQgd2Ugd2FudCB0byBpbnZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRSb3V0ZSAocm91dGUsIHByZWZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgcm91dGVzLCAoKT0+e1xuICAgICAgICAgICAgICAgIGxldCBkZXZCdWlsZFByb21pc2VSZXNvbHZlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBkZXZCdWlsZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKHsgc2NyaXB0cyAsIGNzcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSkgPyBbXSA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSwgXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSksIE1TX01BWF9JRExFX0RFTEFZLCBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYFJvdXRlIGRpZCBub3QgY29tcGxldGUgbG9hZGluZzogJHtyb3V0ZX1gKSkpLnRoZW4oKHsgZW50cnlwb2ludCAsIHN0eWxlcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICB9LCBlbnRyeXBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXM7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIGVycm9ycyBkdXJpbmcgcHJlZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPT09IG51bGwgfHwgZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZldGNoIChyb3V0ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgICAgICAgbGV0IGNuO1xuICAgICAgICAgICAgaWYgKGNuID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKG91dHB1dCk9PlByb21pc2UuYWxsKGNhblByZWZldGNoID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpPT5wcmVmZXRjaFZpYURvbShzY3JpcHQsICdzY3JpcHQnKVxuICAgICAgICAgICAgICAgICkgOiBbXSlcbiAgICAgICAgICAgICkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+dGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgICAoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFya0Fzc2V0RXJyb3IiLCJpc0Fzc2V0RXJyb3IiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiZ2V0TWlkZGxld2FyZU1hbmlmZXN0IiwiY3JlYXRlUm91dGVMb2FkZXIiLCJfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcmVxdWVzdElkbGVDYWxsYmFjayIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiTVNfTUFYX0lETEVfREVMQVkiLCJ3aXRoRnV0dXJlIiwia2V5IiwibWFwIiwiZ2VuZXJhdG9yIiwiZW50cnkiLCJnZXQiLCJmdXR1cmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVyIiwicHJvbSIsInNldCIsInRoZW4iLCJjYXRjaCIsImVyciIsImRlbGV0ZSIsImhhc1ByZWZldGNoIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpbmRvdyIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiZSIsImNhblByZWZldGNoIiwicHJlZmV0Y2hWaWFEb20iLCJocmVmIiwiYXMiLCJyZXMiLCJyZWoiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ1JPU1NfT1JJR0lOIiwib25sb2FkIiwib25lcnJvciIsImhlYWQiLCJhcHBlbmRDaGlsZCIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJhcHBlbmRTY3JpcHQiLCJzcmMiLCJzY3JpcHQiLCJyZWplY3QiLCJFcnJvciIsImJvZHkiLCJkZXZCdWlsZFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0IiwicCIsIm1zIiwiY2FuY2VsbGVkIiwiciIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZXRUaW1lb3V0Iiwic2VsZiIsIl9fQlVJTERfTUFOSUZFU1QiLCJvbkJ1aWxkTWFuaWZlc3QiLCJjYiIsIl9fQlVJTERfTUFOSUZFU1RfQ0IiLCJfX01JRERMRVdBUkVfTUFOSUZFU1QiLCJvbk1pZGRsZXdhcmVNYW5pZmVzdCIsIl9fTUlERExFV0FSRV9NQU5JRkVTVF9DQiIsImdldEZpbGVzRm9yUm91dGUiLCJhc3NldFByZWZpeCIsInJvdXRlIiwic2NyaXB0cyIsImVuY29kZVVSSSIsImNzcyIsIm1hbmlmZXN0IiwiYWxsRmlsZXMiLCJmaWx0ZXIiLCJ2IiwiZW5kc1dpdGgiLCJtYXliZUV4ZWN1dGVTY3JpcHQiLCJsb2FkZWRTY3JpcHRzIiwiZmV0Y2hTdHlsZVNoZWV0Iiwic3R5bGVTaGVldHMiLCJmZXRjaCIsIm9rIiwidGV4dCIsImNvbnRlbnQiLCJlbnRyeXBvaW50cyIsIk1hcCIsInJvdXRlcyIsIndoZW5FbnRyeXBvaW50Iiwib25FbnRyeXBvaW50IiwiZXhlY3V0ZSIsImNvbXBvbmVudCIsImVycm9yIiwidW5kZWZpbmVkIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJwcmVmZXRjaCIsImRldkJ1aWxkUHJvbWlzZVJlc29sdmUiLCJhbGwiLCJoYXMiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiYXNzaWduIiwiZmluYWxseSIsImNuIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwidGVzdCIsImVmZmVjdGl2ZVR5cGUiLCJvdXRwdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/regenerator-runtime/runtime.js */ \"./node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports[\"default\"] = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _isError = _interopRequireDefault1(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../../../server/denormalize-page-path */ \"./node_modules/next/dist/server/denormalize-page-path.js\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _resolveRewrites = _interopRequireDefault1(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _getMiddlewareRegex = __webpack_require__(/*! ./utils/get-middleware-regex */ \"./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js\");\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar detectDomainLocale;\nif (false) {}\nvar basePath =  false || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    var pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(\"\".concat(prefix).concat(pathname)) + path.substr(pathname.length);\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var detectedDomain; } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    var queryIndex = path.indexOf('?');\n    var hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    path = pathNoQueryHash(path);\n    return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = \"/\".concat(path);\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        var locationOrigin = (0, _utils).getLocationOrigin();\n        var resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    var interpolatedRoute = '';\n    var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    var dynamicGroups = dynamicRegex.groups;\n    var dynamicMatches = (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    var params = Object.keys(dynamicGroups);\n    if (!params.every(function(param) {\n        var value = dynamicMatches[param] || '';\n        var _param = dynamicGroups[param], repeat = _param.repeat, optional = _param.optional;\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n        if (optional) {\n            replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        function(segment) {\n            return encodeURIComponent(segment);\n        }).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params: params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    var filteredQuery = {\n    };\n    Object.keys(query).forEach(function(key) {\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    var base;\n    var urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    var urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n    var urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n        var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        var finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        var interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            var ref = interpolateAs(finalUrl.pathname, finalUrl.pathname, query), result = ref.result, params = ref.params;\n            if (result) {\n                interpolatedAs = (0, _utils).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var ref = _slicedToArray(resolveHref(router, url, true), 2), resolvedHref = ref[0], resolvedAs = ref[1];\n    var origin = (0, _utils).getLocationOrigin();\n    var hrefHadOrigin = resolvedHref.startsWith(origin);\n    var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, opts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then(function(res) {\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1, opts);\n            }\n            if (res.status === 404) {\n                return res.json().then(function(data) {\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(\"Failed to load static props\");\n                });\n            }\n            throw new Error(\"Failed to load static props\");\n        }\n        return opts.text ? res.text() : res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n    var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n        text: text\n    }).catch(function(err) {\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then(function(data) {\n        if (!persistCache || \"development\" !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch(function(err) {\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname2, query1, as1, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _classCallCheck(this, Router);\n        // Static Data Cache\n        this.sdc = {\n        };\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {\n        };\n        // In-flight middleware preflight requests\n        this.sde = {\n        };\n        this._idx = 0;\n        this.onPopState = function(e) {\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var pathname = _this.pathname, query = _this.query;\n                _this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query: query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, as = state.as, options = state.options, idx = state.idx;\n            if (false) { var v; }\n            _this._idx = idx;\n            var pathname1 = (0, _parseRelativeUrl).parseRelativeUrl(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && as === _this.asPath && pathname1 === _this.pathname) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change('replaceState', url, as, Object.assign({\n            }, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname2);\n        // set up the component cache (by route keys)\n        this.components = {\n        };\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname2 !== '/_error') {\n            var ref;\n            this.components[this.route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        this.pathname = pathname2;\n        this.query = query1;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname2) && self.__NEXT_DATA__.autoExport;\n        this.asPath = autoExportDynamic ? pathname2 : as1;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isFallback = isFallback;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        this.isPreview = !!isPreview;\n        this.isLocaleDomain = false;\n        if (false) {}\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (as1.substr(0, 2) !== '//') {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options1 = {\n                    locale: locale\n                };\n                options1._shouldResolveHref = as1 !== pathname2;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname2),\n                    query: query1\n                }), (0, _utils).getURL(), options1);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _createClass(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('pushState', url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('replaceState', url, as, options);\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var shouldResolveHref, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _shallow, shallow, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, ref1, ref2, resolvedAs, rewritesResult, effect, route, parsedAs1, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, ref, ref12, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, ref3, newUrl, newAs, notFoundRoute, isValidShallowRoute, _scroll, shouldScroll, resetScroll;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (isLocalURL(url)) {\n                                    _ctx.next = 3;\n                                    break;\n                                }\n                                window.location.href = url;\n                                return _ctx.abrupt(\"return\", false);\n                            case 3:\n                                shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                if (options._h) {\n                                    this.isReady = true;\n                                }\n                                prevLocale = this.locale;\n                                if (true) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;\n                                if (typeof options.locale === 'undefined') {\n                                    options.locale = this.locale;\n                                }\n                                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n                                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n                                if (localePathResult.detectedLocale) {\n                                    this.locale = localePathResult.detectedLocale;\n                                    parsedAs.pathname = addBasePath(parsedAs.pathname);\n                                    as = (0, _utils).formatWithValidation(parsedAs);\n                                    url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n                                }\n                                didNavigate = false;\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale);\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                if (!didNavigate) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 18:\n                                if (!options._h) {\n                                    this.isSsr = false;\n                                }\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark('routeChange');\n                                }\n                                _shallow = options.shallow, shallow = _shallow === void 0 ? false : _shallow;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (this._inFlightRoute) {\n                                    this.abortComponentLoad(this._inFlightRoute, routeProps);\n                                }\n                                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n                                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n                                this._inFlightRoute = as;\n                                localeChange = prevLocale !== this.locale;\n                                if (!(!options._h && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                                    _ctx.next = 35;\n                                    break;\n                                }\n                                this.asPath = cleanedAs;\n                                Router.events.emit('hashChangeStart', as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                this.changeState(method, url, as, options);\n                                this.scrollToHash(cleanedAs);\n                                this.notify(this.components[this.route], null);\n                                Router.events.emit('hashChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 35:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                ;\n                                _ctx.prev = 38;\n                                ;\n                                _ctx.t0 = _slicedToArray;\n                                _ctx.next = 43;\n                                return Promise.all([\n                                    this.pageLoader.getPageList(),\n                                    (0, _routeLoader).getClientBuildManifest(),\n                                    this.pageLoader.getMiddlewareList(), \n                                ]);\n                            case 43:\n                                _ctx.t1 = _ctx.sent;\n                                ref1 = (0, _ctx.t0)(_ctx.t1, 2);\n                                pages = ref1[0];\n                                ref2 = ref1[1], rewrites = ref2.__rewrites, ref2;\n                                ref1;\n                                _ctx.next = 54;\n                                break;\n                            case 50:\n                                _ctx.prev = 50;\n                                _ctx.t2 = _ctx[\"catch\"](38);\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 54:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = 'replaceState';\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n                                if (shouldResolveHref && pathname !== '/_error') {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = addBasePath(pathname);\n                                            url = (0, _utils).formatWithValidation(parsed);\n                                        }\n                                    }\n                                }\n                                if (isLocalURL(as)) {\n                                    _ctx.next = 63;\n                                    break;\n                                }\n                                if (false) {}\n                                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                            case 61:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 63:\n                                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n                                if (!(options._h !== 1)) {\n                                    _ctx.next = 84;\n                                    break;\n                                }\n                                _ctx.next = 67;\n                                return this._preflightRequest({\n                                    as: as,\n                                    cache: \"development\" === 'production',\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 67:\n                                effect = _ctx.sent;\n                                if (!(effect.type === 'rewrite')) {\n                                    _ctx.next = 72;\n                                    break;\n                                }\n                                {\n                                    query = _objectSpread({\n                                    }, query, effect.parsedAs.query);\n                                    resolvedAs = effect.asPath;\n                                    pathname = effect.resolvedHref;\n                                    parsed.pathname = effect.resolvedHref;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 84;\n                                break;\n                            case 72:\n                                if (!(effect.type === 'redirect' && effect.newAs)) {\n                                    _ctx.next = 76;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", this.change(method, effect.newUrl, effect.newAs, options));\n                            case 76:\n                                if (!(effect.type === 'redirect' && effect.destination)) {\n                                    _ctx.next = 81;\n                                    break;\n                                }\n                                window.location.href = effect.destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 81:\n                                if (!(effect.type === 'refresh')) {\n                                    _ctx.next = 84;\n                                    break;\n                                }\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 84:\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                                    _ctx.next = 100;\n                                    break;\n                                }\n                                parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                                asPathname = parsedAs1.pathname;\n                                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                                shouldInterpolate = route === asPathname;\n                                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {\n                                };\n                                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                                    _ctx.next = 99;\n                                    break;\n                                }\n                                missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                    return !query[param];\n                                });\n                                if (!(missingParams.length > 0)) {\n                                    _ctx.next = 97;\n                                    break;\n                                }\n                                if (true) {\n                                    console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                                }\n                                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n                            case 97:\n                                _ctx.next = 100;\n                                break;\n                            case 99:\n                                if (shouldInterpolate) {\n                                    as = (0, _utils).formatWithValidation(Object.assign({\n                                    }, parsedAs1, {\n                                        pathname: interpolatedAs.result,\n                                        query: omitParmsFromQuery(query, interpolatedAs.params)\n                                    }));\n                                } else {\n                                    // Merge params into `query`, overwriting any specified in search\n                                    Object.assign(query, routeMatch);\n                                }\n                            case 100:\n                                Router.events.emit('routeChangeStart', as, routeProps);\n                                _ctx.prev = 101;\n                                ;\n                                _ctx.next = 105;\n                                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n                            case 105:\n                                routeInfo = _ctx.sent;\n                                error = routeInfo.error, props = routeInfo.props, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;\n                                if (!((__N_SSG || __N_SSP) && props)) {\n                                    _ctx.next = 132;\n                                    break;\n                                }\n                                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                                    _ctx.next = 117;\n                                    break;\n                                }\n                                destination = props.pageProps.__N_REDIRECT;\n                                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                                    _ctx.next = 115;\n                                    break;\n                                }\n                                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                ref3 = prepareUrlAs(this, destination, destination), newUrl = ref3.url, newAs = ref3.as;\n                                return _ctx.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n                            case 115:\n                                window.location.href = destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 117:\n                                this.isPreview = !!props.__N_PREVIEW;\n                                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                                    _ctx.next = 132;\n                                    break;\n                                }\n                                ;\n                                _ctx.prev = 120;\n                                _ctx.next = 123;\n                                return this.fetchComponent('/404');\n                            case 123:\n                                notFoundRoute = '/404';\n                                _ctx.next = 129;\n                                break;\n                            case 126:\n                                _ctx.prev = 126;\n                                _ctx.t3 = _ctx[\"catch\"](120);\n                                notFoundRoute = '/_error';\n                            case 129:\n                                _ctx.next = 131;\n                                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                                    shallow: false\n                                });\n                            case 131:\n                                routeInfo = _ctx.sent;\n                            case 132:\n                                Router.events.emit('beforeHistoryChange', as, routeProps);\n                                this.changeState(method, url, as, options);\n                                if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref12 = ref.pageProps) === null || ref12 === void 0 ? void 0 : ref12.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && this.route === route;\n                                ;\n                                shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                _ctx.next = 141;\n                                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(function(e) {\n                                    if (e.cancelled) error = error || e;\n                                    else throw e;\n                                });\n                            case 141:\n                                if (!error) {\n                                    _ctx.next = 144;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                                throw error;\n                            case 144:\n                                if (false) {}\n                                Router.events.emit('routeChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 149:\n                                _ctx.prev = 149;\n                                _ctx.t4 = _ctx[\"catch\"](101);\n                                if (!((0, _isError).default(_ctx.t4) && _ctx.t4.cancelled)) {\n                                    _ctx.next = 153;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", false);\n                            case 153:\n                                throw _ctx.t4;\n                            case 154:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            38,\n                            50\n                        ],\n                        [\n                            101,\n                            149\n                        ],\n                        [\n                            120,\n                            126\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (true) {\n                    if (typeof window.history === 'undefined') {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === 'undefined') {\n                        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                        return;\n                    }\n                }\n                if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    '', as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var Component, styleSheets, props, ref, routeInfo;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (!err.cancelled) {\n                                    _ctx.next = 2;\n                                    break;\n                                }\n                                // bubble up cancellation errors\n                                throw err;\n                            case 2:\n                                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                                    _ctx.next = 6;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', err, as, routeProps);\n                                // If we can't load the page it could be one of following reasons\n                                //  1. Page doesn't exists\n                                //  2. Page does exist in a different zone\n                                //  3. Internal error while loading the page\n                                // So, doing a hard reload is the proper way to deal with this.\n                                window.location.href = as;\n                                // Changing the URL doesn't block executing the current code path.\n                                // So let's throw a cancellation error stop the routing logic.\n                                throw buildCancellationError();\n                            case 6:\n                                _ctx.prev = 6;\n                                ;\n                                ;\n                                ;\n                                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                ;\n                                _ctx.next = 14;\n                                return this.fetchComponent('/_error');\n                            case 14:\n                                ref = _ctx.sent;\n                                Component = ref.page;\n                                styleSheets = ref.styleSheets;\n                                ref;\n                            case 18:\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (routeInfo.props) {\n                                    _ctx.next = 30;\n                                    break;\n                                }\n                                _ctx.prev = 20;\n                                _ctx.next = 23;\n                                return this.getInitialProps(Component, {\n                                    err: err,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 23:\n                                routeInfo.props = _ctx.sent;\n                                _ctx.next = 30;\n                                break;\n                            case 26:\n                                _ctx.prev = 26;\n                                _ctx.t0 = _ctx[\"catch\"](20);\n                                console.error('Error in error page `getInitialProps`: ', _ctx.t0);\n                                routeInfo.props = {\n                                };\n                            case 30:\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 33:\n                                _ctx.prev = 33;\n                                _ctx.t1 = _ctx[\"catch\"](6);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps, true));\n                            case 36:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            6,\n                            33\n                        ],\n                        [\n                            20,\n                            26\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, __N_RSC, isValidElementType, dataHref, props, ref, fresh, data;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _ctx.prev = 0;\n                                existingRouteInfo = this.components[route];\n                                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {\n                                    _ctx.next = 4;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", existingRouteInfo);\n                            case 4:\n                                cachedRouteInfo = undefined;\n                                // can only use non-initial route info\n                                // cannot reuse route info in development since it can change after HMR\n                                if (false) {}\n                                _ctx.t0 = cachedRouteInfo;\n                                if (_ctx.t0) {\n                                    _ctx.next = 11;\n                                    break;\n                                }\n                                _ctx.next = 10;\n                                return this.fetchComponent(route).then(function(res) {\n                                    return {\n                                        Component: res.page,\n                                        styleSheets: res.styleSheets,\n                                        __N_SSG: res.mod.__N_SSG,\n                                        __N_SSP: res.mod.__N_SSP,\n                                        __N_RSC: !!res.page.__next_rsc__\n                                    };\n                                });\n                            case 10:\n                                _ctx.t0 = _ctx.sent;\n                            case 11:\n                                routeInfo = _ctx.t0;\n                                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP, __N_RSC = routeInfo.__N_RSC;\n                                if (false) {}\n                                isValidElementType = (__webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\").isValidElementType);\n                                if (isValidElementType(Component)) {\n                                    _ctx.next = 17;\n                                    break;\n                                }\n                                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n                            case 17:\n                                ;\n                                if (__N_SSG || __N_SSP || __N_RSC) {\n                                    dataHref = this.pageLoader.getDataHref({\n                                        href: (0, _utils).formatWithValidation({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        asPath: resolvedAs,\n                                        ssg: __N_SSG,\n                                        rsc: __N_RSC,\n                                        locale: this.locale\n                                    });\n                                }\n                                _ctx.next = 21;\n                                return this._getData(function() {\n                                    return __N_SSG || __N_SSP ? fetchNextData(dataHref, _this.isSsr, false, __N_SSG ? _this.sdc : _this.sdr, !!__N_SSG && !_this.isPreview) : _this.getInitialProps(Component, {\n                                        pathname: pathname,\n                                        query: query,\n                                        asPath: as,\n                                        locale: _this.locale,\n                                        locales: _this.locales,\n                                        defaultLocale: _this.defaultLocale\n                                    });\n                                });\n                            case 21:\n                                props = _ctx.sent;\n                                if (!__N_RSC) {\n                                    _ctx.next = 29;\n                                    break;\n                                }\n                                _ctx.next = 25;\n                                return this._getData(function() {\n                                    return _this._getFlightData(dataHref);\n                                });\n                            case 25:\n                                ref = _ctx.sent;\n                                fresh = ref.fresh;\n                                data = ref.data;\n                                props.pageProps = Object.assign(props.pageProps, {\n                                    __flight_serialized__: data,\n                                    __flight_fresh__: fresh\n                                });\n                            case 29:\n                                routeInfo.props = props;\n                                this.components[route] = routeInfo;\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 34:\n                                _ctx.prev = 34;\n                                _ctx.t1 = _ctx[\"catch\"](0);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps));\n                            case 37:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            34\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(route, pathname, query, as, data, resetScroll) {\n                this.isFallback = false;\n                this.route = route;\n                this.pathname = pathname;\n                this.query = query;\n                this.asPath = as;\n                return this.notify(data, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var ref = _slicedToArray(this.asPath.split('#'), 2), oldUrlNoHash = ref[0], oldHash = ref[1];\n                var ref4 = _slicedToArray(as.split('#'), 2), newUrlNoHash = ref4[0], newHash = ref4[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var ref = _slicedToArray(as.split('#'), 2), hash = ref[1];\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === '' || hash === 'top') {\n                    window.scrollTo(0, 0);\n                    return;\n                }\n                // First we check if the element by id is found\n                var idEl = document.getElementById(hash);\n                if (idEl) {\n                    idEl.scrollIntoView();\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(hash)[0];\n                if (nameEl) {\n                    nameEl.scrollIntoView();\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url, param, param1) {\n                var asPath = param === void 0 ? url : param, options = param1 === void 0 ? {\n                } : param1;\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var parsed, pathname, query, parsedAs, localePathResult, pages, resolvedAs, rewrites, ref, rewritesResult, effects, route;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                if (false) {}\n                                _ctx.next = 5;\n                                return this.pageLoader.getPageList();\n                            case 5:\n                                pages = _ctx.sent;\n                                resolvedAs = asPath;\n                                if (true) {\n                                    _ctx.next = 20;\n                                    break;\n                                }\n                                ;\n                                ;\n                                _ctx.next = 12;\n                                return (0, _routeLoader).getClientBuildManifest();\n                            case 12:\n                                ref = _ctx.sent;\n                                rewrites = ref.__rewrites;\n                                ref;\n                                rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, this.locales);\n                                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 21;\n                                break;\n                            case 20:\n                                {\n                                    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                    if (parsed.pathname !== pathname) {\n                                        pathname = parsed.pathname;\n                                        parsed.pathname = pathname;\n                                        url = (0, _utils).formatWithValidation(parsed);\n                                    }\n                                }\n                            case 21:\n                                if (false) {}\n                                return _ctx.abrupt(\"return\");\n                            case 23:\n                                _ctx.next = 25;\n                                return this._preflightRequest({\n                                    as: addBasePath(asPath),\n                                    cache: true,\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 25:\n                                effects = _ctx.sent;\n                                if (effects.type === 'rewrite') {\n                                    parsed.pathname = effects.resolvedHref;\n                                    pathname = effects.resolvedHref;\n                                    query = _objectSpread({\n                                    }, query, effects.parsedAs.query);\n                                    resolvedAs = effects.asPath;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                _ctx.next = 30;\n                                return Promise.all([\n                                    this.pageLoader._isSsg(route).then(function(isSsg) {\n                                        return isSsg ? fetchNextData(_this.pageLoader.getDataHref({\n                                            href: url,\n                                            asPath: resolvedAs,\n                                            ssg: true,\n                                            locale: typeof options.locale !== 'undefined' ? options.locale : _this.locale\n                                        }), false, false, _this.sdc, true) : false;\n                                    }),\n                                    this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n                                ]);\n                            case 30:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var cancelled, cancel, handleCancelled, componentResult;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                cancelled = false;\n                                cancel = this.clc = function() {\n                                    cancelled = true;\n                                };\n                                handleCancelled = function() {\n                                    if (cancelled) {\n                                        var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n                                        error.cancelled = true;\n                                        throw error;\n                                    }\n                                    if (cancel === _this.clc) {\n                                        _this.clc = null;\n                                    }\n                                };\n                                _ctx.prev = 3;\n                                _ctx.next = 6;\n                                return this.pageLoader.loadPage(route);\n                            case 6:\n                                componentResult = _ctx.sent;\n                                handleCancelled();\n                                return _ctx.abrupt(\"return\", componentResult);\n                            case 11:\n                                _ctx.prev = 11;\n                                _ctx.t0 = _ctx[\"catch\"](3);\n                                handleCancelled();\n                                throw _ctx.t0;\n                            case 15:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            3,\n                            11\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error('Loading initial props cancelled');\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                var _this = this;\n                var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n                if (!this.isPreview && this.sdc[cacheKey]) {\n                    return Promise.resolve({\n                        fresh: false,\n                        data: this.sdc[cacheKey]\n                    });\n                }\n                return fetchNextData(dataHref, true, true, this.sdc, false).then(function(serialized) {\n                    _this.sdc[cacheKey] = serialized;\n                    return {\n                        fresh: true,\n                        data: serialized\n                    };\n                });\n            }\n        },\n        {\n            key: \"_preflightRequest\",\n            value: function _preflightRequest(options) {\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var ref, cleanedAs, fns, requiresPreflight, preflight, parsed, fsPathname, matchedPage, resolvedHref, cleanRedirect, ref5, newUrl, newAs;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                ;\n                                cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, this.locale);\n                                _ctx.next = 4;\n                                return this.pageLoader.getMiddlewareList();\n                            case 4:\n                                fns = _ctx.sent;\n                                requiresPreflight = fns.some(function(param) {\n                                    var _param = _slicedToArray(param, 2), middleware = _param[0], isSSR = _param[1];\n                                    return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n                                });\n                                if (requiresPreflight) {\n                                    _ctx.next = 8;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 8:\n                                _ctx.next = 10;\n                                return this._getPreflightData({\n                                    preflightHref: options.as,\n                                    shouldCache: options.cache\n                                });\n                            case 10:\n                                preflight = _ctx.sent;\n                                if (!((ref = preflight.rewrite) === null || ref === void 0 ? void 0 : ref.startsWith('/'))) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n                                fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n                                ;\n                                ;\n                                if (options.pages.includes(fsPathname)) {\n                                    matchedPage = true;\n                                    resolvedHref = fsPathname;\n                                } else {\n                                    resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                                    if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                                        matchedPage = true;\n                                    }\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'rewrite',\n                                    asPath: parsed.pathname,\n                                    parsedAs: parsed,\n                                    matchedPage: matchedPage,\n                                    resolvedHref: resolvedHref\n                                });\n                            case 18:\n                                if (!preflight.redirect) {\n                                    _ctx.next = 24;\n                                    break;\n                                }\n                                if (!preflight.redirect.startsWith('/')) {\n                                    _ctx.next = 23;\n                                    break;\n                                }\n                                cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                                ref5 = prepareUrlAs(this, cleanRedirect, cleanRedirect), newUrl = ref5.url, newAs = ref5.as;\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    newUrl: newUrl,\n                                    newAs: newAs\n                                });\n                            case 23:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    destination: preflight.redirect\n                                });\n                            case 24:\n                                if (!(preflight.refresh && !preflight.ssr)) {\n                                    _ctx.next = 26;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'refresh'\n                                });\n                            case 26:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 27:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getPreflightData\",\n            value: function _getPreflightData(params) {\n                var _this = this;\n                var preflightHref = params.preflightHref, _shouldCache = params.shouldCache, shouldCache = _shouldCache === void 0 ? false : _shouldCache;\n                var ref = new URL(preflightHref, window.location.href), cacheKey = ref.href;\n                if (false) {}\n                return fetch(preflightHref, {\n                    method: 'HEAD',\n                    credentials: 'same-origin',\n                    headers: {\n                        'x-middleware-preflight': '1'\n                    }\n                }).then(function(res) {\n                    if (!res.ok) {\n                        throw new Error(\"Failed to preflight request\");\n                    }\n                    return {\n                        redirect: res.headers.get('Location'),\n                        refresh: res.headers.has('x-middleware-refresh'),\n                        rewrite: res.headers.get('x-middleware-rewrite'),\n                        ssr: !!res.headers.get('x-middleware-ssr')\n                    };\n                }).then(function(data) {\n                    if (shouldCache) {\n                        _this.sde[cacheKey] = data;\n                    }\n                    return data;\n                }).catch(function(err) {\n                    delete _this.sde[cacheKey];\n                    throw err;\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var ref = this.components['/_app'], App = ref.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils).loadGetInitialProps(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"abortComponentLoad\",\n            value: function abortComponentLoad(as, routeProps) {\n                if (this.clc) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n                    this.clc();\n                    this.clc = null;\n                }\n            }\n        },\n        {\n            key: \"notify\",\n            value: function notify(data, resetScroll) {\n                return this.sub(data, this.components['/_app'].Component, resetScroll);\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt).default();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRSxlQUFlO0FBQ3pDRixpQkFBaUIsR0FBR0csU0FBUztBQUM3QkgsaUJBQWlCLEdBQUdJLFNBQVM7QUFDN0JKLG1CQUFtQixHQUFHSyxXQUFXO0FBQ2pDTCxtQkFBbUIsR0FBR00sV0FBVztBQUNqQ04sbUJBQW1CLEdBQUdPLFdBQVc7QUFDakNQLGtCQUFrQixHQUFHUSxVQUFVO0FBQy9CUixxQkFBcUIsR0FBR1MsYUFBYTtBQUNyQ1QsbUJBQW1CLEdBQUdVLFdBQVc7QUFDakNWLGtCQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDeEIsR0FBRyxDQUFDWSx1QkFBdUIsR0FBR0MsbUJBQU8sQ0FBQyw2R0FBMEM7QUFDaEYsR0FBRyxDQUFDQyxZQUFZLEdBQUdELG1CQUFPLENBQUMscUZBQThCO0FBQ3pELEdBQUcsQ0FBQ0UsUUFBUSxHQUFHQyx1QkFBc0IsQ0FBQ0gsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDckUsR0FBRyxDQUFDSSxvQkFBb0IsR0FBR0osbUJBQU8sQ0FBQyx1R0FBdUM7QUFDMUUsR0FBRyxDQUFDSyxvQkFBb0IsR0FBR0wsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDbEUsR0FBRyxDQUFDTSxLQUFLLEdBQUdILHVCQUFzQixDQUFDSCxtQkFBTyxDQUFDLDREQUFTO0FBQ3BELEdBQUcsQ0FBQ08sTUFBTSxHQUFHUCxtQkFBTyxDQUFDLDhEQUFVO0FBQy9CLEdBQUcsQ0FBQ1EsVUFBVSxHQUFH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QUFNLEVBQU5BLENBQU07bUJBQU5BLFFBQVEsQ0FBUkEsTUFBTSxDQUFDeEgsSUFBSSxFQUFFNkcsV0FBVyxFQUFFLENBQUM7Z0JBQ3ZCLE1BQU0sQ0FBQyxJQUFJLENBQUM5QyxHQUFHLENBQUMvRCxJQUFJLEVBQUUsSUFBSSxDQUFDa0QsVUFBVSxDQUFDLENBQU8sUUFBRWhDLFNBQVMsRUFBRTJGLFdBQVc7WUFDekUsQ0FBQzs7O1dBdDZCQ2hHLE1BQU07O0FBdzZCWkEsTUFBTSxDQUFDOEMsTUFBTSxJQUFJLENBQUMsRUFBRTlNLEtBQUssRUFBRVIsT0FBTztBQUNsQ1gsa0JBQWUsR0FBR21MLE1BQU0sQ0FFeEIsQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanM/ODY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0RG9tYWluTG9jYWxlID0gZ2V0RG9tYWluTG9jYWxlO1xuZXhwb3J0cy5hZGRMb2NhbGUgPSBhZGRMb2NhbGU7XG5leHBvcnRzLmRlbExvY2FsZSA9IGRlbExvY2FsZTtcbmV4cG9ydHMuaGFzQmFzZVBhdGggPSBoYXNCYXNlUGF0aDtcbmV4cG9ydHMuYWRkQmFzZVBhdGggPSBhZGRCYXNlUGF0aDtcbmV4cG9ydHMuZGVsQmFzZVBhdGggPSBkZWxCYXNlUGF0aDtcbmV4cG9ydHMuaXNMb2NhbFVSTCA9IGlzTG9jYWxVUkw7XG5leHBvcnRzLmludGVycG9sYXRlQXMgPSBpbnRlcnBvbGF0ZUFzO1xuZXhwb3J0cy5yZXNvbHZlSHJlZiA9IHJlc29sdmVIcmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX3JvdXRlTG9hZGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXJcIik7XG52YXIgX2lzRXJyb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtZXJyb3JcIikpO1xudmFyIF9kZW5vcm1hbGl6ZVBhZ2VQYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XG52YXIgX25vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG52YXIgX21pdHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9taXR0XCIpKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG52YXIgX3BhcnNlUmVsYXRpdmVVcmwgPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4vdXRpbHMvcXVlcnlzdHJpbmdcIik7XG52YXIgX3Jlc29sdmVSZXdyaXRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG52YXIgX3JvdXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG52YXIgX3JvdXRlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbnZhciBfZ2V0TWlkZGxld2FyZVJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0LW1pZGRsZXdhcmUtcmVnZXhcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5sZXQgZGV0ZWN0RG9tYWluTG9jYWxlO1xuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBkZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykuZGV0ZWN0RG9tYWluTG9jYWxlO1xufVxuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGAke3ByZWZpeH0ke3BhdGhuYW1lfWApICsgcGF0aC5zdWJzdHIocGF0aG5hbWUubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShwYXRoLCBsb2NhbGUsIGxvY2FsZXMsIGRvbWFpbkxvY2FsZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBsb2NhbGUgPSBsb2NhbGUgfHwgKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIGxvY2FsZSk7XG4gICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuIGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHtiYXNlUGF0aCB8fCAnJ30ke2xvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke2xvY2FsZX1gfSR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkTG9jYWxlKHBhdGgsIGxvY2FsZSwgZGVmYXVsdExvY2FsZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgICAgICBjb25zdCBwYXRoTG93ZXIgPSBwYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBsb2NhbGVMb3dlciA9IGxvY2FsZSAmJiBsb2NhbGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZSAmJiBsb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUgJiYgIXBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSAmJiBwYXRoTG93ZXIgIT09ICcvJyArIGxvY2FsZUxvd2VyID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpIDogcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBkZWxMb2NhbGUocGF0aCwgbG9jYWxlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZUxvd2VyID0gbG9jYWxlICYmIGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIChwYXRoTG93ZXIuc3RhcnRzV2l0aCgnLycgKyBsb2NhbGVMb3dlciArICcvJykgfHwgcGF0aExvd2VyID09PSAnLycgKyBsb2NhbGVMb3dlcikgPyAocGF0aG5hbWUubGVuZ3RoID09PSBsb2NhbGUubGVuZ3RoICsgMSA/ICcvJyA6ICcnKSArIHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSA6IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gcGF0aE5vUXVlcnlIYXNoKHBhdGgpIHtcbiAgICBjb25zdCBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gICAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKHF1ZXJ5SW5kZXggPiAtMSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aCkge1xuICAgIHBhdGggPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJyk7XG59XG5mdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoKSB7XG4gICAgLy8gd2Ugb25seSBhZGQgdGhlIGJhc2VwYXRoIG9uIHJlbGF0aXZlIHVybHNcbiAgICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aCk7XG59XG5mdW5jdGlvbiBkZWxCYXNlUGF0aChwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKTtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YDtcbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpIHx8IHVybC5zdGFydHNXaXRoKCcjJykgfHwgdXJsLnN0YXJ0c1dpdGgoJz8nKSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSAnJztcbiAgICBjb25zdCBkeW5hbWljUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xuICAgIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzO1xuICAgIGNvbnN0IGR5bmFtaWNNYXRjaGVzID0gLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fCAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG4gICAgcXVlcnk7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKTtcbiAgICBpZiAoIXBhcmFtcy5ldmVyeSgocGFyYW0pPT57XG4gICAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJztcbiAgICAgICAgY29uc3QgeyByZXBlYXQgLCBvcHRpb25hbCAgfSA9IGR5bmFtaWNHcm91cHNbcGFyYW1dO1xuICAgICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuICAgICAgICBsZXQgcmVwbGFjZWQgPSBgWyR7cmVwZWF0ID8gJy4uLicgOiAnJ30ke3BhcmFtfV1gO1xuICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiYgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9IGludGVycG9sYXRlZFJvdXRlLnJlcGxhY2UocmVwbGFjZWQsIHJlcGVhdCA/IHZhbHVlLm1hcCgvLyB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGZ1bGx5IGVuY29kZWQgaW5zdGVhZCBvZiBqdXN0XG4gICAgICAgIC8vIHBhdGggZGVsaW1pdGVyIGVzY2FwZWQgc2luY2UgdGhleSBhcmUgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgLy8gaW50byB0aGUgVVJMIGFuZCB3ZSBleHBlY3QgVVJMIGVuY29kZWQgc2VnbWVudHNcbiAgICAgICAgLy8gd2hlbiBwYXJzaW5nIGR5bmFtaWMgcm91dGUgcGFyYW1zXG4gICAgICAgIChzZWdtZW50KT0+ZW5jb2RlVVJJQ29tcG9uZW50KHNlZ21lbnQpXG4gICAgICAgICkuam9pbignLycpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkgfHwgJy8nKTtcbiAgICB9KSkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5mdW5jdGlvbiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcykge1xuICAgIGNvbnN0IGZpbHRlcmVkUXVlcnkgPSB7XG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBpZiAoIXBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFF1ZXJ5W2tleV0gPSBxdWVyeVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkUXVlcnk7XG59XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKGhyZWYpO1xuICAgIC8vIHJlcGVhdGVkIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSBVUkwgYXJlIGNvbnNpZGVyZWRcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcbiAgICBjb25zdCB1cmxQcm90b01hdGNoID0gdXJsQXNTdHJpbmcubWF0Y2goL15bYS16QS1aXXsxLH06XFwvXFwvLyk7XG4gICAgY29uc3QgdXJsQXNTdHJpbmdOb1Byb3RvID0gdXJsUHJvdG9NYXRjaCA/IHVybEFzU3RyaW5nLnN1YnN0cih1cmxQcm90b01hdGNoWzBdLmxlbmd0aCkgOiB1cmxBc1N0cmluZztcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybEFzU3RyaW5nTm9Qcm90by5zcGxpdCgnPycpO1xuICAgIGlmICgodXJsUGFydHNbMF0gfHwgJycpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBocmVmIHBhc3NlZCB0byBuZXh0L3JvdXRlcjogJHt1cmxBc1N0cmluZ30sIHJlcGVhdGVkIGZvcndhcmQtc2xhc2hlcyAoLy8pIG9yIGJhY2tzbGFzaGVzIFxcXFwgYXJlIG5vdCB2YWxpZCBpbiB0aGUgaHJlZmApO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscykubm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogJycpICsgbm9ybWFsaXplZFVybDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsQXNTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICB1cmxBc1N0cmluZ1xuICAgICAgICBdIDogdXJsQXNTdHJpbmc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKHVybEFzU3RyaW5nLnN0YXJ0c1dpdGgoJyMnKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsICdodHRwOi8vbicpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gLyBmb3IgaW52YWxpZCBhc1BhdGggdmFsdWVzIGUuZy4gLy9cbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoJy8nLCAnaHR0cDovL24nKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gJyc7XG4gICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJiByZXNvbHZlQXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gKDAsIF9xdWVyeXN0cmluZykuc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShmaW5hbFVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgLCBwYXJhbXMgIH0gPSBpbnRlcnBvbGF0ZUFzKGZpbmFsVXJsLnBhdGhuYW1lLCBmaW5hbFVybC5wYXRobmFtZSwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZEFzID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIF0gOiByZXNvbHZlZEhyZWY7XG4gICAgfSBjYXRjaCAoXzEpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIGNvbnN0IGhyZWZIYWRPcmlnaW4gPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIGNvbnN0IGFzSGFkT3JpZ2luID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZkhhZE9yaWdpbiA/IHJlc29sdmVkSHJlZiA6IGFkZEJhc2VQYXRoKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZUhyZWYocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzSGFkT3JpZ2luID8gcHJlcGFyZWRBcyA6IGFkZEJhc2VQYXRoKHByZXBhcmVkQXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKSB7XG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goKDAsIF9kZW5vcm1hbGl6ZVBhZ2VQYXRoKS5kZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhdGhuYW1lKSk7XG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpPT57XG4gICAgICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHBhZ2UpICYmICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xufVxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiYgISFmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgdiA9ICdfX25leHQnO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICB9XG59KCk7XG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRzKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ1xuICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cy50ZXh0ID8gcmVzLnRleHQoKSA6IHJlcy5qc29uKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciwgdGV4dCwgaW5mbGlnaHRDYWNoZSwgcGVyc2lzdENhY2hlKSB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSAgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBpZiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgICAgdGV4dFxuICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgICAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgICAgICAvLyBsb29wLlxuICAgICAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5tYXJrQXNzZXRFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICBpZiAoIXBlcnNpc3RDYWNoZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG59XG5jbGFzcyBSb3V0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzICwgcGFnZUxvYWRlciAsIEFwcCAsIHdyYXBBcHAgLCBDb21wb25lbnQgLCBlcnIgLCBzdWJzY3JpcHRpb24gLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRlZmF1bHRMb2NhbGUgLCBkb21haW5Mb2NhbGVzICwgaXNQcmV2aWV3ICB9KXtcbiAgICAgICAgLy8gU3RhdGljIERhdGEgQ2FjaGVcbiAgICAgICAgdGhpcy5zZGMgPSB7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluLWZsaWdodCBTZXJ2ZXIgRGF0YSBSZXF1ZXN0cywgZm9yIGRlZHVwaW5nXG4gICAgICAgIHRoaXMuc2RyID0ge1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbi1mbGlnaHQgbWlkZGxld2FyZSBwcmVmbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgdGhpcy5zZGUgPSB7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2lkeCA9IDA7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgICAgICAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscykuZ2V0VVJMKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwgaWR4ICB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9pZHgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faWR4ID0gaWR4O1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgICAgICAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgfSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIHRoaXMucm91dGUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICAgICAgICAgICAgX19OX1JTQzogISEoKHJlZiA9IENvbXBvbmVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuX19uZXh0X3JzY19fKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgICAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHM7XG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYXNQYXRoID0gYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzO1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGg7XG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgICAgIHRoaXMuaXNTc3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIHRoaXMuaXNQcmV2aWV3ID0gISFpc1ByZXZpZXc7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMgIT09IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscykuZ2V0VVJMKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zID0ge1xuICAgIH0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9pZHgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNoYW5nZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMsIGZvcmNlZFNjcm9sbCkge1xuICAgICAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvdWxkUmVzb2x2ZUhyZWYgPSBvcHRpb25zLl9oIHx8IG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmIHx8IHBhdGhOb1F1ZXJ5SGFzaCh1cmwpID09PSBwYXRoTm9RdWVyeUhhc2goYXMpO1xuICAgICAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgICAgIGlmIChvcHRpb25zLl9oKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZMb2NhbGUgPSB0aGlzLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID8gdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXJzZWRBcy5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGhhc0Jhc2VQYXRoKHVybCkgPyBkZWxCYXNlUGF0aCh1cmwpIDogdXJsLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKHJlZiA9IHRoaXMubG9jYWxlcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuaW5jbHVkZXModGhpcy5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKHRoaXMuZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiB0aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSBkZWxCYXNlUGF0aChhcyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke2FkZEJhc2VQYXRoKGAke3RoaXMubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7dGhpcy5sb2NhbGV9YH0ke2FzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGh9YCB8fCAnLycpfWA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9PntcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuX2gpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ID1mYWxzZSAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7XG4gICAgICAgICAgICBzaGFsbG93XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29tcG9uZW50TG9hZCh0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBhcyA9IGFkZEJhc2VQYXRoKGFkZExvY2FsZShoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsIHRoaXMubG9jYWxlKTtcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICBsZXQgbG9jYWxlQ2hhbmdlID0gcHJldkxvY2FsZSAhPT0gdGhpcy5sb2NhbGU7XG4gICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBpZiAoIW9wdGlvbnMuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAgICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLmdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZUxpc3QoKSwgXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgICAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XG4gICAgICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAgICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lID8gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChkZWxCYXNlUGF0aChwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZVJld3JpdGVzKS5kZWZhdWx0KGFkZEJhc2VQYXRoKGFkZExvY2FsZShjbGVhbmVkQXMsIHRoaXMubG9jYWxlKSksIHBhZ2VzLCByZXdyaXRlcywgcXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcylcbiAgICAgICAgICAgICAgICAsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTG9jYWxVUkwoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgKyBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGUgcm91dGUgdXBkYXRlIHdhcyB0cmlnZ2VyZWQgZm9yIGNsaWVudC1zaWRlIGh5ZHJhdGlvbiB0aGVuXG4gICAgICogZG8gbm90IGNoZWNrIHRoZSBwcmVmbGlnaHQgcmVxdWVzdC4gT3RoZXJ3aXNlIHdoZW4gcmVuZGVyaW5nXG4gICAgICogYSBwYWdlIHdpdGggcmVmcmVzaCBpdCBtaWdodCBnZXQgaW50byBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAqLyBpZiAob3B0aW9ucy5faCAhPT0gMSkge1xuICAgICAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgY2FjaGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgIC4uLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGVmZmVjdC5hc1BhdGg7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBlZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0Lm5ld0FzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgZWZmZWN0Lm5ld1VybCwgZWZmZWN0Lm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBlZmZlY3QuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVmZmVjdC50eXBlID09PSAncmVmcmVzaCcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSA6IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtzaG91bGRJbnRlcnBvbGF0ZSA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbignLCAnKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8ocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgbGV0IHsgZXJyb3IgLCBwcm9wcyAsIF9fTl9TU0cgLCBfX05fU1NQICB9ID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKF9fTl9TU0cgfHwgX19OX1NTUCkgJiYgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucGFnZVByb3BzICYmIHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ByZXZpZXcgPSAhIXByb3BzLl9fTl9QUkVWSUVXO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCc7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8obm90Rm91bmRSb3V0ZSwgbm90Rm91bmRSb3V0ZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5faCAmJiBwYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChyZWYxID0gcmVmLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS5zdGF0dXNDb2RlKSA9PT0gNTAwICYmIChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGU7XG4gICAgICAgICAgICB2YXIgX3Njcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9PSBudWxsICYmIF9zY3JvbGwgIT09IHZvaWQgMCA/IF9zY3JvbGwgOiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBjbGVhbmVkQXMsIHJvdXRlSW5mbywgZm9yY2VkU2Nyb2xsICE9PSBudWxsICYmIGZvcmNlZFNjcm9sbCAhPT0gdm9pZCAwID8gZm9yY2VkU2Nyb2xsIDogcmVzZXRTY3JvbGwpLmNhdGNoKChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycjEpICYmIGVycjEuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCAoMCwgX3V0aWxzKS5nZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAgaWR4OiB0aGlzLl9pZHggPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5faWR4IDogdGhpcy5faWR4ICsgMVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICcnLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3JvdXRlTG9hZGVyKS5pc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgQ29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlU2hlZXRzO1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBzdHlsZVNoZWV0cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAoeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArICcnKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUm91dGVJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIGNhbiBvbmx5IHVzZSBub24taW5pdGlhbCByb3V0ZSBpbmZvXG4gICAgICAgICAgICAvLyBjYW5ub3QgcmV1c2Ugcm91dGUgaW5mbyBpbiBkZXZlbG9wbWVudCBzaW5jZSBpdCBjYW4gY2hhbmdlIGFmdGVyIEhNUlxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmIGV4aXN0aW5nUm91dGVJbmZvICYmICEoJ2luaXRpYWwnIGluIGV4aXN0aW5nUm91dGVJbmZvKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nUm91dGVJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgICAgICAgICAgICBfX05fUlNDOiAhIXJlcy5wYWdlLl9fbmV4dF9yc2NfX1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgeyBDb21wb25lbnQgLCBfX05fU1NHICwgX19OX1NTUCAsIF9fTl9SU0MgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YUhyZWY7XG4gICAgICAgICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQIHx8IF9fTl9SU0MpIHtcbiAgICAgICAgICAgICAgICBkYXRhSHJlZiA9IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgc3NnOiBfX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICByc2M6IF9fTl9SU0MsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YSgoKT0+X19OX1NTRyB8fCBfX05fU1NQID8gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzciwgZmFsc2UsIF9fTl9TU0cgPyB0aGlzLnNkYyA6IHRoaXMuc2RyLCAhIV9fTl9TU0cgJiYgIXRoaXMuaXNQcmV2aWV3KSA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlczogdGhpcy5sb2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChfX05fUlNDKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcmVzaCAsIGRhdGEgIH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKCgpPT50aGlzLl9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbihwcm9wcy5wYWdlUHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgX19mbGlnaHRfc2VyaWFsaXplZF9fOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBfX2ZsaWdodF9mcmVzaF9fOiBmcmVzaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzRXJyb3IpLmRlZmF1bHQoZXJyKSA/IGVyciA6IG5ldyBFcnJvcihlcnIgKyAnJyksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgZGF0YSwgcmVzZXRTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5pc0ZhbGxiYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuYXNQYXRoID0gYXM7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhLCByZXNldFNjcm9sbCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi8gYmVmb3JlUG9wU3RhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5fYnBzID0gY2I7XG4gICAgfVxuICAgIG9ubHlBSGFzaENoYW5nZShhcykge1xuICAgICAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSAnJyB8fCBoYXNoID09PSAndG9wJykge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdO1xuICAgICAgICBpZiAobmFtZUVsKSB7XG4gICAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoID0gdXJsLCBvcHRpb25zID0ge1xuICAgIH0pIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9ID0gYXdhaXQgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzUGF0aCwgdGhpcy5sb2NhbGUpKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcylcbiAgICAgICAgICAgICwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZmZlY3RzID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICBhczogYWRkQmFzZVBhdGgoYXNQYXRoKSxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWZmZWN0cy50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGVmZmVjdHMucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBlZmZlY3RzLnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmVmZmVjdHMucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZWZmZWN0cy5hc1BhdGg7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEodGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIHNzZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiB0aGlzLmxvY2FsZVxuICAgICAgICAgICAgICAgIH0pLCBmYWxzZSwgZmFsc2UsIHRoaXMuc2RjLCB0cnVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksIFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSB0aGlzLmNsYyA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHRoaXMuc2RjW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZnJlc2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuc2RjW2NhY2hlS2V5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRydWUsIHRydWUsIHRoaXMuc2RjLCBmYWxzZSkudGhlbigoc2VyaWFsaXplZCk9PntcbiAgICAgICAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IHNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyZXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHNlcmlhbGl6ZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfcHJlZmxpZ2h0UmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShoYXNCYXNlUGF0aChvcHRpb25zLmFzKSA/IGRlbEJhc2VQYXRoKG9wdGlvbnMuYXMpIDogb3B0aW9ucy5hcywgdGhpcy5sb2NhbGUpO1xuICAgICAgICBjb25zdCBmbnMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZUxpc3QoKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZXNQcmVmbGlnaHQgPSBmbnMuc29tZSgoW21pZGRsZXdhcmUsIGlzU1NSXSk9PntcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfZ2V0TWlkZGxld2FyZVJlZ2V4KS5nZXRNaWRkbGV3YXJlUmVnZXgobWlkZGxld2FyZSwgIWlzU1NSKSkoY2xlYW5lZEFzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVxdWlyZXNQcmVmbGlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZsaWdodCA9IGF3YWl0IHRoaXMuX2dldFByZWZsaWdodERhdGEoe1xuICAgICAgICAgICAgcHJlZmxpZ2h0SHJlZjogb3B0aW9ucy5hcyxcbiAgICAgICAgICAgIHNob3VsZENhY2hlOiBvcHRpb25zLmNhY2hlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKHJlZiA9IHByZWZsaWdodC5yZXdyaXRlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoaGFzQmFzZVBhdGgocHJlZmxpZ2h0LnJld3JpdGUpID8gZGVsQmFzZVBhdGgocHJlZmxpZ2h0LnJld3JpdGUpIDogcHJlZmxpZ2h0LnJld3JpdGUsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZnNQYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGFyc2VkLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIGxldCBtYXRjaGVkUGFnZTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRQYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWYgPSBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWYgPSByZXNvbHZlRHluYW1pY1JvdXRlKGZzUGF0aG5hbWUsIG9wdGlvbnMucGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZEhyZWYgIT09IHBhcnNlZC5wYXRobmFtZSAmJiBvcHRpb25zLnBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jld3JpdGUnLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogcGFyc2VkLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWQsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmbGlnaHQucmVkaXJlY3QpIHtcbiAgICAgICAgICAgIGlmIChwcmVmbGlnaHQucmVkaXJlY3Quc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5SZWRpcmVjdCA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGhhc0Jhc2VQYXRoKHByZWZsaWdodC5yZWRpcmVjdCkgPyBkZWxCYXNlUGF0aChwcmVmbGlnaHQucmVkaXJlY3QpIDogcHJlZmxpZ2h0LnJlZGlyZWN0LCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsICwgYXM6IG5ld0FzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIGNsZWFuUmVkaXJlY3QsIGNsZWFuUmVkaXJlY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIG5ld1VybCxcbiAgICAgICAgICAgICAgICAgICAgbmV3QXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVkaXJlY3QnLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBwcmVmbGlnaHQucmVkaXJlY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIFNTUiByZXF1ZXN0cywgdGhleSB3aWxsIGJlIGhhbmRsZWQgbGlrZSBub3JtYWwgcGFnZXMuXG4gICAgICAgIGlmIChwcmVmbGlnaHQucmVmcmVzaCAmJiAhcHJlZmxpZ2h0LnNzcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVmcmVzaCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICduZXh0J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0UHJlZmxpZ2h0RGF0YShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmbGlnaHRIcmVmICwgc2hvdWxkQ2FjaGUgPWZhbHNlICB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChwcmVmbGlnaHRIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICF0aGlzLmlzUHJldmlldyAmJiBzaG91bGRDYWNoZSAmJiB0aGlzLnNkZVtjYWNoZUtleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGVbY2FjaGVLZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2gocHJlZmxpZ2h0SHJlZiwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAneC1taWRkbGV3YXJlLXByZWZsaWdodCc6ICcxJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKChyZXMpPT57XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHByZWZsaWdodCByZXF1ZXN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZXMuaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyksXG4gICAgICAgICAgICAgICAgcmVmcmVzaDogcmVzLmhlYWRlcnMuaGFzKCd4LW1pZGRsZXdhcmUtcmVmcmVzaCcpLFxuICAgICAgICAgICAgICAgIHJld3JpdGU6IHJlcy5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLXJld3JpdGUnKSxcbiAgICAgICAgICAgICAgICBzc3I6ICEhcmVzLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtc3NyJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNkZVtjYWNoZUtleV0gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zZGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ107XG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCk7XG4gICAgICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZTtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCB7XG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhYm9ydENvbXBvbmVudExvYWQoYXMsIHJvdXRlUHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuY2xjKCk7XG4gICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50LCByZXNldFNjcm9sbCk7XG4gICAgfVxufVxuUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dCkuZGVmYXVsdCgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RG9tYWluTG9jYWxlIiwiYWRkTG9jYWxlIiwiZGVsTG9jYWxlIiwiaGFzQmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsImRlbEJhc2VQYXRoIiwiaXNMb2NhbFVSTCIsImludGVycG9sYXRlQXMiLCJyZXNvbHZlSHJlZiIsImRlZmF1bHQiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsInJlcXVpcmUiLCJfcm91dGVMb2FkZXIiLCJfaXNFcnJvciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZGVub3JtYWxpemVQYWdlUGF0aCIsIl9ub3JtYWxpemVMb2NhbGVQYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNEeW5hbWljIiwiX3BhcnNlUmVsYXRpdmVVcmwiLCJfcXVlcnlzdHJpbmciLCJfcmVzb2x2ZVJld3JpdGVzIiwiX3JvdXRlTWF0Y2hlciIsIl9yb3V0ZVJlZ2V4IiwiX2dldE1pZGRsZXdhcmVSZWdleCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImJhc2VQYXRoIiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsImFkZFBhdGhQcmVmaXgiLCJwYXRoIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicGF0aE5vUXVlcnlIYXNoIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJzdWJzdHIiLCJsZW5ndGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3RlZExvY2FsZSIsImRldGVjdGVkRG9tYWluIiwidW5kZWZpbmVkIiwiaHR0cCIsImRvbWFpbiIsImRlZmF1bHRMb2NhbGUiLCJwYXRoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUxvd2VyIiwicXVlcnlJbmRleCIsImluZGV4T2YiLCJoYXNoSW5kZXgiLCJzdWJzdHJpbmciLCJzbGljZSIsInVybCIsImxvY2F0aW9uT3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsIlVSTCIsIm9yaWdpbiIsIl8iLCJyb3V0ZSIsImFzUGF0aG5hbWUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInBhcmFtcyIsImtleXMiLCJldmVyeSIsInBhcmFtIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsImZpbHRlcmVkUXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiLCJyb3V0ZXIiLCJocmVmIiwicmVzb2x2ZUFzIiwiYmFzZSIsInVybEFzU3RyaW5nIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJ1cmxQcm90b01hdGNoIiwibWF0Y2giLCJ1cmxBc1N0cmluZ05vUHJvdG8iLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImFzUGF0aCIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpc0R5bmFtaWNSb3V0ZSIsInNlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJoYXNoIiwicmVzb2x2ZWRIcmVmIiwiXzEiLCJzdHJpcE9yaWdpbiIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZWRBcyIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJzb21lIiwicGFnZSIsInJlIiwidGVzdCIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJvcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInRoZW4iLCJyZXMiLCJvayIsInN0YXR1cyIsImpzb24iLCJkYXRhIiwibm90Rm91bmQiLCJ0ZXh0IiwiZmV0Y2hOZXh0RGF0YSIsImRhdGFIcmVmIiwiaXNTZXJ2ZXJSZW5kZXIiLCJpbmZsaWdodENhY2hlIiwicGVyc2lzdENhY2hlIiwibG9jYXRpb24iLCJjYWNoZUtleSIsImNhdGNoIiwiZXJyIiwibWFya0Fzc2V0RXJyb3IiLCJSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJwYWdlTG9hZGVyIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsInN1YnNjcmlwdGlvbiIsImlzRmFsbGJhY2siLCJpc1ByZXZpZXciLCJzZGMiLCJzZHIiLCJzZGUiLCJfaWR4Iiwib25Qb3BTdGF0ZSIsImUiLCJzdGF0ZSIsImNoYW5nZVN0YXRlIiwiZ2V0VVJMIiwiX19OIiwiZm9yY2VkU2Nyb2xsIiwib3B0aW9ucyIsImlkeCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0SXRlbSIsInBhcnNlIiwicGFyc2VSZWxhdGl2ZVVybCIsImlzU3NyIiwiX2JwcyIsImNoYW5nZSIsInNoYWxsb3ciLCJfc2hhbGxvdyIsImNvbXBvbmVudHMiLCJyZWYiLCJpbml0aWFsIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsIl9fTl9SU0MiLCJfX25leHRfcnNjX18iLCJzdHlsZVNoZWV0cyIsImV2ZW50cyIsImF1dG9FeHBvcnREeW5hbWljIiwiX19ORVhUX0RBVEFfXyIsImF1dG9FeHBvcnQiLCJzdWIiLCJjbGMiLCJfd3JhcEFwcCIsImlzUmVhZHkiLCJnc3NwIiwiZ2lwIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsImlzTG9jYWxlRG9tYWluIiwiaG9zdG5hbWUiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJyZWxvYWQiLCJiYWNrIiwicHVzaCIsIm1ldGhvZCIsInNob3VsZFJlc29sdmVIcmVmIiwicHJldkxvY2FsZSIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRpZE5hdmlnYXRlIiwiYXNOb0Jhc2VQYXRoIiwicm91dGVQcm9wcyIsImNsZWFuZWRBcyIsImxvY2FsZUNoYW5nZSIsInBhcnNlZCIsInJld3JpdGVzIiwicmV3cml0ZXNSZXN1bHQiLCJlZmZlY3QiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJlZjEiLCJyb3V0ZUluZm8iLCJkZXN0aW5hdGlvbiIsInBhcnNlZEhyZWYiLCJuZXdVcmwiLCJuZXdBcyIsIm5vdEZvdW5kUm91dGUiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiX3Njcm9sbCIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwiX2giLCJQcm9taXNlIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJfaW5GbGlnaHRSb3V0ZSIsImFib3J0Q29tcG9uZW50TG9hZCIsIm9ubHlBSGFzaENoYW5nZSIsImVtaXQiLCJzY3JvbGxUb0hhc2giLCJub3RpZnkiLCJhbGwiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJnZXRNaWRkbGV3YXJlTGlzdCIsIl9fcmV3cml0ZXMiLCJ1cmxJc05ldyIsInAiLCJtYXRjaGVkUGFnZSIsIl9wcmVmbGlnaHRSZXF1ZXN0IiwiY2FjaGUiLCJ0eXBlIiwiZmlsdGVyIiwid2FybiIsImdldFJvdXRlSW5mbyIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJfX05fUFJFVklFVyIsImZldGNoQ29tcG9uZW50Iiwic3RhdHVzQ29kZSIsInNjcm9sbCIsInNldCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsImV4aXN0aW5nUm91dGVJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZnJlc2giLCJtb2QiLCJnZXREYXRhSHJlZiIsInNzZyIsInJzYyIsIl9nZXREYXRhIiwiX2dldEZsaWdodERhdGEiLCJfX2ZsaWdodF9zZXJpYWxpemVkX18iLCJfX2ZsaWdodF9mcmVzaF9fIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwic2Nyb2xsVG8iLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwicHJlZmV0Y2giLCJlZmZlY3RzIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsImNhbmNlbCIsImhhbmRsZUNhbmNlbGxlZCIsImNvbXBvbmVudFJlc3VsdCIsImxvYWRQYWdlIiwiZm4iLCJyZXNvbHZlIiwic2VyaWFsaXplZCIsImZucyIsInJlcXVpcmVzUHJlZmxpZ2h0IiwicHJlZmxpZ2h0IiwiZnNQYXRobmFtZSIsImNsZWFuUmVkaXJlY3QiLCJtaWRkbGV3YXJlIiwiaXNTU1IiLCJnZXRNaWRkbGV3YXJlUmVnZXgiLCJfZ2V0UHJlZmxpZ2h0RGF0YSIsInByZWZsaWdodEhyZWYiLCJzaG91bGRDYWNoZSIsInJld3JpdGUiLCJyZWRpcmVjdCIsInJlZnJlc2giLCJzc3IiLCJoZWFkZXJzIiwiZ2V0IiwiaGFzIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n");

/***/ })

});